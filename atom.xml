<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DongHuiWang</title>
  
  
  <link href="https://donghuiw.github.io/atom.xml" rel="self"/>
  
  <link href="https://donghuiw.github.io/"/>
  <updated>2025-03-20T13:19:03.712Z</updated>
  <id>https://donghuiw.github.io/</id>
  
  <author>
    <name>DongHuiWang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HEngine游戏引擎-61-90</title>
    <link href="https://donghuiw.github.io/posts/75ada542"/>
    <id>https://donghuiw.github.io/posts/75ada542</id>
    <published>2025-03-17T12:43:17.000Z</published>
    <updated>2025-03-20T13:19:03.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六十一、打开-保存文件对话框">六十一、打开/保存文件对话框</h2><h4 id="前言">前言</h4><ul><li><p>此节目的</p><p>可以有询问<strong>对话框</strong>保存、解析场景</p><ul><li>新场景：不绘制的实体，创建一个空白的场景</li><li>保存场景：有对话框，问保存到本地哪个位置</li><li>加载场景：有对话框，从本地哪个位置加载场景，重新创建新场景</li></ul></li></ul><h4 id="关键代码">关键代码</h4><ul><li><p>EditorLayer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::NewScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建新场景 ，这段代码可解决 多次加载场景，会将新场景的实体和当前场景的实体一起呈现的bug</span></span><br><span class="line">    m_ActiveScene = <span class="built_in">CreateRef</span>&lt;Scene&gt;();</span><br><span class="line">    m_ActiveScene-&gt;<span class="built_in">OnViewportResize</span>((<span class="type">uint32_t</span>)m_ViewportSize.x, (<span class="type">uint32_t</span>)m_ViewportSize.y);</span><br><span class="line">    m_SceneHierarchyPanel.<span class="built_in">SetContext</span>(m_ActiveScene);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OpenScene</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string filepath = FileDialogs::<span class="built_in">OpenFile</span>(<span class="string">&quot;HEngine Scene (*.hengine)\0*.hengine\0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!filepath.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_ActiveScene = <span class="built_in">CreateRef</span>&lt;Scene&gt;();</span><br><span class="line">        m_ActiveScene-&gt;<span class="built_in">OnViewportResize</span>((<span class="type">uint32_t</span>)m_ViewportSize.x, (<span class="type">uint32_t</span>)m_ViewportSize.y);</span><br><span class="line">        m_SceneHierarchyPanel.<span class="built_in">SetContext</span>(m_ActiveScene);</span><br><span class="line"></span><br><span class="line">        <span class="function">SceneSerializer <span class="title">serializer</span><span class="params">(m_ActiveScene)</span></span>;</span><br><span class="line">        serializer.<span class="built_in">Deserialize</span>(filepath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::SaveSceneAs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string filepath = FileDialogs::<span class="built_in">SaveFile</span>(<span class="string">&quot;HEngine Scene (*.hengine)\0*.hengine\0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!filepath.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">SceneSerializer <span class="title">serializer</span><span class="params">(m_ActiveScene)</span></span>;</span><br><span class="line">        serializer.<span class="built_in">Serialize</span>(filepath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建PlatformUtils.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileDialogs</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//These return empty strings if cancelled</span></span><br><span class="line"><span class="function"><span class="type">static</span> std::string <span class="title">OpenFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filter)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> std::string <span class="title">SaveFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filter)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowsPlatformUtils.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">FileDialogs::OpenFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OPENFILENAMEA ofn;       <span class="comment">// Windows API 结构体，用于存储对话框的信息</span></span><br><span class="line">    CHAR szFile[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 存储选中文件的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;ofn, <span class="built_in">sizeof</span>(OPENFILENAME)); <span class="comment">// 清空结构体数据</span></span><br><span class="line">    ofn.lStructSize = <span class="built_in">sizeof</span>(OPENFILENAME); <span class="comment">// 结构体大小</span></span><br><span class="line">    ofn.hwndOwner = <span class="built_in">glfwGetWin32Window</span>((GLFWwindow*)Application::<span class="built_in">Get</span>().<span class="built_in">GetWindow</span>().<span class="built_in">GetNativeWindow</span>()); <span class="comment">// 获取窗口句柄</span></span><br><span class="line">    ofn.lpstrFile = szFile;   <span class="comment">// 指定缓冲区存储文件路径</span></span><br><span class="line">    ofn.nMaxFile = <span class="built_in">sizeof</span>(szFile); <span class="comment">// 设置最大文件路径长度</span></span><br><span class="line">    ofn.lpstrFilter = filter; <span class="comment">// 设置文件筛选器（如 `&quot;Text Files\0*.txt\0All Files\0*.*\0&quot;`）</span></span><br><span class="line">    ofn.nFilterIndex = <span class="number">1</span>;     <span class="comment">// 默认选择第一个筛选项</span></span><br><span class="line">    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR; <span class="comment">// 设置对话框标志</span></span><br><span class="line">    <span class="comment">// 打开文件选择对话框</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetOpenFileNameA</span>(&amp;ofn) == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ofn.lpstrFile; <span class="comment">// 返回选中的文件路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 用户取消时返回空字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">FileDialogs::SaveFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OPENFILENAMEA ofn;</span><br><span class="line">    CHAR szFile[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ZeroMemory</span>(&amp;ofn, <span class="built_in">sizeof</span>(OPENFILENAME));</span><br><span class="line">    ofn.lStructSize = <span class="built_in">sizeof</span>(OPENFILENAME);</span><br><span class="line">    ofn.hwndOwner = <span class="built_in">glfwGetWin32Window</span>((GLFWwindow*)Application::<span class="built_in">Get</span>().<span class="built_in">GetWindow</span>().<span class="built_in">GetNativeWindow</span>());</span><br><span class="line">    ofn.lpstrFile = szFile;</span><br><span class="line">    ofn.nMaxFile = <span class="built_in">sizeof</span>(szFile);</span><br><span class="line">    ofn.lpstrFilter = filter;</span><br><span class="line">    ofn.nFilterIndex = <span class="number">1</span>;</span><br><span class="line">    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开文件保存对话框</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">GetSaveFileNameA</span>(&amp;ofn) == TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ofn.lpstrFile; <span class="comment">// 返回保存的文件路径</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;; <span class="comment">// 用户取消时返回空字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EditorLayer.cpp 快捷键功能实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">EventDispatcher <span class="title">dispatcher</span><span class="params">(e)</span></span>;</span><br><span class="line">    dispatcher.<span class="built_in">Dispatch</span>&lt;KeyPressedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(EditorLayer::OnKeyPressed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EditorLayer::OnKeyPressed</span><span class="params">(KeyPressedEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="built_in">GetRepeatCount</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> control = Input::<span class="built_in">IsKeyPressed</span>(Key::LeftControl) || Input::<span class="built_in">IsKeyPressed</span>(Key::RightControl);</span><br><span class="line">    <span class="type">bool</span> shift = Input::<span class="built_in">IsKeyPressed</span>(Key::LeftShift) || Input::<span class="built_in">IsKeyPressed</span>(Key::RightShift);</span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="built_in">GetKeyCode</span>()) &#123;</span><br><span class="line">        <span class="keyword">case</span> Key::N: &#123;</span><br><span class="line">            <span class="keyword">if</span> (control) &#123;</span><br><span class="line">                <span class="built_in">NewScene</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Key::O: &#123;</span><br><span class="line">            <span class="keyword">if</span> (control) &#123;</span><br><span class="line">                <span class="built_in">OpenScene</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> Key::S: &#123;</span><br><span class="line">            <span class="keyword">if</span> (control &amp;&amp; shift) &#123;</span><br><span class="line">                <span class="built_in">SaveSceneAs</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存当前场景:要有一个记录当前场景的路径。</span></span><br><span class="line">            <span class="keyword">if</span> (control) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="六十二、添加gizmos">六十二、添加gizmos</h2><h4 id="前言-2">前言</h4><ul><li><p>目的</p><p>为实现像大多3D软件那种，点击物体，会有那种拖动、缩放、旋转的辅助小程序。利用开源的imguizmo库，<a href="https://github.com/CedricGuillemet/ImGuizmo">网址</a></p></li><li><p>介绍imguizmo</p><p>ImGizmo是一个建立在<strong>Dear ImGu</strong>i之上的小型（.h和.cpp）库，允许你操作（目前是旋转和平移）4x4浮点矩阵，没有其他依赖性。编写时考虑到了即时模式（IM）的理念。</p></li></ul><h4 id="关键代码-2">关键代码</h4><p>EditorLayer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Gizmo 操作部分</span></span><br><span class="line">Entity selectedEntity = m_SceneHierarchyPanel.<span class="built_in">GetSelectedEntity</span>(); <span class="comment">// 获取当前选中的实体</span></span><br><span class="line"><span class="keyword">if</span> (selectedEntity &amp;&amp; m_GizmoType != <span class="number">-1</span>) <span class="comment">// 如果实体存在且 Gizmo 类型不为 -1（即 Gizmo 被启用）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 设置 ImGuizmo 的投影模式和绘制选项</span></span><br><span class="line">    ImGuizmo::<span class="built_in">SetOrthographic</span>(<span class="literal">false</span>); <span class="comment">// 设置投影为透视投影（false 表示不是正交投影）</span></span><br><span class="line">    ImGuizmo::<span class="built_in">SetDrawlist</span>(); <span class="comment">// 设置 Gizmo 的绘制列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前窗口的宽度和高度，用来设置 Gizmo 操作区域的大小</span></span><br><span class="line">    <span class="type">float</span> windowWidth = ImGui::<span class="built_in">GetWindowWidth</span>();</span><br><span class="line">    <span class="type">float</span> windowHeight = ImGui::<span class="built_in">GetWindowHeight</span>();</span><br><span class="line">    <span class="comment">// 设置 Gizmo 的矩形区域</span></span><br><span class="line">    ImGuizmo::<span class="built_in">SetRect</span>(ImGui::<span class="built_in">GetWindowPos</span>().x, ImGui::<span class="built_in">GetWindowPos</span>().y, windowWidth, windowHeight);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取主摄像机实体</span></span><br><span class="line">    <span class="keyword">auto</span> cameraEntity = m_ActiveScene-&gt;<span class="built_in">GetPrimaryCameraEntity</span>(); </span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; camera = cameraEntity.<span class="built_in">GetComponent</span>&lt;CameraComponent&gt;().Camera; <span class="comment">// 获取摄像机组件</span></span><br><span class="line">    <span class="type">const</span> glm::mat4&amp; cameraProjection = camera.<span class="built_in">GetProjection</span>(); <span class="comment">// 获取摄像机的投影矩阵</span></span><br><span class="line">    glm::mat4 cameraView = glm::<span class="built_in">inverse</span>(cameraEntity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;().<span class="built_in">GetTransform</span>()); <span class="comment">// 获取摄像机的视图矩阵，通常为相机的变换矩阵的逆矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取选中实体的变换信息</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; tc = selectedEntity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;(); <span class="comment">// 获取选中实体的 Transform 组件</span></span><br><span class="line">    glm::mat4 transform = tc.<span class="built_in">GetTransform</span>(); <span class="comment">// 获取选中实体的当前变换矩阵</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Snapping 设置</span></span><br><span class="line">    <span class="type">bool</span> snap = Input::<span class="built_in">IsKeyPressed</span>(Key::LeftControl); <span class="comment">// 如果按下了控制键，则启用 snap（对齐）</span></span><br><span class="line">    <span class="type">float</span> snapValue = <span class="number">0.5f</span>; <span class="comment">// 默认情况下，平移和缩放对齐的步长是 0.5m</span></span><br><span class="line">    <span class="comment">// 如果当前操作是旋转，则将对齐步长设置为 45 度</span></span><br><span class="line">    <span class="keyword">if</span> (m_GizmoType == ImGuizmo::OPERATION::ROTATE)</span><br><span class="line">        snapValue = <span class="number">45.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义每个轴的对齐值（此处所有轴的对齐步长相同）</span></span><br><span class="line">    <span class="type">float</span> snapValues[<span class="number">3</span>] = &#123; snapValue, snapValue, snapValue &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 ImGuizmo 进行变换操作，传入视图矩阵、投影矩阵、操作类型（平移、旋转或缩放）、变换类型（局部/全局）和变换矩阵</span></span><br><span class="line">    <span class="comment">// 如果启用了 snap 对齐，则传入对齐步长</span></span><br><span class="line">    ImGuizmo::<span class="built_in">Manipulate</span>(glm::<span class="built_in">value_ptr</span>(cameraView), glm::<span class="built_in">value_ptr</span>(cameraProjection),</span><br><span class="line">        (ImGuizmo::OPERATION)m_GizmoType, ImGuizmo::LOCAL, glm::<span class="built_in">value_ptr</span>(transform),</span><br><span class="line">        <span class="literal">nullptr</span>, snap ? snapValues : <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正在使用 Gizmo（即操作发生了变化）</span></span><br><span class="line">    <span class="keyword">if</span> (ImGuizmo::<span class="built_in">IsUsing</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 将变换矩阵分解为平移、旋转和缩放分量</span></span><br><span class="line">        glm::vec3 translation, rotation, scale;</span><br><span class="line">        Math::<span class="built_in">DecomposeTransform</span>(transform, translation, rotation, scale);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算旋转的增量（用于处理局部变换）</span></span><br><span class="line">        glm::vec3 deltaRotation = rotation - tc.Rotation;</span><br><span class="line">        <span class="comment">// 更新实体的变换信息（平移、旋转、缩放）</span></span><br><span class="line">        tc.Translation = translation;</span><br><span class="line">        tc.Rotation += deltaRotation; <span class="comment">// 增加旋转增量</span></span><br><span class="line">        tc.Scale = scale;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EditorLayer::OnKeyPressed</span><span class="params">(KeyPressedEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Gizmos</span></span><br><span class="line">    <span class="keyword">case</span> Key::Q:</span><br><span class="line">        m_GizmoType = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Key::W:</span><br><span class="line">        m_GizmoType = ImGuizmo::OPERATION::TRANSLATE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Key::E:</span><br><span class="line">        m_GizmoType = ImGuizmo::OPERATION::ROTATE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Key::R:</span><br><span class="line">        m_GizmoType = ImGuizmo::OPERATION::SCALE;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="六十三、编辑时的摄像机">六十三、编辑时的摄像机</h2><h4 id="前言-3">前言</h4><ul><li><p>目的</p><p>实现像Unity<strong>编辑时</strong>有一个编辑摄像机呈现画面给开发人员，<strong>运行时</strong>有一个主摄像机呈现游戏画面给玩家。</p></li><li><p>实现细节</p><ol><li>编辑时摄像机是<strong>透视投影</strong>摄像机</li><li>编辑时摄像机缩小<strong>不会透过</strong>实体，这样更简单实现</li><li>编辑时摄像机越<strong>接近</strong>实体，它的放大范围越<strong>小</strong></li><li>不同FPS第一人称摄像机，这个编辑式摄像机是围绕一个点旋转平移的摄像机</li></ol></li></ul><h4 id="编辑时摄像机大致运行流程">编辑时摄像机大致运行流程</h4><ul><li><p>设置好编辑时摄像机参数：宽高比、视角角度、近、远</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_EditorCamera = <span class="built_in">EditorCamera</span>(<span class="number">30.0f</span>, <span class="number">1.778f</span>, <span class="number">0.1f</span>, <span class="number">1000.0f</span>);</span><br></pre></td></tr></table></figure></li><li><p>在EditorLayer中的OnUpdate与OnEvent</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m_EditorCamera.<span class="built_in">OnUpdate</span>(ts);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_EditorCamera.<span class="built_in">OnEvent</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Scene中的OnUpdate</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">m_ActiveScene-&gt;<span class="built_in">OnUpdateEditor</span>(ts, m_EditorCamera);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::OnUpdateEditor</span><span class="params">(Timestep ts, EditorCamera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Renderer2D::<span class="built_in">BeginScene</span>(camera);</span><br><span class="line">    <span class="keyword">auto</span> group = m_Registry.<span class="built_in">group</span>&lt;TransformComponent&gt;(entt::get&lt;SpriteRendererComponent&gt;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> entity : group) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [transform, sprite] = group.<span class="built_in">get</span>&lt;TransformComponent, SpriteRendererComponent&gt;(entity);</span><br><span class="line">        Renderer2D::<span class="built_in">DrawQuad</span>(transform.<span class="built_in">GetTransform</span>(), sprite.Color);</span><br><span class="line">    &#125;</span><br><span class="line">    Renderer2D::<span class="built_in">EndScene</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::BeginScene</span><span class="params">(<span class="type">const</span> EditorCamera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_PROFILE_FUNCTION</span>();</span><br><span class="line"></span><br><span class="line">    glm::mat4 viewProj = camera.<span class="built_in">GetViewProjection</span>();</span><br><span class="line"></span><br><span class="line">    s_Data.TextureShader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    s_Data.TextureShader-&gt;<span class="built_in">SetMat4</span>(<span class="string">&quot;u_ViewProjection&quot;</span>, viewProj);</span><br><span class="line">    <span class="built_in">StartBatch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EditorLayer.cpp 将gizmos关联<strong>编辑时</strong>的摄像机投影与视图矩阵，而不是<strong>运行时</strong>的摄像机</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Camera - editor 编辑时的摄像机矩阵</span></span><br><span class="line"><span class="type">const</span> glm::mat4&amp; cameraProjection = m_EditorCamera.<span class="built_in">GetProjection</span>();</span><br><span class="line">glm::mat4 cameraView = m_EditorCamera.<span class="built_in">GetViewMatrix</span>();</span><br></pre></td></tr></table></figure></li></ul><h4 id="编辑时摄像机-移动与缩放-实现">编辑时摄像机 移动与缩放 实现</h4><p>为什么不讲旋转，不太会，而且此节大都是我自己推的，大概率有误，仅提供参考，忽全信</p><ul><li><p>编辑时摄像机参数略讲</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glm::vec3 m_Position = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">10.0f</span> &#125;;<span class="comment">// 摄像机的位置</span></span><br><span class="line">glm::vec3 m_FocalPoint = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;; <span class="comment">// 焦点的位置为原点</span></span><br><span class="line"></span><br><span class="line">glm::vec2 m_InitialMousePosition = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;<span class="comment">// 记录当前鼠标位置，为了计算移动鼠标后焦点的位置</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> m_Distance = <span class="number">10.0f</span>;<span class="comment">// 控制摄像机的z位置，为实现缩放效果</span></span><br></pre></td></tr></table></figure></li><li><p>当鼠标按着<strong>中键</strong>移动。目的是为了移动焦点m_FocalPoint</p><ol><li>用移动后的鼠标坐标<strong>减去</strong>当前的鼠标坐标，得到偏移量是向量且有正负（可以实现斜着移动）</li><li>获取<strong>方向向量</strong>与<strong>偏移量</strong>相乘得到焦点的最终要平移的<strong>数值</strong>delta</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorCamera::OnUpdate</span><span class="params">(Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(Key::LeftAlt))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> glm::vec2&amp; mouse&#123; Input::<span class="built_in">GetMouseX</span>(), Input::<span class="built_in">GetMouseY</span>() &#125;;</span><br><span class="line">        glm::vec2 delta = (mouse - m_InitialMousePosition) * <span class="number">0.003f</span>;</span><br><span class="line">        m_InitialMousePosition = mouse;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input::<span class="built_in">IsMouseButtonPressed</span>(Mouse::ButtonMiddle))</span><br><span class="line">            <span class="built_in">MousePan</span>(delta);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input::<span class="built_in">IsMouseButtonPressed</span>(Mouse::ButtonLeft))</span><br><span class="line">            <span class="built_in">MouseRotate</span>(delta);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Input::<span class="built_in">IsMouseButtonPressed</span>(Mouse::ButtonRight))</span><br><span class="line">            <span class="built_in">MouseZoom</span>(delta.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UpdateView</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移动焦点，从原点000移动到xy0点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorCamera::MousePan</span><span class="params">(<span class="type">const</span> glm::vec2&amp; delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> [xSpeed, ySpeed] = <span class="built_in">PanSpeed</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//加上负号是因为，焦点往右方向物体要左移</span></span><br><span class="line">m_FocalPoint += -<span class="built_in">GetRightDirection</span>() * delta.x * xSpeed * m_Distance;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 不加负号是因为，焦点往上方向(0,1,0)移动到(0,1,0)，使得物体下移效果</span></span><br><span class="line">m_FocalPoint += <span class="built_in">GetUpDirection</span>() * delta.y * ySpeed * m_Distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得旋转矩阵沿着y轴的向量。</span></span><br><span class="line"><span class="comment">// 返回vec3(0, 1, 0);或者 vec3(0, -1, 0)得到是往上还是往下的向量</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">EditorCamera::GetUpDirection</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">rotate</span>(<span class="built_in">GetOrientation</span>(), glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得旋转矩阵沿着x轴的向量。</span></span><br><span class="line"><span class="comment">// 返回vec3(1, 0, 0)(右);或者 vec3(-1, 0, 0)(左)得到是往右还是往左的向量</span></span><br><span class="line"><span class="function">glm::vec3 <span class="title">EditorCamera::GetRightDirection</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> glm::<span class="built_in">rotate</span>(<span class="built_in">GetOrientation</span>(), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="六十四、重构帧缓冲类">六十四、重构帧缓冲类</h2><h4 id="前言-4">前言</h4><ul><li><p>要实现什么</p><p>完善Gizmos，点击场景的物体，即会显示gizmos，而<strong>不用点击</strong>hierarchy的实体才会显示。</p></li><li><p>实现思路</p><p>光栅化输出到界面有<strong>每一个像素对应的实体ID</strong>（这节要实现的）</p></li><li><p>此节要完成</p><p>由下面的思路三得出：</p><ol><li>修改和优化<strong>帧缓冲</strong>类，<strong>能附加多个不同类别缓冲区</strong>。</li><li>使得帧缓冲区可以附加<strong>两个</strong>颜色纹理，实现一个渲染通道有两个渲染目标，并且imgui可以显示出<strong>第二个</strong>渲染目标</li></ol></li></ul><h4 id="如何将实体ID值附加到像素上">如何将实体ID值附加到像素上</h4><p><strong>思路一</strong></p><ul><li><p>方法</p><p>使用<strong>Uniform</strong></p></li><li><p>问题</p><p>当前场景使用批处理，虽然场景显示了3个实体，但实际上调用<strong>一次drawcall</strong>属于一个对象，无法用Uniform确定当前一个整体的分块。</p><p>除非每一个实体调用一个drawcall，这样不使用批处理效率会降低，不行。</p></li></ul><p><strong>思路二</strong></p><ul><li><p>方法</p><p>将实体ID附加到<strong>顶点</strong>缓冲区中。</p></li><li><p>实现Demo</p><p>在顶点缓冲布局中添加实体ID，这样<strong>每个顶点都有一个自己的EntityID值，再将这个ID值作为像素的颜色值，这样就可以成功在当前实体里的每个像素都有这个ID值</strong>，即在代码位置为:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QuadVertex</span> &#123;</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">.....</span><br><span class="line">    <span class="comment">// Editor-only;</span></span><br><span class="line">    <span class="type">int</span> EntityID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 2.1设置顶点缓冲区布局</span></span><br><span class="line">s_Data.QuadVertexBuffer-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">    &#123;HEngine::ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;,</span><br><span class="line">.....</span><br><span class="line">    &#123;HEngine::ShaderDataType::<span class="type">int</span>, <span class="string">&quot;a_EntityID&quot;</span>&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawQuad</span><span class="params">(<span class="type">const</span> glm::mat4&amp; transform, <span class="type">const</span> glm::vec4&amp; color, <span class="type">const</span> <span class="type">int</span> entityId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s_Data.QuadIndexCount &gt;= Renderer2DData::MaxIndices) &#123;</span><br><span class="line">        <span class="built_in">NextBatch</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> quadVertexCount = <span class="number">4</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// quad的左下角为起点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; quadVertexCount; i++) &#123;</span><br><span class="line">        s_Data.QuadVertexBufferPtr-&gt;Position = transform * s_Data.QuadVertexPosition[i];</span><br><span class="line">......</span><br><span class="line">        </span><br><span class="line">        s_Data.QuadVertexBufferPtr-&gt;EntityId = entityId;<span class="comment">// 在这写</span></span><br><span class="line">        s_Data.QuadVertexBufferPtr++;</span><br><span class="line">    &#125;</span><br><span class="line">    s_Data.QuadIndexCount += <span class="number">6</span>;<span class="comment">// 每一个quad用6个索引</span></span><br><span class="line">    s_Data.Stats.QuadCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>问题</p><p>由于使用了动态顶点缓冲区，即又要重写RendererAPI，可是本身RendererAPI就有很多代码，若再重写，将会<strong>混乱</strong></p><p>例如：</p><p>当前项目的结构是，一个渲染通道（drawcall）对应一个渲染目标（帧缓冲的缓冲附件），这个渲染目标（帧缓冲的缓冲附件）已经<strong>输出</strong>了颜色（这个缓冲区只有颜色值），那实体ID值应该渲染到哪个渲染目标上（帧缓冲的缓冲附件）上呢？</p></li></ul><h4 id="解决思路二的问题">解决思路二的问题</h4><ul><li><p>方法</p><p>当前项目的渲染目标是<strong>帧缓冲，帧缓冲可以附加多个缓冲区，所以只需要将实体ID缓冲区随已经存在的颜色缓冲区之后附加到帧缓冲即可</strong></p></li></ul><h4 id="帧缓冲类修改">帧缓冲类修改</h4><ul><li><p>创建纹理</p><p>原先是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glCreateTextures</span>(GL_TEXTURE_2D, <span class="number">1</span>, &amp;m_ColorAttachment);;</span><br></pre></td></tr></table></figure><p>修改后是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.1创建纹理。m_ColorAttachments.data()是地址，可以创建多个缓冲区</span></span><br><span class="line">Utils::<span class="built_in">CreateTextures</span>(multisample, m_ColorAttachments.<span class="built_in">data</span>(), m_ColorAttachments.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CreateTextures</span><span class="params">(<span class="type">bool</span> multisampled, <span class="type">uint32_t</span>* outID, <span class="type">uint32_t</span> count)</span> </span>&#123;<span class="comment">// outID 是vector的起始位置</span></span><br><span class="line">    <span class="built_in">glCreateTextures</span>(<span class="built_in">TextureTarget</span>(multisampled), count, outID);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若m_ColorAttachments.size()是2，且m_ColorAttachments[0] = 3, 那么m_ColorAttachments[1] = 4，3和4是<strong>缓冲区ID</strong></p></li><li><p>颜色纹理附加到帧缓冲</p><p>原先是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1颜色纹理缓冲区附加到帧缓冲</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_ColorAttachment, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>修改后是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 颜色纹理缓冲区附加到帧缓冲：第二个参数重要，可以附加多个颜色纹理缓冲区！**</span></span><br><span class="line"><span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + index, <span class="built_in">TextureTarget</span>(multisampled), id, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>由于附加多个颜色纹理缓冲区到帧缓冲中，所以要用glDrawBuffers 定义<strong>多个渲染目标</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新加的！！！指定要Draw的颜色缓冲区列表</span></span><br><span class="line"><span class="keyword">if</span> (m_ColorAttachments.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(m_ColorAttachments.<span class="built_in">size</span>() &lt;= <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 这里id对应上面，颜色纹理附加到帧缓冲的ID</span></span><br><span class="line">    GLenum buffers[<span class="number">4</span>] = &#123;GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 ,GL_COLOR_ATTACHMENT2 ,GL_COLOR_ATTACHMENT3 &#125;;</span><br><span class="line">    <span class="comment">// 定义**多个渲染目标**</span></span><br><span class="line">    <span class="built_in">glDrawBuffers</span>(m_ColorAttachments.<span class="built_in">size</span>(), buffers);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(m_ColorAttachments.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="comment">// 只有深度缓冲</span></span><br><span class="line">    <span class="built_in">glDrawBuffer</span>(GL_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若只使用第一个颜色纹理缓冲区，不用上面代码，但使用第二个颜色纹理缓冲区必须要有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只使用两个颜色纹理缓冲区可以不用后面两个</span></span><br><span class="line">GLenum buffers[] = &#123;GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以创建多重采样的纹理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> multisampled = samples &gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (multisampled) &#123;</span><br><span class="line">    <span class="built_in">glTexImage2DMultisample</span>(GL_TEXTURE_2D_MULTISAMPLE, samples, format, width, height, GL_FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="显示第二个渲染目标代码">显示第二个渲染目标代码</h4><ul><li><p>指定要附加<strong>两个</strong>颜色纹理缓冲区给帧缓冲</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FramebufferSpecification fbSpec;</span><br><span class="line">fbSpec.Attachments = &#123; FramebufferTextureFormat::RGBA8, FramebufferTextureFormat::RGBA8, FramebufferTextureFormat::Depth&#125;;</span><br><span class="line">fbSpec.Width = <span class="number">1280</span>;</span><br><span class="line">fbSpec.Height = <span class="number">720</span>;</span><br><span class="line">m_Framebuffer = Framebuffer::<span class="built_in">Create</span>(fbSpec);</span><br><span class="line"><span class="comment">// 附加的代码都在OpenGlFramebuffer中</span></span><br></pre></td></tr></table></figure></li><li><p>glsl编写第二个输出的颜色纹理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#type fragment</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 color;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) out vec4 color2;<span class="comment">// 第二个渲染目标(颜色纹理)的颜色</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> color = <span class="built_in">texture</span>(u_Textures[<span class="built_in">int</span>(v_TexIndex)], v_TexCoord * v_TilingFactor) * v_Color;</span><br><span class="line"> color2 = <span class="built_in">vec4</span>(<span class="number">0.9</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">1.0</span>);;<span class="comment">// 输出到第二个渲染目标(颜色纹理)中，红色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EditorLayer根据<strong>下标</strong>获取第<strong>二</strong>个渲染目标的<strong>缓冲区ID</strong>，Imgui根据缓冲区ID呈现缓冲区的颜色纹理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// imgui渲染帧缓冲中的东西。</span></span><br><span class="line"><span class="comment">// textureID是缓冲区ID</span></span><br><span class="line"><span class="type">uint32_t</span> textureID = m_Framebuffer-&gt;<span class="built_in">GetColorAttachmentRendererID</span>(<span class="number">1</span>);</span><br><span class="line">ImGui::<span class="built_in">Image</span>((<span class="type">void</span>*)textureID, <span class="built_in">ImVec2</span>(m_ViewportSize.x, m_ViewportSize.y), <span class="built_in">ImVec2</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">ImVec2</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="六十五、鼠标拾取帧缓存数据">六十五、鼠标拾取帧缓存数据</h2><h4 id="前言-5">前言</h4><ul><li><p>此节目的</p><ol><li>上一节已经显示了帧缓冲第二个<strong>颜色纹理</strong>缓冲的颜色</li><li>这节需要把帧缓冲第二个缓冲区改变<strong>类型</strong>，为<strong>有符号整形</strong>对应实体ID。</li><li>并且需要增加获取当前鼠标在viewport视口的<strong>相对位置</strong>，然后读取鼠标位置像素的**帧缓冲中第二个缓冲区（渲染目标）**的数据。</li></ol></li><li><p>如何实现</p><ul><li><p>获取鼠标在viewport视口的相对位置</p><p>鼠标的<strong>绝对</strong>位置是：当前位置距离整个屏幕**左上角(0,0)**的位置</p><p>鼠标的<strong>相对</strong>位置是：ImGui的API，<strong>得到viewport视口左上角的绝对位置</strong>，再鼠标绝对位置<strong>减去</strong>viewport窗口的左上角绝对位置即可</p></li></ul></li><li><p>注意细节</p><p>由于ImGui的viewport视口左上角为00，而OpenGL的左下角才是00，所以读取缓冲区数据时候需要<strong>翻转y</strong>（用视口高度**-** 鼠标y<strong>相对位置</strong>即可）。</p></li></ul><h4 id="代码">代码</h4><p>OpenGLFramebuffer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1纹理附加到帧缓冲</span></span><br><span class="line"><span class="keyword">switch</span> (m_ColorAttachmentSpecifications[i].TextureFormat)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> FramebufferTextureFormat::RGBA8:</span><br><span class="line">        Utils::<span class="built_in">AttachColorTextures</span>(m_ColorAttachments[i], m_Specification.Samples, GL_RGBA8, GL_RGBA, m_Specification.Width, m_Specification.Height, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加整形缓冲区附件</span></span><br><span class="line">    <span class="keyword">case</span> FramebufferTextureFormat::RED_INTEGER:</span><br><span class="line">        Utils::<span class="built_in">AttachColorTextures</span>(m_ColorAttachments[i], m_Specification.Samples, GL_R32I, GL_RED_INTEGER, m_Specification.Width, m_Specification.Height, i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EditorLayer.cpp  获取鼠标在viewport视口的相对位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.先获取Viewport视口左上角与viewport视口标题栏距离的偏移位置（0,24)- 必须放这，因为标题栏后就是视口的左上角</span></span><br><span class="line"><span class="keyword">auto</span> viewportOffset = ImGui::<span class="built_in">GetCursorPos</span>();</span><br><span class="line"><span class="comment">// 2.获取vieport视口大小 - 包含标题栏的高</span></span><br><span class="line"><span class="keyword">auto</span> windowSize = ImGui::<span class="built_in">GetWindowSize</span>();</span><br><span class="line"><span class="comment">// 3.获取当前vieport视口标题栏左上角距离当前整个屏幕左上角（0,0）的位置</span></span><br><span class="line">ImVec2 minBound = ImGui::<span class="built_in">GetWindowPos</span>();</span><br><span class="line"><span class="comment">// 4.计算viewport视口的左上角距离当前整个屏幕左上角（0,0）的位置</span></span><br><span class="line">minBound.x += viewportOffset.x;</span><br><span class="line">minBound.y += viewportOffset.y;</span><br><span class="line"><span class="comment">// 5. 计算viewport视口的右下角距离当前整个屏幕左上角（0,0）的位置</span></span><br><span class="line">ImVec2 maxBound = &#123; minBound.x + windowSize.x, minBound.y + windowSize.y - viewportOffset.y &#125;;</span><br><span class="line"><span class="comment">// 6. 保存左上角和右下角距离整个屏幕左上角的位置</span></span><br><span class="line">m_ViewportBounds[<span class="number">0</span>] = &#123; minBound.x, minBound.y &#125;;</span><br><span class="line">m_ViewportBounds[<span class="number">1</span>] = &#123; maxBound.x, maxBound.y &#125;;</span><br></pre></td></tr></table></figure><p>鼠标<strong>绝对</strong>位置减去viewport窗口的左上角<strong>绝对</strong>位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取当前鼠标距离整个屏幕左上角(0,0)的位置</span></span><br><span class="line"><span class="keyword">auto</span> [mx, my] = ImGui::<span class="built_in">GetMousePos</span>();</span><br><span class="line"><span class="comment">// 2.鼠标绝对位置减去viewport窗口的左上角绝对位置=鼠标相对于viewport窗口左上角的位置</span></span><br><span class="line">mx -= m_ViewportBounds[<span class="number">0</span>].x;</span><br><span class="line">my -= m_ViewportBounds[<span class="number">0</span>].y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.viewport窗口的右下角绝对位置-左上角的绝对位置=viewport窗口的大小</span></span><br><span class="line">glm::vec2 viewportSize = m_ViewportBounds[<span class="number">1</span>] - m_ViewportBounds[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 翻转y,使其左下角开始才是(0,0)</span></span><br><span class="line">my = viewportSize.y - my;</span><br><span class="line"><span class="type">int</span> mouseX = (<span class="type">int</span>)mx;</span><br><span class="line"><span class="type">int</span> mouseY = (<span class="type">int</span>)my;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mouseX &gt;= <span class="number">0</span> &amp;&amp; mouseY &gt;= <span class="number">0</span> &amp;&amp; mouseX &lt; (<span class="type">int</span>)viewportSize.x &amp;&amp; mouseY &lt; (<span class="type">int</span>)viewportSize.y) &#123;</span><br><span class="line">    <span class="comment">// 4.读取帧缓冲第二个缓冲区的数据</span></span><br><span class="line">    <span class="type">int</span> pixelData = m_Framebuffer-&gt;<span class="built_in">ReadPixel</span>(<span class="number">1</span>, mouseX, mouseY);</span><br><span class="line">    <span class="built_in">HE_CORE_WARN</span>(<span class="string">&quot;Pixel data = &#123;0&#125;&quot;</span>, pixelData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取鼠标位置像素的**帧缓冲中第二个缓冲区（渲染目标）**的数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">OpenGLFramebuffer::ReadPixel</span><span class="params">(<span class="type">uint32_t</span> attachmentIndex, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(attachmentIndex &lt; m_ColorAttachments.<span class="built_in">size</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键函数glReadBuffer+glReadPixels</span></span><br><span class="line">    <span class="built_in">glReadBuffer</span>(GL_COLOR_ATTACHMENT0 + attachmentIndex);<span class="comment">// 读取第二个缓冲区</span></span><br><span class="line">    <span class="type">int</span> pixelData = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">glReadPixels</span>(x, y, <span class="number">1</span>, <span class="number">1</span>, GL_RED_INTEGER, GL_INT, &amp;pixelData);<span class="comment">// 读取第二个缓冲区中的xy位置的缓冲区值</span></span><br><span class="line">    <span class="keyword">return</span> pixelData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个缓冲区（渲染目标）的数据在Glsl的片段着色器中设置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#type fragment</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 color;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) out <span class="type">int</span> color2;<span class="comment">// 第二个渲染目标(有符号整形)</span></span><br><span class="line"></span><br><span class="line">in vec4 v_Color;</span><br><span class="line">in vec2 v_TexCoord;</span><br><span class="line">in <span class="type">float</span> v_TexIndex;</span><br><span class="line">in <span class="type">float</span> v_TilingFactor;</span><br><span class="line"></span><br><span class="line">uniform sampler2D u_Textures[<span class="number">32</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> color = <span class="built_in">texture</span>(u_Textures[<span class="built_in">int</span>(v_TexIndex)], v_TexCoord * v_TilingFactor) * v_Color;</span><br><span class="line"> color2 = <span class="number">50</span>;<span class="comment">// 第二个渲染目标(有符号整形的值)设为50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="六十六、用固定值填充帧缓冲区">六十六、用固定值填充帧缓冲区</h2><h4 id="前言-6">前言</h4><ul><li><p>前情提要</p><p>由上节已经可以<strong>读取</strong>鼠标位置的颜色缓冲区的值，但是当读取不是quad的范围的值是一个**奇怪的数字*</p><p>是因为cpp代码中使用了glClearColor(color.r, color.g, color.b, color.a);将缓冲区<strong>默认</strong>填上了颜色,这个颜色本来是float值，<strong>转换</strong>为int读取出来则是奇怪的数字</p></li><li><p>如何实现</p><p>使用新的OpenGL函数<a href="https://docs.gl/gl4/glClearTexImage">glClearTexImage</a>，用<strong>特定值</strong>填充缓冲区</p></li><li><p>实现细节</p><ol><li>由于这个glClearTexImage函数根据是设置为int值，还是float值需要<strong>指定不同参数</strong></li><li>需要适当考虑<strong>扩展性</strong>，但当前只需要填充int值，所以可以先简单写死，后面有增加则再改。</li></ol></li></ul><h4 id="代码-2">代码</h4><ul><li><p>EditorLayer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用-1填充帧缓冲的第二个颜色缓冲区</span></span><br><span class="line">m_Framebuffer-&gt;<span class="built_in">ClearAttachment</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure></li><li><p>具体填充函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLFramebuffer::ClearAttachment</span><span class="params">(<span class="type">uint32_t</span> attachmentIndex, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(attachmentIndex &lt; m_ColorAttachments.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; spec = m_ColorAttachmentSpecifications[attachmentIndex];</span><br><span class="line">    <span class="built_in">glClearTexImage</span>(m_ColorAttachments[attachmentIndex], <span class="number">0</span>,</span><br><span class="line">        Utils::<span class="built_in">HEngineFBTextureFormatToGL</span>(spec.TextureFormat), GL_INT, &amp;value);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> GLenum <span class="title">HEngineFBTextureFormatToGL</span><span class="params">(FramebufferTextureFormat format)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (format)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> FramebufferTextureFormat::RGBA8:<span class="keyword">return</span> GL_RGBA8;</span><br><span class="line">        <span class="keyword">case</span> FramebufferTextureFormat::RED_INTEGER:<span class="keyword">return</span> GL_RED_INTEGER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="六十七、获取鼠标所在的实体的ID">六十七、获取鼠标所在的实体的ID</h2><h4 id="前言-7">前言</h4><ul><li><p>前情提要</p><p>目前已经可以读取鼠标位置的颜色缓冲区的值，但是quad的范围读取的值是一个<strong>固定</strong>的50数字</p><p>需要实现读取quad实体内的像素在第二个缓冲区的值，会返回<strong>当前实体的ID</strong></p></li><li><p>如何实现</p><p>在顶点缓冲布局中添加实体ID，这样<strong>每个顶点都有一个自己的EntityID值，再将这个ID值作为第二个缓冲区像素的颜色值，这样就可以成功在当前实体里的每个像素都有这个ID值</strong></p></li></ul><h4 id="修改代码">修改代码</h4><ul><li><p>Renderer2D.cpp  给顶点缓冲区布局添加实体ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">QuadVertex</span> &#123;</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec4 Color;</span><br><span class="line">    glm::vec2 TexCoord;</span><br><span class="line">    <span class="type">float</span> TexIndex;</span><br><span class="line">    <span class="type">float</span> TilingFactor;</span><br><span class="line">    <span class="comment">// Editor-only;</span></span><br><span class="line">    <span class="type">int</span> EntityID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 2.1设置顶点缓冲区布局</span></span><br><span class="line">s_Data.QuadVertexBuffer-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">    &#123; ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span> &#125;,</span><br><span class="line">    &#123; ShaderDataType::Float4, <span class="string">&quot;a_Color&quot;</span> &#125;,</span><br><span class="line">    &#123; ShaderDataType::Float2, <span class="string">&quot;a_TexCoord&quot;</span> &#125;,</span><br><span class="line">    &#123; ShaderDataType::Float, <span class="string">&quot;a_TexIndex&quot;</span> &#125;,</span><br><span class="line">    &#123; ShaderDataType::Float, <span class="string">&quot;a_TilingFactor&quot;</span> &#125;,</span><br><span class="line">    &#123; ShaderDataType::Int, <span class="string">&quot;a_EntityID&quot;</span> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Renderer2D.cpp 设置顶点属性的<strong>EntityID</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawQuad</span><span class="params">(<span class="type">const</span> glm::mat4&amp; transform, <span class="type">const</span> glm::vec4&amp; color, <span class="type">int</span> entityID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; quadVertexCount; i++) </span><br><span class="line">    &#123;</span><br><span class="line">...</span><br><span class="line">        s_Data.QuadVertexBufferPtr-&gt;EntityID = entityID; <span class="comment">//新增</span></span><br><span class="line">        s_Data.QuadVertexBufferPtr++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Texture.glsl</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#type vertex</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> a_Position;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec4</span> a_Color;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> a_TexCoord;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">3</span>) <span class="keyword">in</span> <span class="type">float</span> a_TexIndex;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">4</span>) <span class="keyword">in</span> <span class="type">float</span> a_TilingFactor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">5</span>) <span class="keyword">in</span> <span class="type">int</span> a_EntityId; <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_ViewProjection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> v_Color;</span><br><span class="line"><span class="keyword">out</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"><span class="keyword">out</span> <span class="type">float</span> v_TexIndex;</span><br><span class="line"><span class="keyword">out</span> <span class="type">float</span> v_TilingFactor;</span><br><span class="line"><span class="keyword">out</span> <span class="keyword">flat</span> <span class="type">int</span> v_EntityId;<span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#type fragment</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">float</span> v_TilingFactor;</span><br><span class="line"><span class="keyword">in</span> <span class="keyword">flat</span> <span class="type">int</span> v_EntityId; <span class="comment">// 新增</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"> color2 = v_EntityId;<span class="comment">// 新增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EditorLayer.cpp  获取当前选中实体信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnUpdate</span><span class="params">(Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mouseX &gt;= <span class="number">0</span> &amp;&amp; mouseY &gt;= <span class="number">0</span> &amp;&amp; mouseX &lt; (<span class="type">int</span>)viewportSize.x &amp;&amp; mouseY &lt; (<span class="type">int</span>)viewportSize.y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pixelData = m_Framebuffer-&gt;<span class="built_in">ReadPixel</span>(<span class="number">1</span>, mouseX, mouseY);</span><br><span class="line">        m_HoveredEntity = pixelData == <span class="number">-1</span> ? <span class="built_in">Entity</span>() : <span class="built_in">Entity</span>((entt::entity)pixelData, m_ActiveScene.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string name = <span class="string">&quot;None&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (m_HoveredEntity)</span><br><span class="line">        name = m_HoveredEntity.<span class="built_in">GetComponent</span>&lt;TagComponent&gt;().Tag;</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hovered Entity: %s &quot;</span>, name.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="六十八、点击选择实体">六十八、点击选择实体</h2><h4 id="前言-8">前言</h4><ul><li><p>前情提要</p><p>由上节已经可以读取当前鼠标位置所在实体围成的像素在缓冲区的<strong>实体ID值</strong></p><p>此节实现鼠标点击实体，会出现gizmos，并且可以拖动什么的</p></li><li><p>实现过程中出现的Bug</p><ol><li>拖动gizmo移动一个实体与另一个实体重叠时停下，且另一个实体在当前实体上面，再点击gizmo想移动<strong>原先</strong>实体，那么会获取在<strong>上面</strong>另一个实体的实体ID，即<strong>另一个实体会被选中</strong>，会切换gizmo。</li><li>显示了gizmo，但是若按下leftalt拖动旋转摄像机，则gizmo会消失</li></ol></li></ul><h4 id="代码-3">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 事件</span></span><br><span class="line">    m_CameraController.<span class="built_in">OnEvent</span>(e);</span><br><span class="line">    m_EditorCamera.<span class="built_in">OnEvent</span>(e);</span><br><span class="line"></span><br><span class="line">    <span class="function">EventDispatcher <span class="title">dispatcher</span><span class="params">(e)</span></span>;</span><br><span class="line">    dispatcher.<span class="built_in">Dispatch</span>&lt;MouseButtonPressedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(EditorLayer::OnMouseButtonPressed));</span><br><span class="line">&#125;</span><br><span class="line">.......</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EditorLayer::OnMouseButtonPressed</span><span class="params">(MouseButtonPressedEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="built_in">GetMouseButton</span>() == Mouse::ButtonLeft) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">m_ViewportHovered 是为了在别的视口点击不会关闭当前显示的gizmo</span></span><br><span class="line"><span class="comment">两个&amp;&amp;后面是解决下面两个问题</span></span><br><span class="line"><span class="comment">1. 拖动gizmo移动一个实体与另一个实体重叠时停下，且另一个实体在当前实体上面，再点击gizmo想移动原先实体，那么会获取在上面另一个实体的实体ID，即另一个实体会被选中，会切换gizmo。</span></span><br><span class="line"><span class="comment">2. 显示了gizmo，但是若按下leftalt拖动旋转摄像机，则gizmo会消失</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m_ViewportHovered &amp;&amp; !ImGuizmo::<span class="built_in">IsOver</span>() &amp;&amp; !Input::<span class="built_in">IsKeyPressed</span>(Key::LeftAlt)) &#123;</span><br><span class="line">            m_SceneHierarchyPanel.<span class="built_in">SetSelectedEntity</span>(m_HoveredEntity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">.......</span><br><span class="line"><span class="comment">// 选中实体//</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::SetSelectedEntity</span><span class="params">(Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_SelectionContext = entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="六十九、Vulkan和新Shader系统">六十九、Vulkan和新Shader系统</h2><h4 id="前言-9">前言</h4><ul><li><p>当前项目以后Cherno打算支持vulkan，由于vulkan着色器代码也支持glsl语言，但是和Opengl的glsl<strong>标准不一样</strong>。</p><p>因为Vulkan中存在OpenGL的不存在的东西（反之亦然），所以着色器代码肯定不同。</p><ul><li><p>vulkan和opengl的glsl对比-以Uniform为例</p><ul><li><p>主要不同</p><p>在于，opengl支持uniform，vulkan不支持uniform，而是支持uniform<strong>缓冲区</strong>（push_constant、存储缓冲区）这比OpenGL的glsl更好。</p><p>opengl的uniform</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> m_transform;</span><br></pre></td></tr></table></figure><p>vulkan的uniform缓冲区</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span>(<span class="keyword">std140</span>, <span class="keyword">binding</span>=<span class="number">2</span>) <span class="keyword">uniform</span> Transform&#123;</span><br><span class="line">    <span class="type">mat4</span> Transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Opengl支持的uniform哪里不好</p><p>场景有很多个物体，这样一个物体调用一次drawcall（不是批处理模式），每个物体需要显示都需要<strong>上传</strong>摄像机的投影视图矩阵，那么10000个物体就有10000个uniform更新，但其实摄像机的投影视图矩阵在当前帧不变的，这样就会造成性能的下降。</p></li><li><p>vulkan哪里好</p><p>vulkan的uniform是在<strong>GPU开辟的一块缓冲区</strong>，每个物体需要摄像机的投影视图矩阵，只需将这块缓冲区放入投影矩阵的值，然后每个drawcall都去<strong>访问</strong>这块缓冲区，得到投影视图矩阵就行，性能更好。</p></li></ul></li></ul></li><li><p>此节目的</p><p>重新写shader系统，使其能支持vulkan和opengl两种glsl</p></li><li><p>如何实现</p><p>使用SPIR-V，作为<strong>中间表示语言</strong>，即可支持vulkan也支持opengl的glsl</p></li></ul><h4 id="介绍SPIR-V">介绍SPIR-V</h4><ul><li><p>介绍SPIR-V</p><p>vulkanApi要求以SPIR-V组件的形式提供着色器，而这个SPIR-V相当于“<strong>中间表示语言</strong>”</p><ol><li>可以将写好的glsl、hlsl转换为SPIR-V</li><li>也可以将SPIR-V转换为glsl、hlsl。</li></ol><p>使得可以完成只写<strong>一</strong>次shader，自动生成<strong>各种不同版本的shader语言</strong>。</p></li><li><p>SPIR-V什么工作方式：（可能我理解错了了）</p><p>将vulkan的glsl用SPIR-V<strong>编译</strong>成SPIR-V<strong>二进制</strong>文件，然后用SPIR-V的<strong>交叉编译</strong>这个二进制文件成hlsl、metal，以及兼容OpenGL的glsl。</p></li><li><p>实现过程中的重要功能</p><p>使用SPIR-V加入着色器<strong>缓存</strong>功能，不用每次都编译着色器，<strong>节省时间</strong>。</p></li></ul><p>以上很有可能说的不正确，我有点迷糊，东拼西凑的写完以上内容，但大概意思是这样。</p><h4 id="代码-4">代码</h4><ul><li><p>写vulkan的glsl</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#type vertex</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> a_Position;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec4</span> a_Color;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">vec2</span> a_TexCoord;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">3</span>) <span class="keyword">in</span> <span class="type">float</span> a_TexIndex;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">4</span>) <span class="keyword">in</span> <span class="type">float</span> a_TilingFactor;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">5</span>) <span class="keyword">in</span> <span class="type">int</span> a_EntityID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">std140</span>, <span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> Camera&#123; <span class="comment">// std140是布局</span></span><br><span class="line"><span class="type">mat4</span> u_ViewProjection;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct VertexOutput &#123;</span><br><span class="line"><span class="type">vec4</span> Color;</span><br><span class="line"><span class="type">vec2</span> TexCoord;</span><br><span class="line"><span class="type">float</span> TexIndex;</span><br><span class="line"><span class="type">float</span> TilingFactor;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> VertexOutput Output;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">4</span>) <span class="keyword">out</span> <span class="keyword">flat</span> <span class="type">int</span> v_EntityID; <span class="comment">// 4 是因为TilingFactor 是3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"></span><br><span class="line">Output.Color = a_Color;</span><br><span class="line">Output.TexCoord = a_TexCoord;</span><br><span class="line">Output.TexIndex = a_TexIndex;</span><br><span class="line">Output.TilingFactor = a_TilingFactor;</span><br><span class="line">v_EntityID = a_EntityID;</span><br><span class="line"></span><br><span class="line"><span class="built_in">gl_Position</span> = u_ViewProjection * <span class="type">vec4</span>(a_Position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#type fragment</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">int</span> color2;</span><br><span class="line"></span><br><span class="line">struct VertexOutput &#123;</span><br><span class="line"><span class="type">vec4</span> Color;</span><br><span class="line"><span class="type">vec2</span> TexCoord;</span><br><span class="line"><span class="type">float</span> TexIndex;</span><br><span class="line"><span class="type">float</span> TilingFactor;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> VertexOutput Input;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">4</span>) <span class="keyword">in</span> <span class="keyword">flat</span> <span class="type">int</span> v_EntityID; <span class="comment">// 4 是因为TilingFactor 是3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> u_Textures[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"> color = <span class="built_in">texture</span>(u_Textures[<span class="type">int</span>(Input.TexIndex)], Input.TexCoord * Input.TilingFactor) * Input.Color;</span><br><span class="line"> color2 = v_EntityID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建UniformBuffer类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UniformBuffer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">UniformBuffer</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetData</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">uint32_t</span> size, <span class="type">uint32_t</span> offset = <span class="number">0</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> Ref&lt;UniformBuffer&gt; <span class="title">Create</span><span class="params">(<span class="type">uint32_t</span> size, <span class="type">uint32_t</span> binding)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OpenGLUniformBuffer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">OpenGLUniformBuffer::<span class="built_in">OpenGLUniformBuffer</span>(<span class="type">uint32_t</span> size, <span class="type">uint32_t</span> binding)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建一个 OpenGL 缓冲对象，并存储在 m_RendererID</span></span><br><span class="line">    <span class="built_in">glCreateBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配缓冲区内存，但不初始化数据，使用 GL_DYNAMIC_DRAW 作为提示（数据会频繁更新）</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 研究 GL_DYNAMIC_DRAW 是否最优，可能可以换成其他模式</span></span><br><span class="line">    <span class="built_in">glNamedBufferData</span>(m_RendererID, size, <span class="literal">nullptr</span>, GL_DYNAMIC_DRAW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定缓冲区到指定的 Uniform Buffer 绑定点</span></span><br><span class="line">    <span class="built_in">glBindBufferBase</span>(GL_UNIFORM_BUFFER, binding, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OpenGLUniformBuffer::~<span class="built_in">OpenGLUniformBuffer</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 删除 OpenGL 缓冲对象，释放 GPU 资源</span></span><br><span class="line">    <span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLUniformBuffer::SetData</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">uint32_t</span> size, <span class="type">uint32_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 更新缓冲区的部分数据，避免重新分配整个缓冲区，提高性能</span></span><br><span class="line">    <span class="built_in">glNamedBufferSubData</span>(m_RendererID, offset, size, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Renderer2D.cpp上传摄像机的投影视图矩阵给Uniform缓冲区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Renderer2DData</span></span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CameraData</span></span><br><span class="line">    &#123;</span><br><span class="line">        glm::mat4 ViewProjection;</span><br><span class="line">    &#125;;</span><br><span class="line">    CameraData CameraBuffer;</span><br><span class="line">    Ref&lt;UniformBuffer&gt; CameraUniformBuffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    .....</span><br><span class="line"><span class="comment">// 初始化CameraUniformBuffer实例，在构造函数中就将调用上面的glBindBufferBase函数</span></span><br><span class="line">    s_Data.CameraUniformBuffer = UniformBuffer::<span class="built_in">Create</span>(<span class="built_in">sizeof</span>(Renderer2DData::CameraData), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::BeginScene</span><span class="params">(<span class="type">const</span> EditorCamera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_PROFILE_FUNCTION</span>();</span><br><span class="line"></span><br><span class="line">    s_Data.CameraBuffer.ViewProjection = camera.<span class="built_in">GetViewProjection</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上传数据给缓冲区///</span></span><br><span class="line">    s_Data.CameraUniformBuffer-&gt;<span class="built_in">SetData</span>(&amp;s_Data.CameraBuffer, <span class="built_in">sizeof</span>(Renderer2DData::CameraData));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">StartBatch</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="七十、-显示资源文件夹UI">七十、 显示资源文件夹UI</h2><h4 id="前言-10">前言</h4><ul><li><p>此节目的</p><p>为了实现quad有纹理，要实现像Unity那样<strong>拖动</strong>纹理的文件 到 实体的组件下就能生成纹理组件。</p><p>此节为完成此目的，需先完成显示本地assets文件夹下的文件夹和文件。</p></li><li><p>如何实现</p><ol><li>用ImGUI渲染</li><li>由C++的fstream检索处理的文件和文件夹。</li></ol></li></ul><h4 id="代码-5">代码</h4><p>新建ContentBrowserPanel.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> std::filesystem::path s_AssetPath = <span class="string">&quot;assets&quot;</span>;</span><br><span class="line"></span><br><span class="line">ContentBrowserPanel::<span class="built_in">ContentBrowserPanel</span>()</span><br><span class="line">    :<span class="built_in">m_CurrentDirectory</span>(s_AssetPath)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentBrowserPanel::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 开始创建 ImGui 窗口，窗口名称为 &quot;Content Browser&quot;</span></span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Content Browser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前目录不是资源目录（s_AssetPath），显示返回上级目录的按钮</span></span><br><span class="line">    <span class="keyword">if</span> (m_CurrentDirectory != std::filesystem::<span class="built_in">path</span>(s_AssetPath))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;&lt;-&quot;</span>)) <span class="comment">// 返回按钮</span></span><br><span class="line">        &#123;</span><br><span class="line">            m_CurrentDirectory = m_CurrentDirectory.<span class="built_in">parent_path</span>(); <span class="comment">// 进入上一级目录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历当前目录下的所有文件和子目录</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; directoryEntry : std::filesystem::<span class="built_in">directory_iterator</span>(m_CurrentDirectory))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; path = directoryEntry.<span class="built_in">path</span>(); <span class="comment">// 获取当前文件/目录的路径</span></span><br><span class="line">        <span class="keyword">auto</span> relativePath = std::filesystem::<span class="built_in">relative</span>(path, s_AssetPath); <span class="comment">// 计算相对路径</span></span><br><span class="line">        std::string filenameString = relativePath.<span class="built_in">filename</span>().<span class="built_in">string</span>(); <span class="comment">// 获取文件/目录名并转换为字符串</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (directoryEntry.<span class="built_in">is_directory</span>()) <span class="comment">// 判断是否为目录</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果是目录，创建一个按钮，点击后进入该目录</span></span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(filenameString.<span class="built_in">c_str</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                m_CurrentDirectory /= path.<span class="built_in">filename</span>(); <span class="comment">// 进入该子目录</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果是文件，创建一个按钮，点击后可以触发相关操作（这里暂未实现）</span></span><br><span class="line">            <span class="keyword">if</span>(ImGui::<span class="built_in">Button</span>(filenameString.<span class="built_in">c_str</span>()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 可在此添加打开文件或其他操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束 ImGui 窗口</span></span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="七十一、内容面板和ImGui拖放">七十一、内容面板和ImGui拖放</h2><h4 id="前言-11">前言</h4><ul><li><p>此节目的</p><p>为完成拖动材质赋予实体，需先完成<strong>拖动</strong>这个功能，因为项目已经有打开场景函数，所以此节完成<strong>拖动场景是否能打开场景</strong>。</p></li></ul><h4 id="代码-6">代码</h4><ul><li><p>ContentBrowserPanel.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ContentBrowserPanel::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//实现拖拽功能，允许从内容浏览器拖动文件</span></span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">BeginDragDropSource</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">wchar_t</span>* itemPath = relativePath.<span class="built_in">c_str</span>();</span><br><span class="line">        ImGui::<span class="built_in">SetDragDropPayload</span>(<span class="string">&quot;CONTENT_BROWSER_ITEM&quot;</span>, itemPath, (<span class="built_in">wcslen</span>(itemPath) + <span class="number">1</span>) * <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>));</span><br><span class="line">        ImGui::<span class="built_in">EndDragDropSource</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EditorLayer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnImGuiRender</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收在此视口拖放过来的值</span></span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">BeginDragDropTarget</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为接收内容可能为空，需要if判断 。 CONTENT_BROWSER_ITEM：拖动携带的内容</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="type">const</span> ImGuiPayload* payload = ImGui::<span class="built_in">AcceptDragDropPayload</span>(<span class="string">&quot;CONTENT_BROWSER_ITEM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">wchar_t</span>* path = (<span class="type">const</span> <span class="type">wchar_t</span>*)payload-&gt;Data;</span><br><span class="line">            <span class="built_in">OpenScene</span>(std::filesystem::<span class="built_in">path</span>(g_AssetPath) / path);</span><br><span class="line">        &#125;</span><br><span class="line">        ImGui::<span class="built_in">EndDragDropTarget</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OpenScene</span><span class="params">(<span class="type">const</span> std::filesystem::path&amp; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ActiveScene = <span class="built_in">CreateRef</span>&lt;Scene&gt;();</span><br><span class="line">    m_ActiveScene-&gt;<span class="built_in">OnViewportResize</span>((<span class="type">uint32_t</span>)m_ViewportSize.x, (<span class="type">uint32_t</span>)m_ViewportSize.y);</span><br><span class="line">    m_SceneHierarchyPanel.<span class="built_in">SetContext</span>(m_ActiveScene);</span><br><span class="line"></span><br><span class="line">    <span class="function">SceneSerializer <span class="title">serializer</span><span class="params">(m_ActiveScene)</span></span>;</span><br><span class="line">    serializer.<span class="built_in">Deserialize</span>(path.<span class="built_in">string</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="七十二、拖拽添加纹理">七十二、拖拽添加纹理</h2><h4 id="前言-12">前言</h4><ul><li><p>目的</p><p>完成拖动内容面板上的材质给实体，实体表面会显示这个材质</p></li></ul><h4 id="代码-7">代码</h4><ul><li><p>SceneHierarchyPanel.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DrawComponent</span>&lt;SpriteRendererComponent&gt;(<span class="string">&quot;Sprite Renderer&quot;</span>, entity, [](<span class="keyword">auto</span>&amp; component)</span><br><span class="line">&#123;</span><br><span class="line">        ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Texture&quot;</span>, <span class="built_in">ImVec2</span>(<span class="number">100.0f</span>, <span class="number">0.0f</span>));</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">BeginDragDropTarget</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">const</span> ImGuiPayload* payload = ImGui::<span class="built_in">AcceptDragDropPayload</span>(<span class="string">&quot;CONTENT_BROWSER_ITEM&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">const</span> <span class="type">wchar_t</span>* path = (<span class="type">const</span> <span class="type">wchar_t</span>*)payload-&gt;Data;</span><br><span class="line">                std::filesystem::path texturePath = std::filesystem::<span class="built_in">path</span>(g_AssetPath) / path; </span><br><span class="line">                component.Texture = Texture2D::<span class="built_in">Create</span>(texturePath.<span class="built_in">string</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            ImGui::<span class="built_in">EndDragDropTarget</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Tiling Factor&quot;</span>, &amp;component.TilingFactor, <span class="number">0.1f</span>, <span class="number">0.0f</span>, <span class="number">100.0f</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Components.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SpriteRendererComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//新增</span></span><br><span class="line">    Ref&lt;Texture2D&gt; Texture;</span><br><span class="line">    <span class="type">float</span> TilingFactor = <span class="number">1.0f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Renderer2D.cpp 调用drawcall绘制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawSprite</span><span class="params">(<span class="type">const</span> glm::mat4&amp; transform, SpriteRendererComponent&amp; src, <span class="type">int</span> entityID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src.Texture) &#123;</span><br><span class="line">        <span class="built_in">DrawQuad</span>(transform, src.Texture, src.TilingFactor, src.Color, entityID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">DrawQuad</span>(transform, src.Color, entityID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="七十三、新增Play-Stop按钮">七十三、新增Play/Stop按钮</h2><h4 id="前言-13">前言</h4><ul><li><p>此节目的</p><p>为了物理效果能可以运行，这节需要完成工具栏的UI，点击播放运行和停止物理效果（后几节做）。</p></li></ul><h4 id="代码-8">代码</h4><ul><li><p>EditorLayer.cpp  设计工具栏UI</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::UI_Toolbar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置 ImGui 样式：调整窗口的内边距和元素间距</span></span><br><span class="line">    ImGui::<span class="built_in">PushStyleVar</span>(ImGuiStyleVar_WindowPadding, <span class="built_in">ImVec2</span>(<span class="number">0</span>, <span class="number">2</span>));</span><br><span class="line">    ImGui::<span class="built_in">PushStyleVar</span>(ImGuiStyleVar_ItemInnerSpacing, <span class="built_in">ImVec2</span>(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置按钮颜色为透明（使按钮背景不可见）</span></span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_Button, <span class="built_in">ImVec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 ImGui 当前主题颜色</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; colors = ImGui::<span class="built_in">GetStyle</span>().Colors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置鼠标悬浮时的按钮颜色，透明度降低（更明显的悬浮效果）</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; buttonHovered = colors[ImGuiCol_ButtonHovered];</span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonHovered, <span class="built_in">ImVec4</span>(buttonHovered.x, buttonHovered.y, buttonHovered.z, <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置按钮按下时的颜色，透明度降低（更明显的按下效果）</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; buttonActive = colors[ImGuiCol_ButtonActive];</span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonActive, <span class="built_in">ImVec4</span>(buttonActive.x, buttonActive.y, buttonActive.z, <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建无装饰、无滚动条的 ImGui 窗口（用于工具栏）</span></span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;##toolbar&quot;</span>, <span class="literal">nullptr</span>, ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算按钮大小（按钮的高度 = 窗口高度 - 4）</span></span><br><span class="line">    <span class="type">float</span> size = ImGui::<span class="built_in">GetWindowHeight</span>() - <span class="number">4.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据当前场景状态选择合适的图标：</span></span><br><span class="line">    <span class="comment">//  - 如果当前是编辑模式（Edit），显示“播放”按钮</span></span><br><span class="line">    <span class="comment">//  - 如果当前是播放模式（Play），显示“停止”按钮</span></span><br><span class="line">    Ref&lt;Texture2D&gt; icon = m_SceneState == SceneState::Edit ? m_IconPlay : m_IconStop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置按钮水平居中</span></span><br><span class="line">    ImGui::<span class="built_in">SetCursorPosX</span>((ImGui::<span class="built_in">GetWindowContentRegionMax</span>().x * <span class="number">0.5f</span>) - (size * <span class="number">0.5f</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建播放/停止按钮</span></span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">ImageButton</span>((ImTextureID)icon-&gt;<span class="built_in">GetRendererID</span>(), <span class="built_in">ImVec2</span>(size, size), <span class="built_in">ImVec2</span>(<span class="number">0</span>, <span class="number">0</span>), <span class="built_in">ImVec2</span>(<span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前是编辑模式，点击按钮后进入播放模式</span></span><br><span class="line">        <span class="keyword">if</span> (m_SceneState == SceneState::Edit)</span><br><span class="line">            <span class="built_in">OnScenePlay</span>();</span><br><span class="line">        <span class="comment">// 如果当前是播放模式，点击按钮后进入编辑模式</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m_SceneState == SceneState::Play)</span><br><span class="line">            <span class="built_in">OnSceneStop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复 ImGui 样式设置（避免影响其他 UI 元素）</span></span><br><span class="line">    ImGui::<span class="built_in">PopStyleVar</span>(<span class="number">2</span>);    <span class="comment">// 恢复窗口和元素间距</span></span><br><span class="line">    ImGui::<span class="built_in">PopStyleColor</span>(<span class="number">3</span>);  <span class="comment">// 恢复按钮颜色</span></span><br><span class="line">    ImGui::<span class="built_in">End</span>();             <span class="comment">// 结束 ImGui 窗口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据当前不同状态，Scene调用不同函数渲染静态场景、动态场景（物理效果）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnUpdate</span><span class="params">(Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (m_SceneState)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SceneState::Edit:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_ViewportFocused)</span><br><span class="line">                m_CameraController.<span class="built_in">OnUpdate</span>(ts);</span><br><span class="line"></span><br><span class="line">            m_EditorCamera.<span class="built_in">OnUpdate</span>(ts);</span><br><span class="line"></span><br><span class="line">            m_ActiveScene-&gt;<span class="built_in">OnUpdateEditor</span>(ts, m_EditorCamera);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SceneState::Play:</span><br><span class="line">        &#123;</span><br><span class="line">            m_ActiveScene-&gt;<span class="built_in">OnUpdateRuntime</span>(ts);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="七十四、2D物理引擎！">七十四、2D物理引擎！</h2><h4 id="前言-14">前言</h4><ul><li><p>此节目的</p><p>实现2D物理效果,选择使用Box2D库实现，具体使用可看<a href="https://box2d.org/documentation/">官方文档</a></p></li><li><p>实现细节</p><ul><li>实现物体效果需要rigidbody和box2dcollider两个组件</li><li>添加了rigidbody和box2dcollider两个组件，需要修改面板以及序列化代码</li><li>以后要实现：每次运行结束后可以重置物体的位置</li></ul></li><li><p>有脚本的box2D物理运行顺序——有待搞清楚</p><ul><li><p>Script-Physic-Render顺序</p><p>脚本影响pyhsic然后渲染，<strong>当前帧</strong>得到结果</p></li><li><p>Physic-Script-Render顺序</p><p>先Physic-脚本-渲染，则当前渲染的是<strong>上一帧</strong>的物理模拟计算的结果</p></li></ul></li></ul><h4 id="代码-9">代码</h4><ul><li><p>设置box2D为当前项目的submodule，并重新运行premake程序生成项目</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/donghuiw/box2d.git</span><br></pre></td></tr></table></figure></li><li><p>新增PhysicsManager类</p></li><li><p>PhysicsManage.h</p></li><li><pre><code class="language-c++">namespace HEngine&#123;class Scene;class Timestep;struct Rigidbody2DComponent;struct BoxCollider2DComponent;class PhysicsManager&#123;public:void CreateWorld();void DestoryWorld();void AddRigibody(Scene* scene, entt::entity e);void AttachBoxshape(Scene* scene, entt::entity e);void DestoryBoxshape(Scene* scene, entt::entity e);void FixedUpdate(Timestep ts);void UpdateRigidbody(Scene* scnen, entt::entity e);public:static PhysicsManager&amp; Get() &#123; return m_instance; &#125;private:b2WorldId m_WorldId = b2_nullWorldId;static PhysicsManager m_instance;&#125;;&#125;<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- PhysicsManage.cpp</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  <span class="comment">//创建物理世界，相互作用的物体、形状、关节和接触点的集合</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PhysicsManager::CreateWorld</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      b2WorldDef worldDef = <span class="built_in">b2DefaultWorldDef</span>();</span><br><span class="line">      worldDef.gravity = &#123; <span class="number">0.0f</span>, <span class="number">-9.8f</span> &#125;;</span><br><span class="line">      worldDef.restitutionThreshold = <span class="number">0.5f</span>;</span><br><span class="line">      m_WorldId = <span class="built_in">b2CreateWorld</span>(&amp;worldDef);</span><br><span class="line">      <span class="built_in">HE_CORE_ASSERT</span>(<span class="built_in">b2World_IsValid</span>(m_WorldId),<span class="string">&quot;World id validation failed. &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PhysicsManager::AddRigibody</span><span class="params">(Scene* scene, entt::entity e)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Entity entity = &#123; e, scene &#125;;</span><br><span class="line">      <span class="keyword">auto</span>&amp; transform = entity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;();</span><br><span class="line">      <span class="keyword">auto</span>&amp; rb2d = entity.<span class="built_in">GetComponent</span>&lt;Rigidbody2DComponent&gt;();</span><br><span class="line">  </span><br><span class="line">      b2BodyDef bodyDef = <span class="built_in">b2DefaultBodyDef</span>();</span><br><span class="line">      bodyDef.type = <span class="built_in">GetBox2DBodyType</span>(rb2d.Type);</span><br><span class="line">      bodyDef.position = &#123; transform.Translation.x, transform.Translation.y &#125;;</span><br><span class="line">      bodyDef.rotation = <span class="built_in">b2MakeRot</span>(transform.Rotation.z);</span><br><span class="line">  </span><br><span class="line">      b2BodyId bodyId = <span class="built_in">b2CreateBody</span>(m_WorldId, &amp;bodyDef);</span><br><span class="line">      <span class="built_in">b2Body_SetFixedRotation</span>(bodyId, rb2d.FixedRotation);</span><br><span class="line">      rb2d.RuntimeBodyId = bodyId;</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">HE_CORE_ASSERT</span>(<span class="built_in">b2Body_IsValid</span>(rb2d.RuntimeBodyId), <span class="string">&quot;Body id validation failed.&quot;</span>);</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">AttachBoxshape</span>(scene, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//形状将碰撞几何体绑定到物体上,并添加密度、摩擦力和恢复力等材料属性</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PhysicsManager::AttachBoxshape</span><span class="params">(Scene* scene, entt::entity e)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      Entity entity = &#123; e, scene &#125;;</span><br><span class="line">      <span class="keyword">auto</span>&amp; transform = entity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;();</span><br><span class="line">      <span class="keyword">auto</span>&amp; bc2d = entity.<span class="built_in">GetComponent</span>&lt;BoxCollider2DComponent&gt;();</span><br><span class="line">      <span class="keyword">auto</span>&amp; rb2d = entity.<span class="built_in">GetComponent</span>&lt;Rigidbody2DComponent&gt;();</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">b2Body_IsValid</span>(rb2d.RuntimeBodyId)) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">      b2Polygon boxShape = <span class="built_in">b2MakeBox</span>(bc2d.Size.x * transform.Scale.x, bc2d.Size.y * transform.Scale.y);</span><br><span class="line">  </span><br><span class="line">      b2ShapeDef shapeDef = <span class="built_in">b2DefaultShapeDef</span>();</span><br><span class="line">      shapeDef.friction = bc2d.Friction;</span><br><span class="line">      shapeDef.density = bc2d.Density;</span><br><span class="line">      shapeDef.restitution = bc2d.Restitution;</span><br><span class="line">  </span><br><span class="line">      b2ShapeId shapeID = <span class="built_in">b2CreatePolygonShape</span>(rb2d.RuntimeBodyId, &amp;shapeDef, &amp;boxShape);</span><br><span class="line">      bc2d.RuntimeShapeId = shapeID;</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">HE_CORE_ASSERT</span>(<span class="built_in">b2Shape_IsValid</span>(bc2d.RuntimeShapeId), <span class="string">&quot;Shape id validation failed.&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>Components.h</p></li><li><pre><code class="language-c++">struct Rigidbody2DComponent&#123;    enum class BodyType &#123; Static = 0, Dynamic, Kinematic &#125;;    BodyType Type = BodyType::Static;    bool FixedRotation = false;    //Storage for runtime    b2BodyId RuntimeBodyId = b2_nullBodyId;    Rigidbody2DComponent() = default;    Rigidbody2DComponent(const Rigidbody2DComponent&amp; other) = default;    Rigidbody2DComponent&amp; operator=(const Rigidbody2DComponent&amp;) = default;&#125;;struct BoxCollider2DComponent&#123;    glm::vec2 Offset = &#123; 0.0f, 0.0f &#125;;    glm::vec2 Size = &#123; 0.5f, 0.5f &#125;;    //TODO(Yan): move into physics material in the future mybe    float Density = 1.0f;    float Friction = 0.5f;    float Restitution = 0.0f;    b2ShapeId RuntimeShapeId = b2_nullShapeId;    //Storage for runtime    void* RuntimeFixture = nullptr;    BoxCollider2DComponent() = default;    BoxCollider2DComponent(const BoxCollider2DComponent&amp;) = default;&#125;;<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- Scene.cpp</span><br><span class="line"></span><br><span class="line">  ```<span class="function">cpp</span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">Scene::OnRuntimeStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      PhysicsManager::<span class="built_in">Get</span>().<span class="built_in">CreateWorld</span>();</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">auto</span> view = m_Registry.<span class="built_in">view</span>&lt;Rigidbody2DComponent&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> e : view)</span><br><span class="line">      &#123;</span><br><span class="line">          PhysicsManager::<span class="built_in">Get</span>().<span class="built_in">AddRigibody</span>(<span class="keyword">this</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Scene::OnRuntimeStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      PhysicsManager::<span class="built_in">Get</span>().<span class="built_in">DestoryWorld</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li><li><p>在属性面板显示物理组件（省略包围盒组件代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DrawComponent</span>&lt;Rigidbody2DComponent&gt;(<span class="string">&quot;Rigidbody 2D&quot;</span>, entity, [](<span class="keyword">auto</span>&amp; component) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* bodyTypeStrings[] = &#123; <span class="string">&quot;Static&quot;</span>, <span class="string">&quot;Dynamic&quot;</span>, <span class="string">&quot;Kinematic&quot;</span> &#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* currentBodyTypeString = bodyTypeStrings[(<span class="type">int</span>)component.Type];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">BeginCombo</span>(<span class="string">&quot;Body Type&quot;</span>, currentBodyTypeString)) &#123; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; </span><br><span class="line">            <span class="type">bool</span> isSelected = currentBodyTypeString == bodyTypeStrings[i];</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">Selectable</span>(bodyTypeStrings[i], isSelected)) &#123; </span><br><span class="line">                currentBodyTypeString = bodyTypeStrings[i];</span><br><span class="line">                component.Type = (Rigidbody2DComponent::BodyType)i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSelected)</span><br><span class="line">                ImGui::<span class="built_in">SetItemDefaultFocus</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ImGui::<span class="built_in">EndCombo</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Fixed Rotation&quot;</span>, &amp;component.FixedRotation);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>场景yaml文件需保存和解析物理组件（省略包围盒组件）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;Rigidbody2DComponent&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Rigidbody2DComponent&quot;</span>;</span><br><span class="line">    out &lt;&lt; YAML::BeginMap; <span class="comment">// Rigidbody2DComponent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; rb2dComponent = entity.<span class="built_in">GetComponent</span>&lt;Rigidbody2DComponent&gt;();</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;BodyType&quot;</span> &lt;&lt; YAML::Value &lt;&lt; <span class="built_in">RigidBody2DBodyTypeToString</span>(rb2dComponent.Type);</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;FixedRotation&quot;</span> &lt;&lt; YAML::Value &lt;&lt; rb2dComponent.FixedRotation;</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; YAML::EndMap; <span class="comment">// Rigidbody2DComponent</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------</span><br><span class="line"><span class="keyword">auto</span> rigidbody2DComponent = entity[<span class="string">&quot;Rigidbody2DComponent&quot;</span>];</span><br><span class="line"><span class="keyword">if</span> (rigidbody2DComponent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; rb2d = deserializedEntity.<span class="built_in">AddComponent</span>&lt;Rigidbody2DComponent&gt;();</span><br><span class="line">    rb2d.Type = <span class="built_in">RigidBody2DBodyTypeFromString</span>(rigidbody2DComponent[<span class="string">&quot;BodyType&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;());</span><br><span class="line">    rb2d.FixedRotation = rigidbody2DComponent[<span class="string">&quot;FixedRotation&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">bool</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>EditorLayer.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnScenePlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_SceneState = SceneState::Play;</span><br><span class="line">    m_ActiveScene-&gt;<span class="built_in">OnRuntimeStart</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnSceneStop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_SceneState = SceneState::Edit;</span><br><span class="line"></span><br><span class="line">    m_ActiveScene-&gt;<span class="built_in">OnRuntimeStop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="七十五、UUID唯一标识">七十五、UUID唯一标识</h2><h4 id="前言-15">前言</h4><ul><li>为了点击运行场景，实体发生位置等变化<strong>复原</strong>而要实现的标识功能,定义UUID类，使用cpp的随机函数，随机ID</li></ul><h4 id="代码-10">代码</h4><ul><li><p>定义好UUID类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UUID</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UUID</span>();</span><br><span class="line"><span class="built_in">UUID</span>(<span class="type">uint64_t</span> uuid);</span><br><span class="line"><span class="built_in">UUID</span>(<span class="type">const</span> UUID&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">uint64_t</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_UUID; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">uint64_t</span> m_UUID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;HEngine::UUID&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::<span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> HEngine::UUID&amp; uuid)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">hash</span>&lt;<span class="type">uint64_t</span>&gt;()((<span class="type">uint64_t</span>)uuid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UUID.cpp-------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::random_device s_RandomDevice;</span><br><span class="line"><span class="function"><span class="type">static</span> std::mt19937_64 <span class="title">s_Engine</span><span class="params">(s_RandomDevice())</span></span>;</span><br><span class="line"><span class="type">static</span> std::uniform_int_distribution&lt;<span class="type">uint64_t</span>&gt; s_UniformDistribution;</span><br><span class="line">UUID::<span class="built_in">UUID</span>()</span><br><span class="line">    : <span class="built_in">m_UUID</span>(<span class="built_in">s_UniformDistribution</span>(s_Engine))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UUID::<span class="built_in">UUID</span>(<span class="type">uint64_t</span> uuid)</span><br><span class="line">    : <span class="built_in">m_UUID</span>(uuid)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始创建实体时候（CreateEntity）创建新的UUID，真正创建实体时（CreateEntityWithUUID）使用实参UUID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entity <span class="title">Scene::CreateEntity</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CreateEntityWithUUID</span>(<span class="built_in">UUID</span>(), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HEngine::Entity <span class="title">Scene::CreateEntityWithUUID</span><span class="params">(UUID uuid, <span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity entity = &#123; m_Registry.<span class="built_in">create</span>(), <span class="keyword">this</span> &#125;;</span><br><span class="line">    entity.<span class="built_in">AddComponent</span>&lt;IDComponent&gt;(uuid);</span><br><span class="line">    entity.<span class="built_in">AddComponent</span>&lt;TransformComponent&gt;();</span><br><span class="line">    <span class="keyword">auto</span>&amp; tag = entity.<span class="built_in">AddComponent</span>&lt;TagComponent&gt;();</span><br><span class="line">    tag.Tag = name.<span class="built_in">empty</span>() ? <span class="string">&quot;Entity&quot;</span> : name;</span><br><span class="line">    <span class="keyword">return</span> entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>序列化</strong>yaml-cpp文件时，读取实体的ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SerializeEntity</span><span class="params">(YAML::Emitter&amp; out, Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity.<span class="built_in">HasComponent</span>&lt;IDComponent&gt;());</span><br><span class="line">    out &lt;&lt; YAML::BeginMap; <span class="comment">// Entity</span></span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Entity&quot;</span> &lt;&lt; YAML::Value &lt;&lt; entity.<span class="built_in">GetUUID</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="七十六、开始、结束、复制场景">七十六、开始、结束、复制场景</h2><h4 id="前言-16">前言</h4><ul><li><p>此节目的</p><ol><li>为实现点击运行，<strong>复制</strong>当前场景成为<strong>运行</strong>场景，点击结束<strong>销毁</strong>当前场景。</li><li>在当前场景<strong>复制</strong>实体</li></ol><p>最重要的如何复制场景，复制场景需要复制当前场景的所有实体及其包含的组件，但是当前的entt库不包含复制组件的API，所以我们需要<strong>手动写复制实体</strong>。</p></li></ul><h4 id="代码-11">代码</h4><ul><li><p>复制场景</p><ul><li><p>Editorlayer.cpp  点击运行，执行Scene的Copy函数复制当前的场景，并设置面板的上下文为新场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnScenePlay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_SceneState = SceneState::Play;</span><br><span class="line"></span><br><span class="line">    m_ActiveScene = Scene::<span class="built_in">Copy</span>(m_EditorScene);</span><br><span class="line">    m_ActiveScene-&gt;<span class="built_in">OnRuntimeStart</span>(); </span><br><span class="line"></span><br><span class="line">    m_SceneHierarchyPanel.<span class="built_in">SetContext</span>(m_ActiveScene);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行Scene的Copy函数<strong>复制</strong>当前的场景</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Ref&lt;Scene&gt; <span class="title">Scene::Copy</span><span class="params">(Ref&lt;Scene&gt; other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的 Scene 实例</span></span><br><span class="line">    Ref&lt;Scene&gt; newScene = <span class="built_in">CreateRef</span>&lt;Scene&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制视口宽度和高度</span></span><br><span class="line">    newScene-&gt;m_ViewportWidth = other-&gt;m_ViewportWidth;</span><br><span class="line">    newScene-&gt;m_ViewportHeight = other-&gt;m_ViewportHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取源场景的实体注册表和新场景的实体注册表</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; srcSceneRegistry = other-&gt;m_Registry;</span><br><span class="line">    <span class="keyword">auto</span>&amp; dstSceneRegistry = newScene-&gt;m_Registry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于存储 UUID 和新创建的 entt::entity 之间的映射关系</span></span><br><span class="line">    std::unordered_map&lt;UUID, entt::entity&gt; enttMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取源场景中所有具有 IDComponent 组件的实体视图</span></span><br><span class="line">    <span class="keyword">auto</span> idView = srcSceneRegistry.<span class="built_in">view</span>&lt;IDComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序遍历所有实体（保证实体创建的顺序与原场景一致）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = idView.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        entt::entity e = *(idView.<span class="built_in">begin</span>() + i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取实体的 UUID</span></span><br><span class="line">        UUID uuid = srcSceneRegistry.<span class="built_in">get</span>&lt;IDComponent&gt;(e).ID;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取实体的名称</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; name = srcSceneRegistry.<span class="built_in">get</span>&lt;TagComponent&gt;(e).Tag;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在新场景中创建一个具有相同 UUID 和名称的新实体</span></span><br><span class="line">        Entity newEntity = newScene-&gt;<span class="built_in">CreateEntityWithUUID</span>(uuid, name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将新创建的实体存入映射表，供后续组件复制使用</span></span><br><span class="line">        enttMap[uuid] = (entt::entity)newEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制组件（排除 IDComponent 和 TagComponent，因为它们已在实体创建时设置）</span></span><br><span class="line">    <span class="built_in">CopyComponent</span>&lt;TransformComponent&gt;(dstSceneRegistry, srcSceneRegistry, enttMap);</span><br><span class="line">    <span class="built_in">CopyComponent</span>&lt;SpriteRendererComponent&gt;(dstSceneRegistry, srcSceneRegistry, enttMap);</span><br><span class="line">    <span class="built_in">CopyComponent</span>&lt;CameraComponent&gt;(dstSceneRegistry, srcSceneRegistry, enttMap);</span><br><span class="line">    <span class="built_in">CopyComponent</span>&lt;NativeScriptComponent&gt;(dstSceneRegistry, srcSceneRegistry, enttMap);</span><br><span class="line">    <span class="built_in">CopyComponent</span>&lt;Rigidbody2DComponent&gt;(dstSceneRegistry, srcSceneRegistry, enttMap);</span><br><span class="line">    <span class="built_in">CopyComponent</span>&lt;BoxCollider2DComponent&gt;(dstSceneRegistry, srcSceneRegistry, enttMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回复制后的新场景</span></span><br><span class="line">    <span class="keyword">return</span> newScene;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>复制实体</p><ul><li><p>Editorlayer. cpp 按下快捷键ctrl+d，执行OnDuplicateEntity函数，复制当前选择的实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnDuplicateEntity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_SceneState != SceneState::Edit)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Entity selectedEntity = m_SceneHierarchyPanel.<span class="built_in">GetSelectedEntity</span>();</span><br><span class="line">    <span class="keyword">if</span> (selectedEntity)</span><br><span class="line">        m_EditorScene-&gt;<span class="built_in">DuplicateEntity</span>(selectedEntity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Scene的DuplicateEntity函数执行具体操作</p><ol><li>创建旧实体同名的新实体</li><li>复制组件</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::DuplicateEntity</span><span class="params">(Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string name = entity.<span class="built_in">GetName</span>();  <span class="comment">// 获取原实体的名称</span></span><br><span class="line">    Entity newEntity = <span class="built_in">CreateEntity</span>(name); <span class="comment">// 创建一个新的实体，名称与原实体相同</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制所有可能存在的组件</span></span><br><span class="line">    <span class="built_in">CopyComponentIfExists</span>&lt;TransformComponent&gt;(newEntity, entity);</span><br><span class="line">    <span class="built_in">CopyComponentIfExists</span>&lt;SpriteRendererComponent&gt;(newEntity, entity);</span><br><span class="line">    <span class="built_in">CopyComponentIfExists</span>&lt;CameraComponent&gt;(newEntity, entity);</span><br><span class="line">    <span class="built_in">CopyComponentIfExists</span>&lt;NativeScriptComponent&gt;(newEntity, entity);</span><br><span class="line">    <span class="built_in">CopyComponentIfExists</span>&lt;Rigidbody2DComponent&gt;(newEntity, entity);</span><br><span class="line">    <span class="built_in">CopyComponentIfExists</span>&lt;BoxCollider2DComponent&gt;(newEntity, entity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Component&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CopyComponentIfExists</span><span class="params">(Entity dst, Entity src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">HasComponent</span>&lt;Component&gt;()) <span class="comment">// 检查原实体是否拥有该组件</span></span><br><span class="line">        dst.<span class="built_in">AddOrReplaceComponent</span>&lt;Component&gt;(src.<span class="built_in">GetComponent</span>&lt;Component&gt;()); <span class="comment">// 复制组件到新实体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">T&amp; <span class="title">AddOrReplaceComponent</span><span class="params">(Args&amp;&amp;... args)</span><span class="comment">//接受按值传递的旧实体组件数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">/* emplace_or_replace&lt;T&gt;：</span></span><br><span class="line"><span class="comment">如果 m_EntityHandle 之前没有该组件，则添加组件。</span></span><br><span class="line"><span class="comment">如果 m_EntityHandle 已有该组件，则替换组件。 */</span></span><br><span class="line">      </span><br><span class="line">    T&amp; component = m_Scene-&gt;m_Registry.<span class="built_in">emplace_or_replace</span>&lt;T&gt;(m_EntityHandle, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">    m_Scene-&gt;<span class="built_in">OnComponentAdded</span>&lt;T&gt;(*<span class="keyword">this</span>, component);</span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="七十七、成功绘制2D圆">七十七、成功绘制2D圆</h2><h4 id="前言-17">前言</h4><ul><li><p>此节目的</p><p>给引擎添加渲染Circle图形</p></li></ul><h4 id="代码-12">代码</h4><ul><li><p>circle的glsl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#type vertex</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 a_WorldPosition;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec3 a_LocalPosition;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">2</span>) in vec4 a_Color;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">3</span>) in <span class="type">float</span> a_Thickness;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">4</span>) in <span class="type">float</span> a_Fade;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">5</span>) in <span class="type">int</span> a_EntityID;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(std140, binding = <span class="number">0</span>) uniform Camera</span><br><span class="line">&#123;</span><br><span class="line">mat4 u_ViewProjection;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexOutput</span></span><br><span class="line">&#123;</span><br><span class="line">vec3 LocalPosition;</span><br><span class="line">vec4 Color;</span><br><span class="line"><span class="type">float</span> Thickness;</span><br><span class="line"><span class="type">float</span> Fade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) out VertexOutput Output;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">4</span>) out flat <span class="type">int</span> v_EntityID;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Output.LocalPosition = a_LocalPosition;</span><br><span class="line">Output.Color = a_Color;</span><br><span class="line">Output.Thickness = a_Thickness;</span><br><span class="line">Output.Fade = a_Fade;</span><br><span class="line"></span><br><span class="line">v_EntityID = a_EntityID;</span><br><span class="line"></span><br><span class="line">gl_Position = u_ViewProjection * <span class="built_in">vec4</span>(a_WorldPosition, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#type fragment</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) out vec4 o_Color;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) out <span class="type">int</span> o_EntityID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexOutput</span></span><br><span class="line">&#123;</span><br><span class="line">vec3 LocalPosition;</span><br><span class="line">vec4 Color;</span><br><span class="line"><span class="type">float</span> Thickness;</span><br><span class="line"><span class="type">float</span> Fade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">0</span>) in VertexOutput Input;</span><br><span class="line"><span class="built_in">layout</span> (location = <span class="number">4</span>) in flat <span class="type">int</span> v_EntityID;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Calculate distance and fill circle with white</span></span><br><span class="line"><span class="type">float</span> distance = <span class="number">1.0</span> - <span class="built_in">length</span>(Input.LocalPosition);</span><br><span class="line"><span class="type">float</span> circle = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, Input.Fade, distance);</span><br><span class="line">circle *= <span class="built_in">smoothstep</span>(Input.Thickness + Input.Fade, Input.Thickness, distance);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(circle == <span class="number">0.0f</span>)</span><br><span class="line">discard;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Set ouput color</span></span><br><span class="line">o_Color = Input.Color;</span><br><span class="line">o_Color.a *= circle;</span><br><span class="line"></span><br><span class="line">o_EntityID = v_EntityID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Renderer2D.cpp 批处理代码加上circle的顶点数组等信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CircleVertex</span> &#123;</span><br><span class="line">    glm::vec3 WorldPosition;</span><br><span class="line">    glm::vec3 LocalPosition;</span><br><span class="line">    glm::vec4 Color;</span><br><span class="line">    <span class="type">float</span> Thickness;</span><br><span class="line">    <span class="type">float</span> Fade;</span><br><span class="line">    <span class="comment">// Editor-only;</span></span><br><span class="line">    <span class="type">int</span> EntityID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Renderer2DData</span></span><br><span class="line">&#123;</span><br><span class="line">    Ref&lt;VertexArray&gt; CircleVertexArray;</span><br><span class="line">    Ref&lt;VertexBuffer&gt; CircleVertexBuffer;</span><br><span class="line">    Ref&lt;Shader&gt; CircleShader;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> CircleIndexCount = <span class="number">0</span>;</span><br><span class="line">    CircleVertex* CircleVertexBufferBase = <span class="literal">nullptr</span>;</span><br><span class="line">    CircleVertex* CircleVertexBufferPtr = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Circles</span></span><br><span class="line">    s_Data.CircleVertexArray = VertexArray::<span class="built_in">Create</span>();</span><br><span class="line"></span><br><span class="line">    s_Data.CircleVertexBuffer = VertexBuffer::<span class="built_in">Create</span>(s_Data.MaxVertices * <span class="built_in">sizeof</span>(CircleVertex));</span><br><span class="line">    s_Data.CircleVertexBuffer-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">        &#123; ShaderDataType::Float3,<span class="string">&quot;a_WorldPosition&quot;</span> &#125;,</span><br><span class="line">        &#123; ShaderDataType::Float3,<span class="string">&quot;a_LocalPosition&quot;</span>&#125;,</span><br><span class="line">        &#123; ShaderDataType::Float4,<span class="string">&quot;a_Color&quot;</span>&#125;,</span><br><span class="line">        &#123; ShaderDataType::Float,<span class="string">&quot;a_Thickness&quot;</span>&#125;,</span><br><span class="line">        &#123; ShaderDataType::Float,<span class="string">&quot;a_Fade&quot;</span>&#125;,</span><br><span class="line">        &#123; ShaderDataType::Int,<span class="string">&quot;a_EntityID&quot;</span>&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    s_Data.CircleVertexArray-&gt;<span class="built_in">AddVertexBuffer</span>(s_Data.CircleVertexBuffer);</span><br><span class="line">    s_Data.CircleVertexArray-&gt;<span class="built_in">SetIndexBuffer</span>(quadIB);<span class="comment">//Use quad IB</span></span><br><span class="line">    s_Data.CircleVertexBufferBase = <span class="keyword">new</span> CircleVertex[s_Data.MaxVertices];</span><br><span class="line">    </span><br><span class="line">    s_Data.CircleShader = Shader::<span class="built_in">Create</span>(<span class="string">&quot;assets/shaders/Renderer2D_Circle.glsl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::StartBatch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_Data.CircleIndexCount = <span class="number">0</span>;</span><br><span class="line">    s_Data.CircleVertexBufferPtr = s_Data.CircleVertexBufferBase;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::Flush</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s_Data.CircleIndexCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> dataSize = (<span class="type">uint32_t</span>)((<span class="type">uint8_t</span>*)s_Data.CircleVertexBufferPtr - (<span class="type">uint8_t</span>*)s_Data.CircleVertexBufferBase);</span><br><span class="line">        s_Data.CircleVertexBuffer-&gt;<span class="built_in">SetData</span>(s_Data.CircleVertexBufferBase, dataSize);</span><br><span class="line"></span><br><span class="line">        s_Data.CircleShader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        RenderCommand::<span class="built_in">DrawIndexed</span>(s_Data.CircleVertexArray, s_Data.CircleIndexCount);</span><br><span class="line">        s_Data.Stats.DrawCalls++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawCircle</span><span class="params">(<span class="type">const</span> glm::mat4&amp; transform, <span class="type">const</span> glm::vec4&amp; color, <span class="type">float</span> thickness, <span class="type">float</span> fade, <span class="type">int</span> entityID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s_Data.CircleVertexBufferPtr-&gt;WorldPosition = transform * s_Data.QuadVertexPositions[i];</span><br><span class="line">        s_Data.CircleVertexBufferPtr-&gt;LocalPosition = s_Data.QuadVertexPositions[i] * <span class="number">2.0f</span>;</span><br><span class="line">        s_Data.CircleVertexBufferPtr-&gt;Color = color;</span><br><span class="line">        s_Data.CircleVertexBufferPtr-&gt;Thickness = thickness;</span><br><span class="line">        s_Data.CircleVertexBufferPtr-&gt;Fade = fade;</span><br><span class="line">        s_Data.CircleVertexBufferPtr-&gt;EntityID = entityID;</span><br><span class="line">        s_Data.CircleVertexBufferPtr++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s_Data.CircleIndexCount += <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    s_Data.Stats.QuadCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Components.h  添加Circle组件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CircleRendererComponent</span> &#123;</span><br><span class="line">    glm::vec4 Color&#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="type">float</span> Thickness = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">float</span> Fade = <span class="number">0.005f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CircleRendererComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">CircleRendererComponent</span>(<span class="type">const</span> CircleRendererComponent&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Scene.cpp  扫描当前场景有<strong>Circle</strong>的组件，遍历然后调用draw绘制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::OnUpdateEditor</span><span class="params">(Timestep ts, EditorCamera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Draw circles</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> view = m_Registry.<span class="built_in">view</span>&lt;TransformComponent, CircleRendererComponent&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entity : view)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [transform, circle] = view.<span class="built_in">get</span>&lt;TransformComponent, CircleRendererComponent&gt;(entity);</span><br><span class="line"></span><br><span class="line">            Renderer2D::<span class="built_in">DrawCircle</span>(transform.<span class="built_in">GetTransform</span>(), circle.Color, circle.Thickness, circle.Fade, (<span class="type">int</span>)entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SceneSerializer.cpp 添加circle的序列化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;CircleRendererComponent&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;CircleRendererComponent&quot;</span>;</span><br><span class="line">    out &lt;&lt; YAML::BeginMap; <span class="comment">// CircleRendererComponent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; circleRendererComponent = entity.<span class="built_in">GetComponent</span>&lt;CircleRendererComponent&gt;();</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Color&quot;</span> &lt;&lt; YAML::Value &lt;&lt; circleRendererComponent.Color;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Thickness&quot;</span> &lt;&lt; YAML::Value &lt;&lt; circleRendererComponent.Thickness;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Fade&quot;</span> &lt;&lt; YAML::Value &lt;&lt; circleRendererComponent.Fade;</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; YAML::EndMap; <span class="comment">// CircleRendererComponent</span></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="keyword">auto</span> circleRendererComponent = entity[<span class="string">&quot;CircleRendererComponent&quot;</span>];</span><br><span class="line"><span class="keyword">if</span> (circleRendererComponent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; crc = deserializedEntity.<span class="built_in">AddComponent</span>&lt;CircleRendererComponent&gt;();</span><br><span class="line">    crc.Color = circleRendererComponent[<span class="string">&quot;Color&quot;</span>].<span class="built_in">as</span>&lt;glm::vec4&gt;();</span><br><span class="line">    crc.Thickness = circleRendererComponent[<span class="string">&quot;Thickness&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">    crc.Fade = circleRendererComponent[<span class="string">&quot;Fade&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SceneHierarchyPanel.cpp 组件添加Circle</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::DrawComponents</span><span class="params">(Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_SelectionContext.<span class="built_in">HasComponent</span>&lt;CircleRendererComponent&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Circle Renderer&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            m_SelectionContext.<span class="built_in">AddComponent</span>&lt;CircleRendererComponent&gt;();</span><br><span class="line">            ImGui::<span class="built_in">CloseCurrentPopup</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DrawComponent</span>&lt;CircleRendererComponent&gt;(<span class="string">&quot;Circle Renderer&quot;</span>, entity, [](<span class="keyword">auto</span>&amp; component)</span><br><span class="line">    &#123;</span><br><span class="line">        ImGui::<span class="built_in">ColorEdit4</span>(<span class="string">&quot;Color&quot;</span>, glm::<span class="built_in">value_ptr</span>(component.Color));</span><br><span class="line">        ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Thickness&quot;</span>, &amp;component.Thickness, <span class="number">0.025f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Fade&quot;</span>, &amp;component.Fade, <span class="number">0.00025f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="七十八、添加线段和矩形渲染">七十八、添加线段和矩形渲染</h2><h4 id="前言-18">前言</h4><ul><li><p>此节目的</p><p>要给当前引擎添加能渲染<strong>线条</strong>、<strong>方框</strong>功能。渲染方框是在渲染线条的基础上实现的</p></li></ul><h4 id="代码-13">代码</h4><ul><li><p>新增Renderer2D_Line.glsl</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#type vertex</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> a_Position;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec4</span> a_Color;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">2</span>) <span class="keyword">in</span> <span class="type">int</span> a_EntityID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">std140</span>, <span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> Camera</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">mat4</span> u_ViewProjection;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct VertexOutput</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">vec4</span> Color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> VertexOutput Output;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="keyword">flat</span> <span class="type">int</span> v_EntityID;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">Output.Color = a_Color;</span><br><span class="line"></span><br><span class="line">v_EntityID = a_EntityID;</span><br><span class="line"></span><br><span class="line"><span class="built_in">gl_Position</span> = u_ViewProjection * <span class="type">vec4</span>(a_Position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#type fragment</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> o_Color;</span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">out</span> <span class="type">int</span> o_EntityID;</span><br><span class="line"></span><br><span class="line">struct VertexOutput</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">vec4</span> Color;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">in</span> VertexOutput Input;</span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span> = <span class="number">1</span>) <span class="keyword">in</span> <span class="keyword">flat</span> <span class="type">int</span> v_EntityID;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">o_Color = Input.Color;</span><br><span class="line">o_EntityID = v_EntityID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>OpenGLRendererAPI.cpp 实际绘制Line的opengl代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::DrawLines</span><span class="params">(<span class="type">const</span> Ref&lt;VertexArray&gt;&amp; vertexArray, <span class="type">uint32_t</span> vertexCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vertexArray-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    <span class="built_in">glDrawArrays</span>(GL_LINES, <span class="number">0</span>, vertexCount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::SetLineWidth</span><span class="params">(<span class="type">float</span> width)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glLineWidth</span>(width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Renderer2D.cpp 批处理代码加上line的顶点数组等信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LineVertex</span> &#123;</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec4 Color;</span><br><span class="line">    <span class="type">int</span> EntityID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Ref&lt;VertexArray&gt; LineVertexArray;</span><br><span class="line">Ref&lt;VertexBuffer&gt; LineVertexBuffer;</span><br><span class="line">Ref&lt;Shader&gt; LineShader;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> LineVertexCount = <span class="number">0</span>;<span class="comment">// 只需要提供顶点数量</span></span><br><span class="line">LineVertex* LineVertexBufferBase = <span class="literal">nullptr</span>;</span><br><span class="line">LineVertex* LineVertexBufferPtr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0.在CPU开辟存储s_Data.MaxVertices个的LineVertex的内存</span></span><br><span class="line">s_Data.LineVertexBufferBase = <span class="keyword">new</span> LineVertex[s_Data.MaxVertices];</span><br><span class="line"><span class="comment">// 1.创建顶点数组</span></span><br><span class="line">s_Data.LineVertexArray = VertexArray::<span class="built_in">Create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建顶点缓冲区</span></span><br><span class="line">s_Data.LineVertexBuffer = VertexBuffer::<span class="built_in">Create</span>(s_Data.MaxVertices * <span class="built_in">sizeof</span>(LineVertex));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1设置顶点缓冲区布局</span></span><br><span class="line">s_Data.LineVertexBuffer-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">    &#123;ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;,</span><br><span class="line">    &#123;ShaderDataType::Float4, <span class="string">&quot;a_Color&quot;</span>&#125;,</span><br><span class="line">    &#123;ShaderDataType::Int, <span class="string">&quot;a_EntityID&quot;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1设置顶点数组使用的缓冲区，并且在这个缓冲区中设置布局</span></span><br><span class="line">s_Data.LineVertexArray-&gt;<span class="built_in">AddVertexBuffer</span>(s_Data.LineVertexBuffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.索引缓冲-Line不需要索引缓冲区</span></span><br><span class="line">s_Data.LineShader = Shader::<span class="built_in">Create</span>(<span class="string">&quot;assets/shaders/Renderer2D_Line.glsl&quot;</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::Flush</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s_Data.LineVertexCount) &#123;</span><br><span class="line">        <span class="comment">// 计算当前绘制需要多少个顶点数据</span></span><br><span class="line">        <span class="type">uint32_t</span> dataSize = (<span class="type">uint8_t</span>*)s_Data.LineVertexBufferPtr - (<span class="type">uint8_t</span>*)s_Data.LineVertexBufferBase;</span><br><span class="line">        <span class="comment">// 截取部分CPU的顶点数据上传OpenGL</span></span><br><span class="line">        s_Data.LineVertexBuffer-&gt;<span class="built_in">SetData</span>(s_Data.LineVertexBufferBase, dataSize);</span><br><span class="line"></span><br><span class="line">        s_Data.LineShader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        <span class="comment">// 新增的：设置线条宽度</span></span><br><span class="line">        RenderCommand::<span class="built_in">SetLineWidth</span>(s_Data.LineWidth);</span><br><span class="line">        <span class="comment">// 调用绘画命令</span></span><br><span class="line">        RenderCommand::<span class="built_in">DrawLines</span>(s_Data.LineVertexArray, s_Data.LineVertexCount);</span><br><span class="line">        s_Data.Stats.DrawCalls++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawLine</span><span class="params">(<span class="type">const</span> glm::vec3&amp; p0, glm::vec3&amp; p1, <span class="type">const</span> glm::vec4&amp; color, <span class="type">int</span> entityID)</span></span>&#123;</span><br><span class="line">    s_Data.LineVertexBufferPtr-&gt;Position = p0;</span><br><span class="line">    s_Data.LineVertexBufferPtr-&gt;Color = color;</span><br><span class="line">    s_Data.LineVertexBufferPtr-&gt;EntityID = entityID;</span><br><span class="line">    s_Data.LineVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">    s_Data.LineVertexBufferPtr-&gt;Position = p1;</span><br><span class="line">    s_Data.LineVertexBufferPtr-&gt;Color = color;</span><br><span class="line">    s_Data.LineVertexBufferPtr-&gt;EntityID = entityID;</span><br><span class="line">    s_Data.LineVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">    s_Data.LineVertexCount += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据一点中心位置确定4个点的位置绘制rect</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawRect</span><span class="params">(<span class="type">const</span> glm::vec3&amp; position, <span class="type">const</span> glm::vec2&amp; size, <span class="type">const</span> glm::vec4&amp; color, <span class="type">int</span> entityID)</span></span>&#123;</span><br><span class="line">    <span class="comment">// position是中心位置</span></span><br><span class="line">    glm::vec3 p0 = glm::<span class="built_in">vec3</span>(position.x - size.x * <span class="number">0.5f</span>, position.y - size.y * <span class="number">0.5f</span>, position.z);<span class="comment">// 左下角</span></span><br><span class="line">    glm::vec3 p1 = glm::<span class="built_in">vec3</span>(position.x + size.x * <span class="number">0.5f</span>, position.y - size.y * <span class="number">0.5f</span>, position.z);<span class="comment">// 右下角</span></span><br><span class="line">    glm::vec3 p2 = glm::<span class="built_in">vec3</span>(position.x + size.x * <span class="number">0.5f</span>, position.y + size.y * <span class="number">0.5f</span>, position.z);<span class="comment">// 右上角</span></span><br><span class="line">    glm::vec3 p3 = glm::<span class="built_in">vec3</span>(position.x - size.x * <span class="number">0.5f</span>, position.y + size.y * <span class="number">0.5f</span>, position.z);<span class="comment">// 左上角</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">DrawLine</span>(p0, p1, color);</span><br><span class="line">    <span class="built_in">DrawLine</span>(p1, p2, color);</span><br><span class="line">    <span class="built_in">DrawLine</span>(p2, p3, color);</span><br><span class="line">    <span class="built_in">DrawLine</span>(p3, p0, color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据实体的transform确定顶点位置再绘制</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawRect</span><span class="params">(<span class="type">const</span> glm::mat4&amp; transform, <span class="type">const</span> glm::vec4&amp; color, <span class="type">int</span> entityID)</span></span>&#123;</span><br><span class="line">    glm::vec3 lineVertices[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lineVertices[i] = transform * s_Data.QuadVertexPosition[i]; <span class="comment">// quad的顶点位置正好是rect的顶点位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DrawLine</span>(lineVertices[<span class="number">0</span>], lineVertices[<span class="number">1</span>], color);</span><br><span class="line">    <span class="built_in">DrawLine</span>(lineVertices[<span class="number">1</span>], lineVertices[<span class="number">2</span>], color);</span><br><span class="line">    <span class="built_in">DrawLine</span>(lineVertices[<span class="number">2</span>], lineVertices[<span class="number">3</span>], color);</span><br><span class="line">    <span class="built_in">DrawLine</span>(lineVertices[<span class="number">3</span>], lineVertices[<span class="number">0</span>], color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Scene.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::OnUpdateEditor</span><span class="params">(Timestep ts, EditorCamera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Renderer2D::<span class="built_in">BeginScene</span>(camera);</span><br><span class="line">    Renderer2D::<span class="built_in">DrawLine</span>(glm::<span class="built_in">vec3</span>(<span class="number">2.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">5.0f</span>), glm::<span class="built_in">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    Renderer2D::<span class="built_in">DrawRect</span>(glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec4</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    Renderer2D::<span class="built_in">EndScene</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="七十九、添加圆形组件和物理">七十九、添加圆形组件和物理</h2><h4 id="前言-19">前言</h4><ul><li><p>此节目的</p><p>添加圆形组件,设置圆形组件的属性面板,在编辑场景显示实体物理组件的包围盒</p></li></ul><h4 id="代码-14">代码</h4><ul><li><p>Components.h 设置圆形包围盒组件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Circle包围盒</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CircleCollider2DComponent</span> &#123;</span><br><span class="line">    glm::vec2 Offset = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    <span class="type">float</span> Radius = <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span>移到物理材质</span></span><br><span class="line">    <span class="type">float</span> Density = <span class="number">1.0f</span>;           <span class="comment">// 密度,0是静态的物理</span></span><br><span class="line">    <span class="type">float</span> Friction = <span class="number">0.5f</span>;          <span class="comment">// 摩擦力</span></span><br><span class="line">    <span class="type">float</span> Restitution = <span class="number">0.0f</span>;       <span class="comment">// 弹力，0不会弹跳，1无限弹跳</span></span><br><span class="line">    <span class="type">float</span> RestitutionThreshold = <span class="number">0.5f</span>;<span class="comment">// 复原速度阈值，超过这个速度的碰撞就会被恢复原状（会反弹）。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行时候由于物理，每一帧的上述参数可能会变，所以保存为对象,但未使用</span></span><br><span class="line">    <span class="type">void</span>* RuntimeFixture = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CircleCollider2DComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">CircleCollider2DComponent</span>(<span class="type">const</span> CircleCollider2DComponent&amp;) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>PhysicsManager.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PhysicsManager::AttachCircleCollider</span><span class="params">(Scene* scene, entt::entity e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity entity = &#123; e, scene &#125;;</span><br><span class="line">    <span class="keyword">auto</span>&amp; transform = entity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;();</span><br><span class="line">    <span class="keyword">auto</span>&amp; cc2d = entity.<span class="built_in">GetComponent</span>&lt;CircleCollider2DComponent&gt;();</span><br><span class="line">    <span class="keyword">auto</span>&amp; rb2d = entity.<span class="built_in">GetComponent</span>&lt;Rigidbody2DComponent&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">b2Body_IsValid</span>(rb2d.RuntimeBodyId)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    b2Circle circleShape;</span><br><span class="line">    circleShape.center = &#123; cc2d.Offset.x, cc2d.Offset.y &#125;;</span><br><span class="line">    circleShape.radius = cc2d.Radius;</span><br><span class="line"></span><br><span class="line">    b2ShapeDef shapeDef = <span class="built_in">b2DefaultShapeDef</span>();</span><br><span class="line">    shapeDef.friction = cc2d.Friction;</span><br><span class="line">    shapeDef.density = cc2d.Density;</span><br><span class="line">    shapeDef.restitution = cc2d.Restitution;</span><br><span class="line"></span><br><span class="line">    b2ShapeId shapeID = <span class="built_in">b2CreateCircleShape</span>(rb2d.RuntimeBodyId, &amp;shapeDef, &amp;circleShape);</span><br><span class="line">    cc2d.RuntimeShapeId = shapeID;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="built_in">b2Shape_IsValid</span>(cc2d.RuntimeShapeId), <span class="string">&quot;Circle Shape id validation failed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Scene.cpp 在属性面板显示圆形包围盒组件代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!m_SelectionContext.<span class="built_in">HasComponent</span>&lt;CircleCollider2DComponent&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Circle Collider 2D&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        m_SelectionContext.<span class="built_in">AddComponent</span>&lt;CircleCollider2DComponent&gt;();</span><br><span class="line">        ImGui::<span class="built_in">CloseCurrentPopup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">DrawComponent</span>&lt;CircleRendererComponent&gt;(<span class="string">&quot;Circle Renderer&quot;</span>, entity, [](<span class="keyword">auto</span>&amp; component)</span><br><span class="line">&#123;</span><br><span class="line">    ImGui::<span class="built_in">ColorEdit4</span>(<span class="string">&quot;Color&quot;</span>, glm::<span class="built_in">value_ptr</span>(component.Color));</span><br><span class="line">    ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Thickness&quot;</span>, &amp;component.Thickness, <span class="number">0.025f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">    ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Fade&quot;</span>, &amp;component.Fade, <span class="number">0.00025f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>场景yaml文件需序列化保存和解析包围盒组件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;CircleCollider2DComponent&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;CircleCollider2DComponent&quot;</span>;</span><br><span class="line">    out &lt;&lt; YAML::BeginMap; <span class="comment">// CircleCollider2DComponent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; cc2dComponent = entity.<span class="built_in">GetComponent</span>&lt;CircleCollider2DComponent&gt;();</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Offset&quot;</span> &lt;&lt; YAML::Value &lt;&lt; cc2dComponent.Offset;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Radius&quot;</span> &lt;&lt; YAML::Value &lt;&lt; cc2dComponent.Radius;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Density&quot;</span> &lt;&lt; YAML::Value &lt;&lt; cc2dComponent.Density;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Friction&quot;</span> &lt;&lt; YAML::Value &lt;&lt; cc2dComponent.Friction;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Restitution&quot;</span> &lt;&lt; YAML::Value &lt;&lt; cc2dComponent.Restitution;</span><br><span class="line">    out &lt;&lt; YAML::EndMap; <span class="comment">// CircleCollider2DComponent</span></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"><span class="keyword">auto</span> circleCollider2DComponent = entity[<span class="string">&quot;CircleCollider2DComponent&quot;</span>];</span><br><span class="line"><span class="keyword">if</span> (circleCollider2DComponent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; cc2d = deserializedEntity.<span class="built_in">AddComponent</span>&lt;CircleCollider2DComponent&gt;();</span><br><span class="line">    cc2d.Offset = boxCollider2DComponent[<span class="string">&quot;Offset&quot;</span>].<span class="built_in">as</span>&lt;glm::vec2&gt;();</span><br><span class="line">    cc2d.Radius = boxCollider2DComponent[<span class="string">&quot;Radius&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">    cc2d.Density = boxCollider2DComponent[<span class="string">&quot;Density&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">    cc2d.Friction = boxCollider2DComponent[<span class="string">&quot;Friction&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">    cc2d.Restitution = boxCollider2DComponent[<span class="string">&quot;Restitution&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">float</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="八十、-可视化物理包围盒">八十、 可视化物理包围盒</h2><h4 id="前言-20">前言</h4><ul><li><p>此节目的</p><p>实现一个复选框点击后，场景可以<strong>渲染出图形相应的包围盒</strong>，使用上两节加的渲染<strong>Line</strong>和<strong>Rect</strong>来渲染盒状包围盒。，至于圆的包围盒，一样绘制圆，只不过控制<strong>厚度</strong>，从而实现<strong>圆环</strong>形状=圆包围盒</p></li></ul><h4 id="代码-15">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnOverlayRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_SceneState == SceneState::Play) </span><br><span class="line">    &#123;</span><br><span class="line">        Entity camera = m_ActiveScene-&gt;<span class="built_in">GetPrimaryCameraEntity</span>();</span><br><span class="line">        <span class="comment">// Caemra类没有视图矩阵，所以需传入transform计算视图矩阵</span></span><br><span class="line">        Renderer2D::<span class="built_in">BeginScene</span>(camera.<span class="built_in">GetComponent</span>&lt;CameraComponent&gt;().camera, camera.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;().<span class="built_in">GetTransform</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// EditorCamera，可以直接获取投影视图矩阵，所以不需要transform</span></span><br><span class="line">        Renderer2D::<span class="built_in">BeginScene</span>(m_EditorCamera);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_ShowPhysicsColliders) <span class="comment">// 由复选框控制</span></span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> view = m_ActiveScene-&gt;<span class="built_in">GetAllEntitiesWith</span>&lt;TransformComponent, BoxCollider2DComponent&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> entity : view) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [tc, bc2d] = view.<span class="built_in">get</span>&lt;TransformComponent, BoxCollider2DComponent&gt;(entity);</span><br><span class="line">                <span class="comment">// 0.001fZ轴偏移量</span></span><br><span class="line">                glm::vec3 translation = tc.Translation + glm::<span class="built_in">vec3</span>(bc2d.Offset, <span class="number">0.001f</span>);</span><br><span class="line">                glm::vec3 scale = tc.Scale * glm::<span class="built_in">vec3</span>(bc2d.Size * <span class="number">2.0f</span>, <span class="number">1.0f</span>); </span><br><span class="line"></span><br><span class="line">                glm::mat4 transform = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), translation)</span><br><span class="line">                * glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), tc.Rotation.z, glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>))          * glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), scale);</span><br><span class="line"></span><br><span class="line">                Renderer2D::<span class="built_in">DrawRect</span>(transform, glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));<span class="comment">// 绿色的包围盒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//Circle Colliders</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> view = m_ActiveScene-&gt;<span class="built_in">GetAllEntitiesWith</span>&lt;TransformComponent, CircleCollider2DComponent&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> entity : view)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> [tc, cc2d] = view.<span class="built_in">get</span>&lt;TransformComponent, CircleCollider2DComponent&gt;(entity);</span><br><span class="line"></span><br><span class="line">                glm::vec3 translation = tc.Translation + glm::<span class="built_in">vec3</span>(cc2d.Offset, <span class="number">0.001f</span>);</span><br><span class="line">                glm::vec3 scale = tc.Scale * glm::<span class="built_in">vec3</span>(cc2d.Radius * <span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line">                glm::mat4 transform = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), translation)</span><br><span class="line">                    * glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), scale);</span><br><span class="line"></span><br><span class="line">                Renderer2D::<span class="built_in">DrawCircle</span>(transform, glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>), <span class="number">0.01f</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="八十一、添加模拟运行按钮">八十一、添加模拟运行按钮</h2><h4 id="前言-21">前言</h4><ul><li><p>此节目的</p><ul><li><p><strong>增加</strong>一个物理模拟运行模式，来运行给物体添加的物理效果，<strong>摄像机却使用编辑模式下的摄像机</strong>。</p></li><li><p><strong>区分</strong>Play运行模式的物理效果</p><p>这个模式的摄像机会变成场景里的<strong>主摄像机</strong>，而不是当前的<strong>编辑相机</strong></p></li></ul></li></ul><h4 id="代码-16">代码</h4><ul><li><p>Scene.cpp</p></li><li><pre><code class="language-c++">void Scene::OnSimulationStart()&#123;    OnPhysics2DStart();&#125;void Scene::OnSimulationStop()&#123;    OnPhysics2DStop();&#125;void Scene::OnPhysics2DStart()&#123;    PhysicsManager::Get().CreateWorld();    auto view = m_Registry.view&lt;Rigidbody2DComponent&gt;();    for (auto e : view)    &#123;        PhysicsManager::Get().AddRigibody(this, e);    &#125;&#125;void Scene::OnPhysics2DStop()&#123;    PhysicsManager::Get().DestoryWorld();&#125;<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- EditorLayer.cpp</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  <span class="keyword">void</span> <span class="title class_">EditorLayer</span>::<span class="title function_ invoke__">OnSceneSimulate</span>()<span class="comment">// 开始物理模拟模式</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">if</span> (m_SceneState == <span class="title class_">SceneState</span>::<span class="variable constant_">Play</span>) &#123;</span><br><span class="line">          <span class="title function_ invoke__">OnSceneStop</span>(); <span class="comment">// 停止物理</span></span><br><span class="line">      &#125;</span><br><span class="line">      m_SceneState = <span class="title class_">SceneState</span>::<span class="variable constant_">Simulate</span>;</span><br><span class="line">  </span><br><span class="line">      m_ActiveScene = <span class="title class_">Scene</span>::<span class="title function_ invoke__">Copy</span>(m_EditorScene);</span><br><span class="line">      m_ActiveScene-&gt;<span class="title function_ invoke__">OnSimulationStart</span>(); </span><br><span class="line">      m_SceneHierarchyPanel.<span class="title function_ invoke__">SetContext</span>(m_ActiveScene);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><hr><h2 id="八十二、Mono实现C-脚本">八十二、Mono实现C#脚本</h2><h4 id="前言-22">前言</h4><ul><li><p>此节目的</p><p>HEngine实现能cpp能调用C#的函数（C#语言嵌入cpp中），需要安装mono.Net库，并克隆git上的mono项目自己构建导出mono库。</p><p>即：<strong>需要.Net库和构建的mono库</strong>,用visual studio<strong>构建mono项目导出mono静态库</strong>，静态链接</p></li></ul><h4 id="Mono配置步骤：">Mono配置步骤：</h4><p>1.安装mono.Net库,<a href="https://www.mono-project.com/download/stable/">网址</a></p><p>2.克隆mono开源项目</p><ul><li><p>克隆mono开源项目</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">--recursive</span> https://github.com/mono/mono</span><br></pre></td></tr></table></figure></li></ul><p>3.生成静态库</p><ul><li><p>打开mono开源项目下的sln文件</p></li><li><p>打开后对libmono-static<strong>单个项目</strong>进行生成, 生成libmono-static-sgen.lib文件（函数的定义）</p><p>注意选择：debug 64和release 64 各自生成一次</p></li><li><p>Mono安装目录下<strong>include</strong>的文件夹有 libmono-static-sgen.lib文件中函数定义的<strong>头文件</strong>（函数声明）</p></li></ul><p>4.移动生成的库文件与inlcude文件</p><ul><li><p>1.将include/mono文件夹放入引擎下的vendor/mono/include下（函数声明）</p></li><li><p>2.拷贝生成的mono库文件到vender/mono下（函数定义）</p></li></ul><p>5.移动Mono安装目录里的.Net库文件</p><p>​到mono安装目录mono\lib\mono下，找到4.5版本的文件夹移动到HEngine-Editor\mono\lib\mono\4.5下</p><h4 id="代码-17">代码</h4><ul><li><p>新建项目HEngine-ScriptCore</p></li><li><p>添加Main.cs文件</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HEngine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> FloatVar &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Main constructor!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintMessage</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello World from C#!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintInt</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;C# says: <span class="subst">&#123;<span class="keyword">value</span>&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintInts</span>(<span class="params"><span class="built_in">int</span> value1, <span class="built_in">int</span> value2</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;C# says: <span class="subst">&#123;value1&#125;</span> and <span class="subst">&#123;value2&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintCustomMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;C# says: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建ScriptEngine类  写好初始化mono环境，加载C#项目生成的 dll</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScriptEngineData</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//Mono 运行时的根域，所有的 AppDomain 都运行在它之上</span></span><br><span class="line">MonoDomain* RootDomain = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//用于 C# 脚本执行的独立 应用域</span></span><br><span class="line">MonoDomain* AppDomain = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//加载的 C# DLL（HEngine-ScriptCore.dll），包含用户的 C# 代码</span></span><br><span class="line">MonoAssembly* CoreAssembly = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> ScriptEngineData* s_Data = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s_Data = <span class="keyword">new</span> <span class="built_in">ScriptEngineData</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">InitMono</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::Shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">ShutdownMono</span>();</span><br><span class="line"><span class="keyword">delete</span> s_Data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">ReadBytes</span><span class="params">(<span class="type">const</span> std::string&amp; filepath, <span class="type">uint32_t</span>* outSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath, std::ios::binary | std::ios::ate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!stream)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Failed to open the file</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::streampos end = stream.<span class="built_in">tellg</span>();</span><br><span class="line">stream.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg);</span><br><span class="line"><span class="type">uint32_t</span> size = end - stream.<span class="built_in">tellg</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// File is empty</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* buffer = <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line">stream.<span class="built_in">read</span>((<span class="type">char</span>*)buffer, size);</span><br><span class="line">stream.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">*outSize = size;</span><br><span class="line"><span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MonoAssembly* <span class="title">LoadCSharpAssembly</span><span class="params">(<span class="type">const</span> std::string&amp; assemblyPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">uint32_t</span> fileSize = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* fileData = <span class="built_in">ReadBytes</span>(assemblyPath, &amp;fileSize);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 MonoImage（DLL 映像），用于加载程序集。</span></span><br><span class="line">MonoImageOpenStatus status;</span><br><span class="line">MonoImage* image = <span class="built_in">mono_image_open_from_data_full</span>(fileData, fileSize, <span class="number">1</span>, &amp;status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (status != MONO_IMAGE_OK)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* errorMessage = <span class="built_in">mono_image_strerror</span>(status);</span><br><span class="line"><span class="comment">// Log some error message using the errorMessage data</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加载程序集（DLL）到 Mono 运行时</span></span><br><span class="line">MonoAssembly* assembly = <span class="built_in">mono_assembly_load_from_full</span>(image, assemblyPath.<span class="built_in">c_str</span>(), &amp;status, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">mono_image_close</span>(image);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don&#x27;t forget to free the file data</span></span><br><span class="line"><span class="keyword">delete</span>[] fileData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> assembly;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintAssemblyTypes</span><span class="params">(MonoAssembly* assembly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//获取assembly的image，然后获取类型定义表，读取所有 C# 类</span></span><br><span class="line">MonoImage* image = <span class="built_in">mono_assembly_get_image</span>(assembly);</span><br><span class="line"><span class="type">const</span> MonoTableInfo* typeDefinitionsTable = <span class="built_in">mono_image_get_table_info</span>(image, MONO_TABLE_TYPEDEF);</span><br><span class="line"><span class="type">int32_t</span> numTypes = <span class="built_in">mono_table_info_get_rows</span>(typeDefinitionsTable);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//遍历 C# 程序集中的所有类，并输出命名空间和类名。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; numTypes; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> cols[MONO_TYPEDEF_SIZE];</span><br><span class="line"><span class="built_in">mono_metadata_decode_row</span>(typeDefinitionsTable, i, cols, MONO_TYPEDEF_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* nameSpace = <span class="built_in">mono_metadata_string_heap</span>(image, cols[MONO_TYPEDEF_NAMESPACE]);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* name = <span class="built_in">mono_metadata_string_heap</span>(image, cols[MONO_TYPEDEF_NAME]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">HE_CORE_TRACE</span>(<span class="string">&quot;&#123;&#125;.&#123;&#125;&quot;</span>, nameSpace, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::InitMono</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">mono_set_assemblies_path</span>(<span class="string">&quot;mono/lib&quot;</span>);<span class="comment">//加载.dll组件</span></span><br><span class="line"><span class="comment">//创建Mono运行时的顶级作用域。</span></span><br><span class="line">MonoDomain* rootDomain = <span class="built_in">mono_jit_init</span>(<span class="string">&quot;HEngineITRuntime&quot;</span>);</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(rootDomain);</span><br><span class="line">s_Data-&gt;RootDomain = rootDomain;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建AppDomain（应用域），用于运行 C# 代码</span></span><br><span class="line">s_Data-&gt;AppDomain = <span class="built_in">mono_domain_create_appdomain</span>(<span class="string">&quot;HEngineScriptRuntime&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">mono_domain_set</span>(s_Data-&gt;AppDomain, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载 C# DLL，这是写的 C# 代码</span></span><br><span class="line">s_Data-&gt;CoreAssembly = <span class="built_in">LoadCSharpAssembly</span>(<span class="string">&quot;Resources/Scripts/HEngine-ScriptCore.dll&quot;</span>);</span><br><span class="line">        <span class="comment">//打印 DLL 内所有类的名称。</span></span><br><span class="line"><span class="built_in">PrintAssemblyTypes</span>(s_Data-&gt;CoreAssembly);</span><br><span class="line"></span><br><span class="line">MonoImage* assemblyImage = <span class="built_in">mono_assembly_get_image</span>(s_Data-&gt;CoreAssembly);</span><br><span class="line">MonoClass* monoClass = <span class="built_in">mono_class_from_name</span>(assemblyImage, <span class="string">&quot;HEngine&quot;</span>, <span class="string">&quot;Main&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到C#类HEngine.Main并在C#运行时创建实例（调用默认构造函数）。</span></span><br><span class="line">MonoObject* instance = <span class="built_in">mono_object_new</span>(s_Data-&gt;AppDomain, monoClass);</span><br><span class="line"><span class="built_in">mono_runtime_object_init</span>(instance);</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到 PrintMessage()方法并调用它。</span></span><br><span class="line">MonoMethod* printMessageFunc = <span class="built_in">mono_class_get_method_from_name</span>(monoClass, <span class="string">&quot;PrintMessage&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">mono_runtime_invoke</span>(printMessageFunc, instance, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到PrintInt(int value)方法并传递参数5。</span></span><br><span class="line">MonoMethod* printIntFunc = <span class="built_in">mono_class_get_method_from_name</span>(monoClass, <span class="string">&quot;PrintInt&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="type">void</span>* param = &amp;value;</span><br><span class="line"><span class="built_in">mono_runtime_invoke</span>(printIntFunc, instance, &amp;param, <span class="literal">nullptr</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//找到PrintInts(int a, int b)方法并传递两个参数5,508。</span></span><br><span class="line">MonoMethod* printIntsFunc = <span class="built_in">mono_class_get_method_from_name</span>(monoClass, <span class="string">&quot;PrintInts&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> value2 = <span class="number">508</span>;</span><br><span class="line"><span class="type">void</span>* params[<span class="number">2</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&amp;value,</span><br><span class="line">&amp;value2</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">mono_runtime_invoke</span>(printIntsFunc, instance, params, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建C#字符串,调用PrintCustomMessage(string message)。</span></span><br><span class="line">MonoString* monoString = <span class="built_in">mono_string_new</span>(s_Data-&gt;AppDomain, <span class="string">&quot;Hello World from C++!&quot;</span>);</span><br><span class="line">MonoMethod* printCustomMessageFunc = <span class="built_in">mono_class_get_method_from_name</span>(monoClass, <span class="string">&quot;PrintCustomMessage&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">void</span>* stringParam = monoString;</span><br><span class="line"><span class="built_in">mono_runtime_invoke</span>(printCustomMessageFunc, instance, &amp;stringParam, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HZ_CORE_ASSERT(false);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::ShutdownMono</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s_Data-&gt;AppDomain = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">s_Data-&gt;RootDomain = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="八十三、在C-调用C-内部函数">八十三、在C#调用C++内部函数</h2><h4 id="前言-23">前言</h4><ul><li><p>此节目的</p><ul><li><p>上一节实现了<strong>cpp调用c#函数</strong></p><p>这一节要实现<strong>C#调用cpp内部函数</strong>，这样才可以算得上脚本</p></li></ul></li></ul><h4 id="C-调用Cpp函数例子">C#调用Cpp函数例子</h4><ol><li>无返回值、无参数</li></ol><ul><li><p>C#</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">HEngine</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Main</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> FloatVar &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Main constructor!&quot;</span>);</span><br><span class="line">            CppFunction();<span class="comment">// 调用cpp的函数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明为内部调用：声明这个函数的定义在cpp内部被实现</span></span><br><span class="line">        [<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CppFunction</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">CppFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;来自cpp内部函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::InitMono</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 把C++的CppFunc绑定到c#的CppFunction</span></span><br><span class="line">    <span class="built_in">mono_add_internal_call</span>(<span class="string">&quot;HEngine.Main::CppFunction&quot;</span>, CppFunc);</span><br><span class="line">    <span class="comment">//&quot;.后面是类  ::后面是函数&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>带有参数</li></ol><ul><li><p>C#</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    NativeLog(<span class="string">&quot;Hello&quot;</span>, <span class="number">2025</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NativeLog</span>(<span class="params"><span class="built_in">string</span> text, <span class="built_in">int</span> parameter</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>C++</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">NativeLog</span><span class="params">(MonoString* string, <span class="type">int</span> parameter)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="type">char</span>* cStr = <span class="built_in">mono_string_to_utf8</span>(string);</span><br><span class="line">    <span class="function">std::string <span class="title">str</span><span class="params">(cStr)</span></span>;</span><br><span class="line">    <span class="built_in">mono_free</span>(cStr);</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; parameter &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mono_add_internal_call</span>(<span class="string">&quot;HEngine.Main::NativeLog&quot;</span>, NativeLog);</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>带有结构体参数</li></ol><ul><li><p>C#</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Vector3 vec1 = <span class="keyword">new</span> Vector3(<span class="number">5</span>, <span class="number">2.5f</span>, <span class="number">1</span>);</span><br><span class="line">    NativeLogVec3(<span class="keyword">ref</span> vec1, <span class="keyword">out</span> Vector3 vec2);</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;vec2.X&#125;</span>, <span class="subst">&#123;vec2.Y&#125;</span>, <span class="subst">&#123;vec2.Z&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NativeLogVec3</span>(<span class="params"><span class="keyword">ref</span> Vector3 vec, <span class="keyword">out</span> Vector3 vec2</span>)</span>;</span><br><span class="line">[<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br></pre></td></tr></table></figure></li><li><p>cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">NativeLogVec3</span><span class="params">(glm::vec3* vec, glm::vec3* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; vec-&gt;x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; vec-&gt;y &lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;vec-&gt;z &lt;&lt; std::endl;</span><br><span class="line">    *out = glm::<span class="built_in">cross</span>(*vec, glm::<span class="built_in">vec3</span>(vec-&gt;x, vec-&gt;y, -vec-&gt;z)); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mono_add_internal_call</span>(<span class="string">&quot;HEngine.Main::NativeLogVec3&quot;</span>, NativeLogVec3);</span><br></pre></td></tr></table></figure></li><li><p>注意Bug</p><p>由于结构体带有指针，需要<strong>申请内存</strong></p><ul><li><p>若在cpp函数内申请内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> glm::vec3* <span class="title">NativeLogVec3</span><span class="params">(glm::vec3* vec)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt;<span class="string">&quot;TestNativeLogVec3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    glm::vec3 result = glm::<span class="built_in">cross</span>(*vec, glm::<span class="built_in">vec3</span>(vec-&gt;x, vec-&gt;y, -vec-&gt;z));</span><br><span class="line">    <span class="comment">// 因为result是局部变量，函数结束后会被销毁result的内存，所以返回的内存是空的</span></span><br><span class="line">    <span class="keyword">return</span> &amp;result;</span><br><span class="line">    <span class="comment">// new出来的内存，是在cpp本地分配的，传给C#访问的地方也还是无效</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> glm::<span class="built_in">vec3</span>(result); <span class="comment">// 尝试new </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="封装抽象类">封装抽象类</h4><ul><li><p>ScriptEngine.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不引入头文件，必须外部声明，但这些都是在c文件定义的结构，所以需要extern&quot;C&quot;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MonoClass</span> MonoClass;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MonoObject</span> MonoObject;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_MonoMethod</span> MonoMethod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScriptEngine</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;<span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;<span class="comment">// 关闭</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">LoadAssembly</span><span class="params">(<span class="type">const</span> std::filesystem::path&amp; filepath)</span></span>;<span class="comment">// 2.加载dll程序集</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">InitMono</span><span class="params">()</span></span>;<span class="comment">// 1.初始化mono</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">ShutdownMono</span><span class="params">()</span></span>;<span class="comment">// 关闭mono</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> MonoObject* <span class="title">InstantiateClass</span><span class="params">(MonoClass* monoClass)</span></span>;<span class="comment">// 实例化Mono类为Mono实例对象</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ScriptClass</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScriptClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ScriptClass</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">ScriptClass</span>(<span class="type">const</span> std::string&amp; classNamespace, <span class="type">const</span> std::string&amp; className);<span class="comment">// 3. 创建一个MonoClass类</span></span><br><span class="line"></span><br><span class="line"><span class="function">MonoObject* <span class="title">Instantiate</span><span class="params">()</span></span>;<span class="comment">// 4.创建一个由MonoClass类构成的mono对象并且初始化</span></span><br><span class="line"><span class="function">MonoMethod* <span class="title">GetMethod</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> parameterCount)</span></span>;<span class="comment">// 5.1 获取类的函数</span></span><br><span class="line"><span class="function">MonoObject* <span class="title">InvokeMethod</span><span class="params">(MonoObject* instance, MonoMethod* method, <span class="type">void</span>** params = <span class="literal">nullptr</span>)</span></span>;<span class="comment">// 5.2 调用类的函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::string m_ClassNamespace;</span><br><span class="line">std::string m_ClassName;</span><br><span class="line">MonoClass* m_MonoClass = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ScriptGlue</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScriptGlue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">RegisterFunctions</span><span class="params">()</span></span>;<span class="comment">// 添加内部调用</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_ADD_INTERNAL_CALL(Name) mono_add_internal_call(<span class="string">&quot;HEngine.InternalCalls::&quot;</span> #Name, Name)</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">NativeLog</span><span class="params">(MonoString* string, <span class="type">int</span> parameter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span>* cStr = <span class="built_in">mono_string_to_utf8</span>(string);</span><br><span class="line">        <span class="function">std::string <span class="title">str</span><span class="params">(cStr)</span></span>;</span><br><span class="line">        <span class="built_in">mono_free</span>(cStr);</span><br><span class="line">        std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; parameter &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">NativeLog_Vector</span><span class="params">(glm::vec3* parameter, glm::vec3* outResult)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">HE_CORE_WARN</span>(<span class="string">&quot;Value: &#123;0&#125;&quot;</span>, *parameter);</span><br><span class="line">        *outResult = glm::<span class="built_in">normalize</span>(*parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">NativeLog_VectorDot</span><span class="params">(glm::vec3* parameter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">HE_CORE_WARN</span>(<span class="string">&quot;Value: &#123;0&#125;&quot;</span>, *parameter);</span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">dot</span>(*parameter, *parameter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ScriptGlue::RegisterFunctions</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">HE_ADD_INTERNAL_CALL</span>(NativeLog);</span><br><span class="line">        <span class="built_in">HE_ADD_INTERNAL_CALL</span>(NativeLog_Vector);</span><br><span class="line">        <span class="built_in">HE_ADD_INTERNAL_CALL</span>(NativeLog_VectorDot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="八十四、实现C-脚本控制实体">八十四、实现C#脚本控制实体</h2><h4 id="前言-24">前言</h4><ul><li><p>此节目的</p><p>为实现C#脚本WSAD能控制实体的位置变化</p></li></ul><h4 id="代码-18">代码</h4><ul><li><p>Entity.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">HEngine</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Entity</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">Entity</span>()</span> &#123; ID = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">internal</span> <span class="title">Entity</span>(<span class="params"><span class="built_in">ulong</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            ID = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">ulong</span> ID;</span><br><span class="line">        <span class="keyword">public</span> Vector3 Translation</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                InternalCalls.TransformComponent_GetTranslation(ID, <span class="keyword">out</span> Vector3 result);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                InternalCalls.TransformComponent_SetTranslation(ID, <span class="keyword">ref</span> <span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">HasComponent</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Component, <span class="keyword">new</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Type componentType = <span class="keyword">typeof</span>(T);</span><br><span class="line">            <span class="keyword">return</span> InternalCalls.Entity_HasComponent(ID, componentType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">GetComponent</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Component, <span class="keyword">new</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!HasComponent&lt;T&gt;())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            T component = <span class="keyword">new</span> T() &#123; Entity = <span class="keyword">this</span> &#125;;</span><br><span class="line">            <span class="keyword">return</span> component;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Player.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> Hazel;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Sandbox</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> : <span class="title">Entity</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Player</span>()</span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Player()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnCreate</span>()</span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;Player.OnCreate() - <span class="subst">&#123;ID&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">OnUpdate</span>(<span class="params"><span class="built_in">float</span> ts</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//Console.WriteLine($&quot;Player.OnUpdate() - &#123;ts&#125;&quot;);</span></span><br><span class="line">            <span class="built_in">float</span> speed = <span class="number">1.0f</span>;</span><br><span class="line">            Vector3 velocity = Vector3.Zero;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">            <span class="comment">// 内部调用函数，事件是否触发//</span></span><br><span class="line">            <span class="keyword">if</span> (Input.IsKeyDown(KeyCode.W))&#123;</span><br><span class="line">                velocity.Y = <span class="number">1.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Input.IsKeyDown(KeyCode.S))&#123;</span><br><span class="line">                velocity.Y = <span class="number">-1.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Input.IsKeyDown(KeyCode.A))&#123;</span><br><span class="line">                velocity.X = <span class="number">-1.0f</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Input.IsKeyDown(KeyCode.D))&#123;</span><br><span class="line">                velocity.X = <span class="number">1.0f</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;press the D key&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            velocity *= speed;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Translation get访问器 是调用C++的内部函数 获取 实体的位置</span></span><br><span class="line">            Vector3 translation = Translation; </span><br><span class="line">            translation += velocity * ts;</span><br><span class="line">            <span class="comment">// Translation set访问器 是调用C++的内部函数 设置 实体的位置</span></span><br><span class="line">            Translation = translation;          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C#声明调用C++内部函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">InternalCalls</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Entity_HasComponent</span>(<span class="params"><span class="built_in">ulong</span> entityID, Type componentType</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TransformComponent_GetTranslation</span>(<span class="params"><span class="built_in">ulong</span> entityID, <span class="keyword">out</span> Vector3 translation</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TransformComponent_SetTranslation</span>(<span class="params"><span class="built_in">ulong</span> entityID, <span class="keyword">ref</span> Vector3 translation</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Rigidbody2DComponent_ApplyLinearImpulse</span>(<span class="params"><span class="built_in">ulong</span> entityID, <span class="keyword">ref</span> Vector2 impulse, <span class="keyword">ref</span> Vector2 point, <span class="built_in">bool</span> wake</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Rigidbody2DComponent_ApplyLinearImpulseToCenter</span>(<span class="params"><span class="built_in">ulong</span> entityID, <span class="keyword">ref</span> Vector2 impulse, <span class="built_in">bool</span> wake</span>)</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">internal</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">Input_IsKeyDown</span>(<span class="params">KeyCode keycode</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的C++的内部函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TransformComponent_GetTranslation</span><span class="params">(UUID entityID, glm::vec3* outTranslation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line"></span><br><span class="line">    *outTranslation = entity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;().Translation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TransformComponent_SetTranslation</span><span class="params">(UUID entityID, glm::vec3* translation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line"></span><br><span class="line">    entity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;().Translation = *translation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Input_IsKeyDown</span><span class="params">(KeyCode keycode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Input::<span class="built_in">IsKeyPressed</span>(keycode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>C++调用C#的函数(C++项目的代码)</strong></p><ul><li><p>找到dll里所有继承Entity的类，表明这是<strong>脚本类</strong>，得到对应的封装的Mono类</p><p>并用<strong>脚本map</strong>存储所有<strong>封装的</strong>mono类（用封装的Mono类实例化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::LoadAssemblyClasses</span><span class="params">(MonoAssembly* assembly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_Data-&gt;EntityClasses.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    MonoImage* image = <span class="built_in">mono_assembly_get_image</span>(assembly);</span><br><span class="line">    <span class="type">const</span> MonoTableInfo* typeDefinitionsTable = <span class="built_in">mono_image_get_table_info</span>(image, MONO_TABLE_TYPEDEF);</span><br><span class="line">    <span class="type">int32_t</span> numTypes = <span class="built_in">mono_table_info_get_rows</span>(typeDefinitionsTable);</span><br><span class="line">    <span class="comment">// 1.加载Entity父类</span></span><br><span class="line">    MonoClass* entityClass = <span class="built_in">mono_class_from_name</span>(image, <span class="string">&quot;HEngine&quot;</span>, <span class="string">&quot;Entity&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; numTypes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> cols[MONO_TYPEDEF_SIZE];</span><br><span class="line">        <span class="built_in">mono_metadata_decode_row</span>(typeDefinitionsTable, i, cols, MONO_TYPEDEF_SIZE);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* nameSpace = <span class="built_in">mono_metadata_string_heap</span>(image, cols[MONO_TYPEDEF_NAMESPACE]);</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* name = <span class="built_in">mono_metadata_string_heap</span>(image, cols[MONO_TYPEDEF_NAME]);</span><br><span class="line">        std::string fullName;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strlen</span>(nameSpace) != <span class="number">0</span>) &#123;</span><br><span class="line">            fullName = fmt::format(<span class="string">&quot;&#123;&#125;.&#123;&#125;&quot;</span>, nameSpace, name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            fullName = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.加载Dll中所有C#类</span></span><br><span class="line">        MonoClass* monoClass = <span class="built_in">mono_class_from_name</span>(image, nameSpace, name);</span><br><span class="line">        <span class="keyword">if</span> (monoClass == entityClass) &#123;<span class="comment">// entity父类不保存</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断当前类是否为Entity的子类</span></span><br><span class="line">        <span class="type">bool</span> isEntity = <span class="built_in">mono_class_is_subclass_of</span>(monoClass, entityClass, <span class="literal">false</span>); <span class="comment">// 这个c#类是否为entity的子类</span></span><br><span class="line">        <span class="keyword">if</span> (isEntity) &#123;</span><br><span class="line">            <span class="comment">// 存入封装的Mono类对象</span></span><br><span class="line">            <span class="comment">// 3.1是就存入脚本map中</span></span><br><span class="line">            s_Data-&gt;EntityClasses[fullName] = <span class="built_in">CreateRef</span>&lt;ScriptClass&gt;(nameSpace, name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在运行场景开始前<strong>时</strong>，循环遍历当前所有<strong>具有脚本组件</strong>的实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::OnRuntimeStart</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">OnPhysics2DStart</span>();</span><br><span class="line">    &#123;<span class="comment">// 脚本</span></span><br><span class="line">        ScriptEngine::<span class="built_in">OnRuntimeStart</span>(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> view = m_Registry.<span class="built_in">view</span>&lt;ScriptComponent&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : view) &#123;</span><br><span class="line">            Entity entity = &#123; e, <span class="keyword">this</span> &#125;;</span><br><span class="line">            ScriptEngine::<span class="built_in">OnCreateEntity</span>(entity);<span class="comment">// 实例化实体拥有的C#脚本</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再调用C#类的OnCreate函数（初始化）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::OnCreateEntity</span><span class="params">(Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; sc = entity.<span class="built_in">GetComponent</span>&lt;ScriptComponent&gt;();<span class="comment">// 得到这个实体的组件</span></span><br><span class="line">    <span class="keyword">if</span> (ScriptEngine::<span class="built_in">EntityClassExists</span>(sc.ClassName)) &#123;<span class="comment">// 组件的脚本名称是否正确</span></span><br><span class="line">        Ref&lt;ScriptInstance&gt; instance = <span class="built_in">CreateRef</span>&lt;ScriptInstance&gt;(s_Data-&gt;EntityClasses[sc.ClassName], entity);<span class="comment">// 实例化类对象，并存储OnCreate、OnUpdate函数，调用父类Entity的构造函数，传入实体的UUID</span></span><br><span class="line">        s_Data-&gt;EntityInstances[entity.<span class="built_in">GetUUID</span>()] = instance;<span class="comment">// 运行脚本map存储这些ScriptInstance(类对象)</span></span><br><span class="line">        instance-&gt;<span class="built_in">InvokeOncreate</span>();<span class="comment">// 调用C#的OnCreate函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存储OnCreate、OnUpdate函数，并调用C#父类Entity的构造函数传入当前实体的<strong>UUID</strong>给C#</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ScriptInstance::<span class="built_in">ScriptInstance</span>(Ref&lt;ScriptClass&gt; scriptClass, Entity entity)</span><br><span class="line">:<span class="built_in">m_ScriptClass</span>(scriptClass)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取Sandbox Player类构成的MonoObject对象，相当于new Sandbox.Player()</span></span><br><span class="line">    m_Instance = scriptClass-&gt;<span class="built_in">Instantiate</span>();</span><br><span class="line"></span><br><span class="line">    m_Constructor = s_Data-&gt;EntityClass.<span class="built_in">GetMethod</span>(<span class="string">&quot;.ctor&quot;</span>, <span class="number">1</span>);<span class="comment">// 获取C#Entity类的构造函数</span></span><br><span class="line">    m_OnCreateMethod = scriptClass-&gt;<span class="built_in">GetMethod</span>(<span class="string">&quot;OnCreate&quot;</span>, <span class="number">0</span>);<span class="comment">// 获取并存储Sandbox.Player类的函数</span></span><br><span class="line">    m_OnUpdateMethod = scriptClass-&gt;<span class="built_in">GetMethod</span>(<span class="string">&quot;OnUpdate&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 调用C#Entity类的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">    UUID entityID = entity.<span class="built_in">GetUUID</span>();</span><br><span class="line">    <span class="type">void</span>* param = &amp;entityID;</span><br><span class="line">    m_ScriptClass-&gt;<span class="built_in">InvokeMethod</span>(m_Instance, m_Constructor, &amp;param);<span class="comment">// 第一个参数传入的是Entity子类(Player)构成的mono对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在运行场景的update函数，循环遍历当前所有<strong>具有脚本组件</strong>的实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::OnUpdateRuntime</span><span class="params">(Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 脚本</span></span><br><span class="line">    &#123;</span><br><span class="line">        ScriptEngine::<span class="built_in">OnRuntimeStart</span>(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 实例化实体中的C#脚本</span></span><br><span class="line">        <span class="keyword">auto</span> view = m_Registry.<span class="built_in">view</span>&lt;ScriptComponent&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e : view) &#123;</span><br><span class="line">            Entity entity = &#123; e, <span class="keyword">this</span> &#125;;</span><br><span class="line">            ScriptEngine::<span class="built_in">OnUpdateEntity</span>(entity, ts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据UUID在<strong>运行脚本map</strong>找到这个<strong>封装的</strong>mono类对象，并调用C#类的OnUpdate函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::OnUpdateEntity</span><span class="params">(Entity entity, Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UUID entityUUID = entity.<span class="built_in">GetUUID</span>();<span class="comment">// 得到这个实体的UUID</span></span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(s_Data-&gt;EntityInstances.<span class="built_in">find</span>(entityUUID) != s_Data-&gt;EntityInstances.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据UUID获取到ScriptInstance的指针</span></span><br><span class="line">    Ref&lt;ScriptInstance&gt; instance = s_Data-&gt;EntityInstances[entityUUID];</span><br><span class="line">    instance-&gt;<span class="built_in">InvokeOnUpdate</span>((<span class="type">float</span>)ts);<span class="comment">// 调用C#的OnUpdate函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="八十五、C-获取实体的组件">八十五、C#获取实体的组件</h2><h4 id="前言-25">前言</h4><ul><li>此节目的<ol><li>由上节根据UUID获取实体的translation在根据wsad调<strong>整实体的位置</strong></li><li>此节优化上节所做，实体的translation应属于实体的TransformComponent，所以此节需要在C#<strong>创建组件类</strong></li><li>用UUID，C#组件类<strong>对应</strong>cpp的组件类。</li></ol></li></ul><h4 id="代码-19">代码</h4><ul><li><p>Component.cs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> abstract <span class="keyword">class</span> <span class="title class_">Component</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Entity Entity &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransformComponent</span> : Component &#123; </span><br><span class="line">    <span class="keyword">public</span> Vector3 Translation&#123;</span><br><span class="line">        get&#123;</span><br><span class="line">            InternalCalls.<span class="built_in">TransformComponent_GetTranslation</span>(Entity.ID, out Vector3 translation);</span><br><span class="line">            <span class="keyword">return</span> translation;</span><br><span class="line">        &#125;</span><br><span class="line">        set&#123;</span><br><span class="line">            InternalCalls.<span class="built_in">TransformComponent_SetTranslation</span>(Entity.ID, ref value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rigidbody2DComponent</span> : Component&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">ApplyLinearImpulse</span><span class="params">(Vector2 impulse, Vector2 worldPosition, <span class="type">bool</span> wake)</span></span>&#123;</span><br><span class="line">        InternalCalls.<span class="built_in">Rigidbody2DComponent_ApplyLinearImpulse</span>(Entity.ID, ref impulse, ref worldPosition, wake); ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">ApplyLinearImpulse</span><span class="params">(Vector2 impulse, <span class="type">bool</span> wake)</span></span>&#123;</span><br><span class="line">        InternalCalls.<span class="built_in">Rigidbody2DComponent_ApplyLinearImpulseToCenter</span>(Entity.ID, ref impulse, wake); ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ScriptGlue.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Component&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">RegisterComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ([]()</span><br><span class="line">        &#123;</span><br><span class="line">            std::string_view typeName = <span class="built_in">typeid</span>(Component).<span class="built_in">name</span>();</span><br><span class="line">            <span class="type">size_t</span> pos = typeName.<span class="built_in">find_last_of</span>(<span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">            std::string_view structName = typeName.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line">            std::string managedTypename = fmt::format(<span class="string">&quot;HEngine.&#123;&#125;&quot;</span>, structName);</span><br><span class="line"></span><br><span class="line">            MonoType* managedType = <span class="built_in">mono_reflection_type_from_name</span>(managedTypename.<span class="built_in">data</span>(), ScriptEngine::<span class="built_in">GetCoreAssemblyImage</span>());</span><br><span class="line">            <span class="keyword">if</span> (!managedType)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">HE_CORE_ERROR</span>(<span class="string">&quot;Could not find component type &#123;&#125;&quot;</span>, managedTypename);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s_EntityHasComponentFuncs[managedType] = [](Entity entity) &#123; <span class="keyword">return</span> entity.<span class="built_in">HasComponent</span>&lt;Component&gt;(); &#125;;</span><br><span class="line">        &#125;(), ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Component&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">RegisterComponent</span><span class="params">(ComponentGroup&lt;Component...&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RegisterComponent</span>&lt;Component...&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptGlue::RegisterComponents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">RegisterComponent</span>(AllComponents&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Entity.cs</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Player.OnCreate() - <span class="subst">&#123;ID&#125;</span>&quot;</span>);</span><br><span class="line">    m_Transform = GetComponent&lt;TransformComponent&gt;();</span><br><span class="line">    m_Rigidbody = GetComponent&lt;Rigidbody2DComponent&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">GetComponent</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Component, <span class="keyword">new</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!HasComponent&lt;T&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T component = <span class="keyword">new</span> T() &#123; Entity = <span class="keyword">this</span> &#125;;<span class="comment">// 返回本地类实例对象</span></span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">HasComponent</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Component, <span class="keyword">new</span>()<span class="comment">// new()是确保有空构造函数&#123;</span></span></span><br><span class="line"><span class="function">    Type componentType</span> = <span class="keyword">typeof</span>(T);<span class="comment">// 得到命名空间.类名名称，比如Sandbox.Player</span></span><br><span class="line">    <span class="keyword">return</span> InternalCalls.Entity_HasComponent(ID, componentType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScriptGlue.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">Entity_HasComponent</span><span class="params">(UUID entityID, MonoReflectionType* componentType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line"></span><br><span class="line">    MonoType* managedType = <span class="built_in">mono_reflection_type_get_type</span>(componentType);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(s_EntityHasComponentFuncs.<span class="built_in">find</span>(managedType) != s_EntityHasComponentFuncs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> s_EntityHasComponentFuncs.<span class="built_in">at</span>(managedType)(entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若实体存在对应组件，就<strong>返回C#本地组件类的实例化</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">GetComponent</span>&lt;<span class="title">T</span>&gt;() <span class="keyword">where</span> T : Component, <span class="keyword">new</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!HasComponent&lt;T&gt;())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T component = <span class="keyword">new</span> T() &#123; Entity = <span class="keyword">this</span> &#125;;<span class="comment">// 返回本地类实例对象</span></span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C#在相关脚本类的OnUpdate函数对*“获取到的组件”*的属性修改或者函数调用</p><p>实际上都是根据传入UUID，调用<strong>C++内部函数</strong>来实现</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C<span class="meta">#</span></span><br><span class="line">m_Rigidbody.ApplyLinearImpulse(velocity.XY, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Rigidbody2DComponent_ApplyLinearImpulse</span>(<span class="params"><span class="built_in">ulong</span> entityID, <span class="keyword">ref</span> Vector2 impulse, <span class="keyword">ref</span> Vector2 point, <span class="built_in">bool</span> wake</span>)</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">MethodImplAttribute(MethodImplOptions.InternalCall)</span>]</span><br><span class="line"><span class="function"><span class="keyword">internal</span> <span class="keyword">extern</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Rigidbody2DComponent_ApplyLinearImpulseToCenter</span>(<span class="params"><span class="built_in">ulong</span> entityID, <span class="keyword">ref</span> Vector2 impulse, <span class="built_in">bool</span> wake</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cpp</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Rigidbody2DComponent_ApplyLinearImpulse</span><span class="params">(UUID entityID, glm::vec2* impulse, glm::vec2* point, <span class="type">bool</span> wake)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; rb2d = entity.<span class="built_in">GetComponent</span>&lt;Rigidbody2DComponent&gt;();</span><br><span class="line">    b2BodyId bodyid = rb2d.RuntimeBodyId;</span><br><span class="line">    <span class="built_in">b2Body_ApplyLinearImpulse</span>(bodyid, b2Vec2&#123; impulse-&gt;x, impulse-&gt;y &#125;, b2Vec2&#123; point-&gt;x, point-&gt;y &#125;, wake);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Rigidbody2DComponent_ApplyLinearImpulseToCenter</span><span class="params">(UUID entityID, glm::vec2* impulse, <span class="type">bool</span> wake)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; rb2d = entity.<span class="built_in">GetComponent</span>&lt;Rigidbody2DComponent&gt;();</span><br><span class="line">    b2BodyId bodyid = rb2d.RuntimeBodyId;</span><br><span class="line">    <span class="built_in">b2Body_ApplyLinearImpulseToCenter</span>(bodyid, b2Vec2&#123; impulse-&gt;x, impulse-&gt;y &#125;, wake);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="八十六、实现面板操控C-变量">八十六、实现面板操控C#变量</h2><h4 id="前言-26">前言</h4><ul><li><p>此节目的</p><p>为完成在编辑器面板上可以显示C#脚本类的属性，对属性的值修改，C#脚本会<strong>热更新</strong>（mono4.5api支持）</p></li></ul><h4 id="关键代码-3">关键代码</h4><p>mono的API</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有属性</span></span><br><span class="line"><span class="built_in">mono_class_get_fields</span>()</span><br><span class="line"><span class="comment">// 得到单个属性</span></span><br><span class="line">MonoClassField* field = <span class="built_in">mono_class_get_fields</span>(monoClass, &amp;iterator)</span><br><span class="line"><span class="comment">// 获取单个属性的名称</span></span><br><span class="line"><span class="built_in">mono_field_get_name</span>(field)</span><br><span class="line"><span class="comment">// 获取单个属性的权限</span></span><br><span class="line"><span class="built_in">mono_field_get_flags</span>(field)</span><br><span class="line"><span class="comment">// 获取单个属性的类类型</span></span><br><span class="line"><span class="built_in">mono_field_get_type</span>(field)    </span><br><span class="line"><span class="comment">// 设置和获取属性值</span></span><br><span class="line"><span class="built_in">mono_field_get_value</span>(m_Instance, field.ClassField, buffer);</span><br><span class="line"><span class="built_in">mono_field_set_value</span>(m_Instance, field.ClassField, (<span class="type">void</span>*)value);</span><br></pre></td></tr></table></figure><h4 id="代码思路">代码思路</h4><ul><li><p>一个C#脚本对应一个ScriptClass类，ScriptClass类中有**map（fieldmap）**保存这个C#脚本的属性与值类型。</p><ul><li>在加载dll后，读取游戏脚本库的类名，加载C#类得到<strong>封装的MonoClass对象</strong></li><li>再根据MonoClass（反射）得到C#类的所有<strong>属性</strong></li><li>循环属性，得到单个MonoClassField对象，根据MonoClassField（反射）得到C#属性的名称、访问权限、类型</li><li>根据权限决定<strong>map</strong>是否存储这个属性</li></ul><p>ScriptEngine</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">ScriptFieldType</span></span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Float, Double,</span><br><span class="line">    Bool, Char, Byte, Short, Int, Long,</span><br><span class="line">    UByte, UShort, UInt, ULong,</span><br><span class="line">    Vector2, Vector3, Vector4,</span><br><span class="line">    Entity</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 属性名称对应的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ScriptField</span> &#123;</span><br><span class="line">    ScriptFieldType Type;</span><br><span class="line">    std::string Name;</span><br><span class="line"></span><br><span class="line">    MonoClassField* ClassField;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScriptClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> std::map&lt;std::string, ScriptField&gt;&amp; <span class="title">GetFields</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Fields; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, ScriptField&gt; m_Fields; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">ScriptEngine</span>;</span><br><span class="line">&#125;;</span><br><span class="line">------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::LoadAssemblyClasses</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; numTypes; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        .....</span><br><span class="line">        MonoClass* monoClass = <span class="built_in">mono_class_from_name</span>(s_Data-&gt;AppAssemblyImage, nameSpace, className);</span><br><span class="line">.....</span><br><span class="line">        <span class="comment">// 读取脚本类的属性</span></span><br><span class="line">        <span class="type">int</span> fieldCount = <span class="built_in">mono_class_num_fields</span>(monoClass);</span><br><span class="line">        <span class="built_in">HE_CORE_WARN</span>(<span class="string">&quot;&#123;&#125; has &#123;&#125; fields:&quot;</span>, className, fieldCount);</span><br><span class="line">        <span class="type">void</span>* iterator = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 获取所有属性，并得到单个属性</span></span><br><span class="line">        <span class="keyword">while</span> (MonoClassField* field = <span class="built_in">mono_class_get_fields</span>(monoClass, &amp;iterator))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* filedName = <span class="built_in">mono_field_get_name</span>(field);<span class="comment">// 获取单个属性的名称</span></span><br><span class="line">            <span class="type">uint32_t</span> flags = <span class="built_in">mono_field_get_flags</span>(field);<span class="comment">// 获取单个属性的权限</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; FIELD_ATTRIBUTE_PUBLIC) &#123; <span class="comment">//类型是Public的话</span></span><br><span class="line">                MonoType* type = <span class="built_in">mono_field_get_type</span>(field);<span class="comment">// 获取单个属性的类类型</span></span><br><span class="line">                ScriptFieldType fieldType = Utils::<span class="built_in">MonoTypeToScriptFieldType</span>(type);</span><br><span class="line">                <span class="built_in">HE_CORE_TRACE</span>(<span class="string">&quot;&#123;&#125;(&#123;&#125;)&quot;</span>, filedName,Utils::<span class="built_in">ScriptFieldTypeToStirng</span>(fieldType));</span><br><span class="line">                <span class="comment">// 用Map存储这个属性</span></span><br><span class="line">                scriptClass-&gt;m_Fields[filedName] = &#123; fieldType, filedName, field &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>运行游戏时，在编辑面板可以用通过这<strong>fieldmap</strong>获取当前C#脚本的所有属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实体的脚本组件 mutable去除常量属性</span></span><br><span class="line"><span class="built_in">DrawComponent</span>&lt;ScriptComponent&gt;(<span class="string">&quot;Script&quot;</span>, entity, [entity](<span class="keyword">auto</span>&amp; component)<span class="keyword">mutable</span></span><br><span class="line">&#123;</span><br><span class="line">Ref&lt;ScriptInstance&gt; scriptInstance = ScriptEngine::<span class="built_in">GetEntityScriptInstance</span>(entity.<span class="built_in">GetUUID</span>());</span><br><span class="line"><span class="keyword">if</span> (scriptInstance) &#123;</span><br><span class="line">        <span class="comment">// 读取map中的属性</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; fields = scriptInstance-&gt;<span class="built_in">GetScriptClass</span>()-&gt;<span class="built_in">GetFields</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [name, field] : fields)<span class="comment">// 获取保存的属性名称</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (field.Type == ScriptFieldType::Float) &#123;</span><br><span class="line"><span class="type">float</span> data = scriptInstance-&gt;<span class="built_in">GetFieldValue</span>&lt;<span class="type">float</span>&gt;(name);<span class="comment">// 下一步有函数定义：获取属性值</span></span><br><span class="line"><span class="keyword">if</span> (ImGui::<span class="built_in">DragFloat</span>(name.<span class="built_in">c_str</span>(), &amp;data)) &#123;</span><br><span class="line">scriptInstance-&gt;<span class="built_in">SetFieldValue</span>(name, data);<span class="comment">// 下一步有函数定义：设置属性值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>得到了对应属性的名称，在可以用Mono的API来<strong>获取</strong>和<strong>设置</strong>这个属性的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">GetFieldValue</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> success = <span class="built_in">GetFieldValueInternal</span>(name, s_FieldValueBuffer);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">T</span>();</span><br><span class="line">    <span class="keyword">return</span> *(T*)s_FieldValueBuffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ScriptInstance::GetFieldValueInternal</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">void</span>* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; fields = m_ScriptClass-&gt;<span class="built_in">GetFields</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = fields.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (it == fields.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> ScriptField&amp; field = it-&gt;second;</span><br><span class="line">    <span class="comment">// mono的API</span></span><br><span class="line">    <span class="built_in">mono_field_get_value</span>(m_Instance, field.ClassField, buffer); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetFieldValue</span><span class="params">(<span class="type">const</span> std::string&amp; name,  T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">SetFieldValueInternal</span>(name, &amp;value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ScriptInstance::SetFieldValueInternal</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">void</span>* value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; fields = m_ScriptClass-&gt;<span class="built_in">GetFields</span>();</span><br><span class="line">    <span class="keyword">auto</span> it = fields.<span class="built_in">find</span>(name);</span><br><span class="line">    <span class="keyword">if</span> (it == fields.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> ScriptField&amp; field = it-&gt;second;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">mono_field_set_value</span>(m_Instance, field.ClassField, (<span class="type">void</span>*)value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="八十七、添加C-脚本修改重载">八十七、添加C#脚本修改重载</h2><h4 id="前言-27">前言</h4><ul><li><p>此节目的</p><p>实现在运行时按Ctrl+R重新加载核心程序集和应用程序集达到更新脚本部分更改的效果</p></li></ul><p>ScriptEngine.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ScriptEngineData</span></span><br><span class="line">&#123;</span><br><span class="line">    std::filesystem::path CoreAssemblyFilepath;</span><br><span class="line">    std::filesystem::path AppAssemblyFilepath;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::ShutdownMono</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mono_domain_set</span>(<span class="built_in">mono_get_root_domain</span>(), <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">mono_domain_unload</span>(s_Data-&gt;AppDomain);</span><br><span class="line">    s_Data-&gt;AppDomain = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">mono_jit_cleanup</span>(s_Data-&gt;RootDomain);</span><br><span class="line">    s_Data-&gt;RootDomain = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::LoadAssembly</span><span class="params">(<span class="type">const</span> std::filesystem::path&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个新的 AppDomain</span></span><br><span class="line">    s_Data-&gt;AppDomain = <span class="built_in">mono_domain_create_appdomain</span>(<span class="string">&quot;HEngineScriptRuntime&quot;</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">mono_domain_set</span>(s_Data-&gt;AppDomain, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录程序集路径</span></span><br><span class="line">    s_Data-&gt;CoreAssemblyFilepath = filepath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载程序集</span></span><br><span class="line">    s_Data-&gt;CoreAssembly = Utils::<span class="built_in">LoadMonoAssembly</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取程序集的 Image（用于后续的类、方法查找）</span></span><br><span class="line">    s_Data-&gt;CoreAssemblyImage = <span class="built_in">mono_assembly_get_image</span>(s_Data-&gt;CoreAssembly);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::ReloadAssembly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 切换回 Mono 的 Root Domain（根域不能卸载）</span></span><br><span class="line">    <span class="built_in">mono_domain_set</span>(<span class="built_in">mono_get_root_domain</span>(), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载当前 AppDomain</span></span><br><span class="line">    <span class="built_in">mono_domain_unload</span>(s_Data-&gt;AppDomain);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新加载核心程序集和应用程序集</span></span><br><span class="line">    <span class="built_in">LoadAssembly</span>(s_Data-&gt;CoreAssemblyFilepath);</span><br><span class="line">    <span class="built_in">LoadAppAssembly</span>(s_Data-&gt;AppAssemblyFilepath);</span><br><span class="line">    <span class="built_in">LoadAssemblyClasses</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册 C# 组件到 C++ 侧</span></span><br><span class="line">    ScriptGlue::<span class="built_in">RegisterComponents</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新实例化 Entity 类</span></span><br><span class="line">    s_Data-&gt;EntityClass = <span class="built_in">ScriptClass</span>(<span class="string">&quot;HEngine&quot;</span>, <span class="string">&quot;Entity&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::LoadAppAssembly</span><span class="params">(<span class="type">const</span> std::filesystem::path&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录应用程序集的路径</span></span><br><span class="line">    s_Data-&gt;AppAssemblyFilepath = filepath;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载应用程序集</span></span><br><span class="line">    s_Data-&gt;AppAssembly = Utils::<span class="built_in">LoadMonoAssembly</span>(filepath);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取程序集的 Image（用于查找类、方法）</span></span><br><span class="line">    s_Data-&gt;AppAssemblyImage = <span class="built_in">mono_assembly_get_image</span>(s_Data-&gt;AppAssembly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EditorLayer.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">BeginMenu</span>(<span class="string">&quot;Script&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Reload assembly&quot;</span>, <span class="string">&quot;Ctrl+R&quot;</span>))</span><br><span class="line">            ScriptEngine::<span class="built_in">ReloadAssembly</span>();</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">EndMenu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> Key::R:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (control)</span><br><span class="line">    &#123;</span><br><span class="line">        ScriptEngine::<span class="built_in">ReloadAssembly</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ImGuizmo::<span class="built_in">IsUsing</span>())</span><br><span class="line">            m_GizmoType = ImGuizmo::OPERATION::SCALE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="八十八、脚本修改自动热重载">八十八、脚本修改自动热重载</h2><h4 id="前言-28">前言</h4><ul><li><p>此节目的</p><p>实现自动检测文件的更改，一旦更改自动热重载C#dll</p></li></ul><p>ScriptEngine.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ScriptEngineData</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//文件监听器，监视 C# DLL 文件的变更。</span></span><br><span class="line">    Scope&lt;filewatch::FileWatch&lt;std::string&gt;&gt; AppAssemblyFileWatcher;</span><br><span class="line">    <span class="comment">//是否等待热重载，防止重复触发。</span></span><br><span class="line">    <span class="type">bool</span> AssemblyReloadPending = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">OnAppAssemblyFileSystemEvent</span><span class="params">(<span class="type">const</span> std::string&amp; path, <span class="type">const</span> filewatch::Event change_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经等待热重载，或者变更类型不是 &quot;修改&quot;，就不处理</span></span><br><span class="line">    <span class="keyword">if</span> (!s_Data-&gt;AssemblyReloadPending &amp;&amp; change_type == filewatch::Event::modified)</span><br><span class="line">    &#123;</span><br><span class="line">        s_Data-&gt;AssemblyReloadPending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 ReloadAssembly() 提交到主线程执行</span></span><br><span class="line">        Application::<span class="built_in">Get</span>().<span class="built_in">SubmitToMainThread</span>([]()</span><br><span class="line">        &#123;</span><br><span class="line">            s_Data-&gt;AppAssemblyFileWatcher.<span class="built_in">reset</span>();  <span class="comment">// 停止文件监听</span></span><br><span class="line">            ScriptEngine::<span class="built_in">ReloadAssembly</span>();         <span class="comment">// 重新加载 C# 脚本 DLL</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ScriptEngine::LoadAppAssembly</span><span class="params">(<span class="type">const</span> std::filesystem::path&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 监听 C# 应用程序集的变化，触发 OnAppAssemblyFileSystemEvent</span></span><br><span class="line">    s_Data-&gt;AppAssemblyFileWatcher = CreateScope&lt;filewatch::FileWatch&lt;std::string&gt;&gt;(filepath.<span class="built_in">string</span>(), OnAppAssemblyFileSystemEvent);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置不等待重载</span></span><br><span class="line">    s_Data-&gt;AssemblyReloadPending = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Application.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::SubmitToMainThread</span><span class="params">(<span class="type">const</span> std::function&lt;<span class="type">void</span>()&gt;&amp; function)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_MainThreadQueueMutex)</span></span>; <span class="comment">// 加锁，防止多线程竞争</span></span><br><span class="line">    m_MainThreadQueue.<span class="built_in">emplace_back</span>(function); <span class="comment">// 将任务添加到队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::ExecuteMainThreadQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::scoped_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_MainThreadQueueMutex)</span></span>; <span class="comment">// 线程安全</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; func : m_MainThreadQueue) </span><br><span class="line">        <span class="built_in">func</span>(); <span class="comment">// 执行队列中的每个任务</span></span><br><span class="line">    m_MainThreadQueue.<span class="built_in">clear</span>(); <span class="comment">// 清空任务队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="八十九、添加渲染Text功能">八十九、添加渲染Text功能</h2><h4 id="前言-29">前言</h4><ul><li><p>此节目的</p><p>添加Renderer2D_Text着色器，提供渲染文本功能</p><p>Renderer2D.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TextVertex</span></span><br><span class="line">&#123;</span><br><span class="line">    glm::vec3 Position;</span><br><span class="line">    glm::vec4 Color;</span><br><span class="line">    glm::vec2 TexCoord;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> bg color for outline/bg</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Editor-only</span></span><br><span class="line">    <span class="type">int</span> EntityID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Renderer2DData</span></span><br><span class="line">&#123;</span><br><span class="line">    Ref&lt;VertexArray&gt; TextVertexArray;</span><br><span class="line">    Ref&lt;VertexBuffer&gt; TextVertexBuffer;</span><br><span class="line">    Ref&lt;Shader&gt; TextShader;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> TextIndexCount = <span class="number">0</span>;</span><br><span class="line">    TextVertex* TextVertexBufferBase = <span class="literal">nullptr</span>;</span><br><span class="line">    TextVertex* TextVertexBufferPtr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Ref&lt;Texture2D&gt; FontAtlasTexture;</span><br><span class="line">    glm::vec4 QuadVertexPositions[<span class="number">4</span>]&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">            <span class="comment">// Text</span></span><br><span class="line">    s_Data.TextVertexArray = VertexArray::<span class="built_in">Create</span>();</span><br><span class="line"></span><br><span class="line">    s_Data.TextVertexBuffer = VertexBuffer::<span class="built_in">Create</span>(s_Data.MaxVertices * <span class="built_in">sizeof</span>(TextVertex));</span><br><span class="line">    s_Data.TextVertexBuffer-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">        &#123; ShaderDataType::Float3,<span class="string">&quot;a_Position&quot;</span>     &#125;,</span><br><span class="line">        &#123; ShaderDataType::Float4,<span class="string">&quot;a_Color&quot;</span>        &#125;,</span><br><span class="line">        &#123; ShaderDataType::Float2,<span class="string">&quot;a_TexCoord&quot;</span>     &#125;,</span><br><span class="line">        &#123; ShaderDataType::Int,<span class="string">&quot;a_EntityID&quot;</span>     &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    s_Data.TextVertexArray-&gt;<span class="built_in">AddVertexBuffer</span>(s_Data.TextVertexBuffer);</span><br><span class="line">    s_Data.TextVertexArray-&gt;<span class="built_in">SetIndexBuffer</span>(quadIB);</span><br><span class="line">    s_Data.TextVertexBufferBase = <span class="keyword">new</span> TextVertex[s_Data.MaxVertices];</span><br><span class="line"></span><br><span class="line">            s_Data.TextShader = Shader::<span class="built_in">Create</span>(<span class="string">&quot;assets/shaders/Renderer2D_Text.glsl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::Flush</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s_Data.TextIndexCount)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> dataSize = (<span class="type">uint32_t</span>)((<span class="type">uint8_t</span>*)s_Data.TextVertexBufferPtr - (<span class="type">uint8_t</span>*)s_Data.TextVertexBufferBase);</span><br><span class="line">        s_Data.TextVertexBuffer-&gt;<span class="built_in">SetData</span>(s_Data.TextVertexBufferBase, dataSize);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> buf = s_Data.TextVertexBufferBase;</span><br><span class="line">        s_Data.FontAtlasTexture-&gt;<span class="built_in">Bind</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        s_Data.TextShader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        RenderCommand::<span class="built_in">DrawIndexed</span>(s_Data.TextVertexArray, s_Data.TextIndexCount);</span><br><span class="line">        s_Data.Stats.DrawCalls++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawString</span><span class="params">(<span class="type">const</span> std::string&amp; string, Ref&lt;Font&gt; font, <span class="type">const</span> glm::mat4&amp; transform, <span class="type">const</span> glm::vec4&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; fontGeometry = font-&gt;<span class="built_in">GetMSDFData</span>()-&gt;FontGeometry;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; metrics = fontGeometry.<span class="built_in">getMetrics</span>();</span><br><span class="line">    Ref&lt;Texture2D&gt; fontAtlas = font-&gt;<span class="built_in">GetAtlasTexture</span>();</span><br><span class="line"></span><br><span class="line">    s_Data.FontAtlasTexture = fontAtlas;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> x = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">double</span> fsScale = <span class="number">1.0</span> / (metrics.ascenderY - metrics.descenderY);</span><br><span class="line">    <span class="type">double</span> y = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> lineHeightOffset = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; string.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> character = string[i];</span><br><span class="line">        <span class="keyword">if</span> (character == <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (character == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">            y -= fsScale * metrics.lineHeight + lineHeightOffset;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> glyph = fontGeometry.<span class="built_in">getGlyph</span>(character);</span><br><span class="line">        <span class="keyword">if</span> (!glyph)</span><br><span class="line">            glyph = fontGeometry.<span class="built_in">getGlyph</span>(<span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!glyph)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (character == <span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">            glyph = fontGeometry.<span class="built_in">getGlyph</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> al, ab, ar, at;</span><br><span class="line">        glyph-&gt;<span class="built_in">getQuadAtlasBounds</span>(al, ab, ar, at);</span><br><span class="line">        <span class="function">glm::vec2 <span class="title">texCoordMin</span><span class="params">((<span class="type">float</span>)al, (<span class="type">float</span>)ab)</span></span>;</span><br><span class="line">        <span class="function">glm::vec2 <span class="title">texCoordMax</span><span class="params">((<span class="type">float</span>)ar, (<span class="type">float</span>)at)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> pl, pb, pr, pt;</span><br><span class="line">        glyph-&gt;<span class="built_in">getQuadPlaneBounds</span>(pl, pb, pr, pt);</span><br><span class="line">        <span class="function">glm::vec2 <span class="title">quadMin</span><span class="params">((<span class="type">float</span>)pl, (<span class="type">float</span>)pb)</span></span>;</span><br><span class="line">        <span class="function">glm::vec2 <span class="title">quadMax</span><span class="params">((<span class="type">float</span>)pr, (<span class="type">float</span>)pt)</span></span>;</span><br><span class="line"></span><br><span class="line">        quadMin *= fsScale, quadMax *= fsScale;</span><br><span class="line">        quadMin += glm::<span class="built_in">vec2</span>(x, y);</span><br><span class="line">        quadMax += glm::<span class="built_in">vec2</span>(x, y);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> texelWidth = <span class="number">1.0f</span> / fontAtlas-&gt;<span class="built_in">GetWidth</span>();</span><br><span class="line">        <span class="type">float</span> texelHeight = <span class="number">1.0f</span> / fontAtlas-&gt;<span class="built_in">GetHeight</span>();</span><br><span class="line">        texCoordMin *= glm::<span class="built_in">vec2</span>(texelWidth, texelHeight);</span><br><span class="line">        texCoordMax *= glm::<span class="built_in">vec2</span>(texelWidth, texelHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// render here</span></span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;Position = transform * glm::<span class="built_in">vec4</span>(quadMin, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;Color = color;</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;TexCoord = texCoordMin;</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;EntityID = <span class="number">0</span>; <span class="comment">// TODO</span></span><br><span class="line">        s_Data.TextVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;Position = transform * glm::<span class="built_in">vec4</span>(quadMin.x, quadMax.y, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;Color = color;</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;TexCoord = &#123; texCoordMin.x, texCoordMax.y &#125;;</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;EntityID = <span class="number">0</span>; <span class="comment">// TODO</span></span><br><span class="line">        s_Data.TextVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;Position = transform * glm::<span class="built_in">vec4</span>(quadMax, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;Color = color;</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;TexCoord = texCoordMax;</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;EntityID = <span class="number">0</span>; <span class="comment">// TODO</span></span><br><span class="line">        s_Data.TextVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;Position = transform * glm::<span class="built_in">vec4</span>(quadMax.x, quadMin.y, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;Color = color;</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;TexCoord = &#123; texCoordMax.x, texCoordMin.y &#125;;</span><br><span class="line">        s_Data.TextVertexBufferPtr-&gt;EntityID = <span class="number">0</span>; <span class="comment">// TODO</span></span><br><span class="line">        s_Data.TextVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">        s_Data.TextIndexCount += <span class="number">6</span>;</span><br><span class="line">        s_Data.Stats.QuadCount++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &lt; string.<span class="built_in">size</span>() - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">double</span> advance = glyph-&gt;<span class="built_in">getAdvance</span>();</span><br><span class="line">            <span class="type">char</span> nextCharacter = string[i + <span class="number">1</span>];</span><br><span class="line">            fontGeometry.<span class="built_in">getAdvance</span>(advance, character, nextCharacter);</span><br><span class="line"></span><br><span class="line">            <span class="type">float</span> kerningOffset = <span class="number">0.0f</span>;</span><br><span class="line">            x += fsScale * advance + kerningOffset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Components.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TextComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string TextString;</span><br><span class="line">    Ref&lt;Font&gt; FontAsset = Font::<span class="built_in">GetDefault</span>();</span><br><span class="line">    glm::vec4 Color&#123; <span class="number">1.0f</span> &#125;;</span><br><span class="line">    <span class="type">float</span> Kerning = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">float</span> LineSpacing = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Scene.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Renderer2D::<span class="built_in">DrawString</span>(<span class="string">&quot;DongHui&quot;</span>, Font::<span class="built_in">GetDefault</span>(), glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="九十、-脚本绑定Text相关">九十、 脚本绑定Text相关</h2><h4 id="前言-30">前言</h4><ul><li><p>此节目的</p><p>绑定Text组件相关函数到C#,以供脚本实现文本功能</p><p>ScriptEngine.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MonoString* <span class="title">ScriptEngine::CreateString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* string)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mono_string_new</span>(s_Data-&gt;AppDomain, string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScriptGlue.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Utils</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::string <span class="title">MonoStringToString</span><span class="params">(MonoString* string)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span>* cStr = <span class="built_in">mono_string_to_utf8</span>(string);</span><br><span class="line">        <span class="function">std::string <span class="title">str</span><span class="params">(cStr)</span></span>;</span><br><span class="line">        <span class="built_in">mono_free</span>(cStr);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> MonoString* <span class="title">TextComponent_GetText</span><span class="params">(UUID entityID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity.<span class="built_in">HasComponent</span>&lt;TextComponent&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; tc = entity.<span class="built_in">GetComponent</span>&lt;TextComponent&gt;();</span><br><span class="line">    <span class="keyword">return</span> ScriptEngine::<span class="built_in">CreateString</span>(tc.TextString.<span class="built_in">c_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TextComponent_SetText</span><span class="params">(UUID entityID, MonoString* textString)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity.<span class="built_in">HasComponent</span>&lt;TextComponent&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; tc = entity.<span class="built_in">GetComponent</span>&lt;TextComponent&gt;();</span><br><span class="line">    tc.TextString = Utils::<span class="built_in">MonoStringToString</span>(textString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TextComponent_GetColor</span><span class="params">(UUID entityID, glm::vec4* color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity.<span class="built_in">HasComponent</span>&lt;TextComponent&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; tc = entity.<span class="built_in">GetComponent</span>&lt;TextComponent&gt;();</span><br><span class="line">    *color = tc.Color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TextComponent_SetColor</span><span class="params">(UUID entityID, glm::vec4* color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity.<span class="built_in">HasComponent</span>&lt;TextComponent&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; tc = entity.<span class="built_in">GetComponent</span>&lt;TextComponent&gt;();</span><br><span class="line">    tc.Color = *color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">TextComponent_GetKerning</span><span class="params">(UUID entityID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity.<span class="built_in">HasComponent</span>&lt;TextComponent&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; tc = entity.<span class="built_in">GetComponent</span>&lt;TextComponent&gt;();</span><br><span class="line">    <span class="keyword">return</span> tc.Kerning;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TextComponent_SetKerning</span><span class="params">(UUID entityID, <span class="type">float</span> kerning)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity.<span class="built_in">HasComponent</span>&lt;TextComponent&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; tc = entity.<span class="built_in">GetComponent</span>&lt;TextComponent&gt;();</span><br><span class="line">    tc.Kerning = kerning;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">float</span> <span class="title">TextComponent_GetLineSpacing</span><span class="params">(UUID entityID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity.<span class="built_in">HasComponent</span>&lt;TextComponent&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; tc = entity.<span class="built_in">GetComponent</span>&lt;TextComponent&gt;();</span><br><span class="line">    <span class="keyword">return</span> tc.LineSpacing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TextComponent_SetLineSpacing</span><span class="params">(UUID entityID, <span class="type">float</span> lineSpacing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Scene* scene = ScriptEngine::<span class="built_in">GetSceneContext</span>();</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(scene);</span><br><span class="line">    Entity entity = scene-&gt;<span class="built_in">GetEntityByUUID</span>(entityID);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity);</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(entity.<span class="built_in">HasComponent</span>&lt;TextComponent&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; tc = entity.<span class="built_in">GetComponent</span>&lt;TextComponent&gt;();</span><br><span class="line">    tc.LineSpacing = lineSpacing;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Components.cs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TextComponent</span> : Component</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> string Text</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; InternalCalls.<span class="built_in">TextComponent_GetText</span>(Entity.ID);</span><br><span class="line">        set =&gt; InternalCalls.<span class="built_in">TextComponent_SetText</span>(Entity.ID, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector4 Color</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            InternalCalls.<span class="built_in">TextComponent_GetColor</span>(Entity.ID, out Vector4 color);</span><br><span class="line">            <span class="keyword">return</span> color;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            InternalCalls.<span class="built_in">TextComponent_SetColor</span>(Entity.ID, ref value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> Kerning</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; InternalCalls.<span class="built_in">TextComponent_GetKerning</span>(Entity.ID);</span><br><span class="line">        set =&gt; InternalCalls.<span class="built_in">TextComponent_SetKerning</span>(Entity.ID, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> LineSpacing</span><br><span class="line">    &#123;</span><br><span class="line">        get =&gt; InternalCalls.<span class="built_in">TextComponent_GetLineSpacing</span>(Entity.ID);</span><br><span class="line">        set =&gt; InternalCalls.<span class="built_in">TextComponent_SetLineSpacing</span>(Entity.ID, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">记录HEngine每一次提交的重点内容以及遇到的问题和解决的步骤</summary>
    
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>实体组件系统(ECS)</title>
    <link href="https://donghuiw.github.io/posts/b6d9ed88"/>
    <id>https://donghuiw.github.io/posts/b6d9ed88</id>
    <published>2025-03-13T14:02:20.000Z</published>
    <updated>2025-03-14T13:58:22.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是ECS？">什么是ECS？</h2><p>学习写游戏引擎的时候，做到这一部分的内容，看了很多相关文章，写一些自己的理解在这</p><blockquote><p>Entity-Component-System (ECS) is a software architectural pattern mostly used on video game development for the storage of game world objects. An ECS follows the pattern of “entities” with “components” of data.<br>An ECS follows the principle of composition over inheritance, meaning that every entity is defined not by a “type”, but by the components that are associated with it. The design of how components relate to entities depend upon the Entity Component System being used.</p></blockquote><p>先不谈ECS架构，先来思考思考，假设我们有一个场景Scene，里面一个是正方体，那么我可以设计这么几个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span>[<span class="number">3</span>] m_Position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> : <span class="keyword">public</span> Enitty &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scene</span></span><br><span class="line">&#123;</span><br><span class="line">std::vector&lt;Entity&gt; m_Entities;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在C++里，public继承是is-a的关系，private继承是has-a的关系，那么如果我需要两个正方体，一个可以播放音频，一个可以播放动画，那么代码是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span>[<span class="number">3</span>] m_Position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> : <span class="keyword">public</span> Enitty &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scene</span></span><br><span class="line">&#123;</span><br><span class="line">std::vector&lt;Entity&gt; m_Entities;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoxWithAudio</span> : <span class="keyword">public</span> Box &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoxWithAnimator</span> : <span class="keyword">public</span> Box &#123;&#125;;</span><br></pre></td></tr></table></figure><p>当如果Box既可以播放音频、又可以播放动画，那么一共会有这么些类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> : <span class="keyword">public</span> Enitty &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoxWithAudio</span> : <span class="keyword">public</span> Box &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoxWithAnimator</span> : <span class="keyword">public</span> Box &#123;&#125;;</span><br><span class="line"><span class="comment">// 出现了multiple inheritance</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoxWithAnimatorAndAudio</span> : <span class="keyword">public</span> BoxWithAnimator, <span class="keyword">public</span> BoxWithAudio &#123;&#125;;</span><br></pre></td></tr></table></figure><p>这里很容易就出现了一个类继承于两个类的情况，而<code>BoxWithAnimator</code>和<code>BoxWithAudio </code>又同时继承于<code>Box</code>，所以这是个菱形继承。Box类才添加了两个功能就会造成这么复杂的类设计，所以说这种写法，很容易造成类混乱，更何况其他的很多语言里根本不支持多重继承。</p><p>所以，这里有个更好的设计思路，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> </span><br><span class="line">&#123;</span><br><span class="line">std::vector&lt;Component&gt; m_Components;</span><br><span class="line"><span class="type">float</span>[<span class="number">3</span>] m_Position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scene</span></span><br><span class="line">&#123;</span><br><span class="line">std::vector&lt;Entity&gt; m_Entities;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MeshComponent</span> : <span class="keyword">public</span> Component &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioComponent</span> : <span class="keyword">public</span> Component &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimatorComponent</span> : <span class="keyword">public</span> Component &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Entity</span></span><br><span class="line">Entity boxWithAnimatorAndAudio;</span><br><span class="line">boxWithAnimatorAndAudio.<span class="built_in">AddComponent</span>(<span class="keyword">new</span> <span class="built_in">MeshComponent</span>());</span><br><span class="line">boxWithAnimatorAndAudio.<span class="built_in">AddComponent</span>(<span class="keyword">new</span> <span class="built_in">AudioComponent</span>());</span><br><span class="line">boxWithAnimatorAndAudio.<span class="built_in">AddComponent</span>(<span class="keyword">new</span> <span class="built_in">AnimatorComponent</span>());</span><br></pre></td></tr></table></figure><p>此时的Entity，它需要什么功能，就会在其<code>m_Components</code>里添加对应的<code>Component</code>组件，这样代码设计就不混乱了。</p><p>上面的代码，是ECS架构的雏形，但还远远不够。假设我们的Scene里有一堆Entity，每个Entity都有自己的Mesh和自己的Position，那么我们渲染的时候，大概会这么写代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历Scene里的entities</span></span><br><span class="line"><span class="keyword">for</span>(Entity&amp; e: m_Entities)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(e.<span class="built_in">GetMeshComponent</span>() ! = null)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">PrepareToDrawMesh</span>(e.<span class="built_in">GetMeshComponent</span>().mesh, e.<span class="built_in">GetPosition</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批处理一起绘制Mesh</span></span><br><span class="line"><span class="built_in">DrawMesh</span>();</span><br></pre></td></tr></table></figure><p>上面的代码，最大的问题是，由于Mesh是存在每个Entity里的，它们的内存必然是散布于计算机各个位置的，那么计算机必然经常会产生缺页情况。没有遵循计算机的局部访问性的代码，效率是很差的。</p><p>为了解决这个问题，更好的思路产生了，Scene里相同Component的数据，应该是连续存储的，大概思路如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Scene</span></span><br><span class="line">&#123;</span><br><span class="line">std::vector&lt;Entity&gt; m_Entities;</span><br><span class="line"><span class="comment">// 真正的数据连续的存在于Scene里</span></span><br><span class="line">std::vector&lt;MeshComponent&gt; m_MeshComponents;</span><br><span class="line">std::vector&lt;AudioComponent&gt; m_AudioComponents;</span><br><span class="line">std::vector&lt;AnimatorComponent&gt; m_AnimatorComponents;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Entity本质就是一个唯一标识符(个人理解)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> m_UniqueId;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span>[<span class="number">3</span>] m_Position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MeshComponent</span> : <span class="keyword">public</span> Component &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AudioComponent</span> : <span class="keyword">public</span> Component &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnimatorComponent</span> : <span class="keyword">public</span> Component &#123;&#125;;</span><br></pre></td></tr></table></figure><p>实际绘制的时候，代码就变成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m_MeshComponents.count; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> Entity&amp; entity = <span class="built_in">FindEntityWhoseMeshIdEquals</span>(i);</span><br><span class="line"><span class="keyword">if</span>(entity ! = null)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">PrepareToDrawMesh</span>(m_MeshComponents[i], entity.<span class="built_in">GetPosition</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批处理一起绘制Mesh</span></span><br><span class="line"><span class="built_in">DrawMesh</span>();</span><br></pre></td></tr></table></figure><p>一般来说, 一个Entity只会有一个某种类型的Component, 比如Animator、Audio组件等，所以前面的Entity里都是用单个<code>uint32_t</code>记录Component在对应数组里的id，但脚本组件一般可以有多个挂在一个Entity上，不过思路是一样的。</p><p>为了方便说明，我在Entity里存了三个float，但这里的Entity.GetPosition可能仍然会产生缺页的情况。实际上应该把Transform信息也作为Component存到Scene里，Entity里不会存储任何实际数据，它的作用是把特定的Components组合起来，然后实际绘制Mesh的时候，内存可能是这样的：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mesh | <span class="type">Transform</span> | <span class="type">Mesh</span> | <span class="type">Transform</span></span><br></pre></td></tr></table></figure><p>Mesh并不是直接连续的，可能是Mesh | Transform 两两一组，分布于Memory里。</p><hr><h4 id="什么是EC">什么是EC?</h4><blockquote><p>EC frameworks, as typically found in game engines, are similar to ECS in that they allow for the creation of entities and the composition of components. However, in an EC framework, components are classes that contain both data and behavior, and behavior is executed directly on the component.</p></blockquote><p>EC框架跟ECS非常类似，无非ECS框架里，Component只负责存Data，而EC框架里，Component除了存Data，还要存Behavior相关的逻辑代码。</p><p>Unity和UE4里都是用的EC架构，而不是ECS</p><p>Unity和UE4里的Component都可以写逻辑代码，甚至UE4的Actor本身就可以在内部写逻辑代码(Unity则不可以)，而且UE4里的Component可以形成父子层级关系：</p><hr><h4 id="结论">结论</h4><p>所以说，ECS里，Components基本上都是存Data的，对Components处理的逻辑代码都放到System里；而EC里，Components里不仅存Data，也存放代码逻辑，所以没有System这个概念。UE4和Unity里基本都是用的EC架构，而不是ECS系统。</p><h4 id="EnTT项目">EnTT项目</h4><p>在HEngine选择的就是使用ECS架构的Entt库,这里是他的<a href="https://github.com/skypjack/entt/wiki">Wiki</a></p><p>该库所有的内容，应该都放到一个叫<code>entt.hpp</code>的文件里了，我看了下，这个文件非常大，一共有17600行，500多KB，应该代码都在里面了，就把它当头文件用就行了。</p><p>这里把该文件放到vendor/entt/include文件夹下，把liscense文件放到vendor/entt文件夹下</p><p>entt相关的内容可以直接看对应的github仓库的介绍，这里看一些例子代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于后面的Callback例子, 当Transform组件被创建时调用, 会加到entity上</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">OnTransformConstruct</span><span class="params">(entt::registry&amp; registry, entt::entity entity)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个TransformComponent类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TransformComponent</span></span><br><span class="line">&#123;</span><br><span class="line">glm::mat4 Transform&#123; <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TransformComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">TransformComponent</span>(<span class="type">const</span> TransformComponent&amp;) = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">TransformComponent</span>(<span class="type">const</span> glm::mat4 &amp; transform)</span><br><span class="line">: <span class="built_in">Transform</span>(transform) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> glm::mat4&amp; () &#123; <span class="keyword">return</span> Transform; &#125;</span><br><span class="line"><span class="keyword">operator</span> <span class="type">const</span> glm::mat4&amp; () <span class="type">const</span> &#123; <span class="keyword">return</span> Transform; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个registry, 可以把它理解为vector&lt;entity&gt;, 也就是包含所有entity的容器</span></span><br><span class="line">entt::registry m_Registry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个entity, entt::entity其实是uint32_t</span></span><br><span class="line">entt::entity entity = m_Registry.<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// emplace等同于AddComponent, 这里给entity添加TransformComponent</span></span><br><span class="line">m_Registry.<span class="built_in">emplace</span>&lt;TransformComponent&gt;(entity, glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// entt提供的Callback, 当TransformComponent被创建时, 调用OnTransformConstruct函数</span></span><br><span class="line">m_Registry.<span class="built_in">on_construct</span>&lt;TransformComponent&gt;().<span class="built_in">connect</span>&lt;&amp;OnTransformConstruct&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断entity上是否有TransformComponent</span></span><br><span class="line"><span class="keyword">if</span> (m_Registry.<span class="built_in">all_of</span>&lt;TransformComponent&gt;(entity))</span><br><span class="line"><span class="comment">// 从entity上get TransformComponent</span></span><br><span class="line">TransformComponent&amp; transform = m_Registry.<span class="built_in">get</span>&lt;TransformComponent&gt;(entity);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有带有TransformComponent的entity数组</span></span><br><span class="line"><span class="keyword">auto</span> view = m_Registry.<span class="built_in">view</span>&lt;TransformComponent&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> entity : view)</span><br><span class="line">&#123;</span><br><span class="line">TransformComponent&amp; transform = view.<span class="built_in">get</span>&lt;TransformComponent&gt;(entity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// group用来获取同时满足拥有多个Component的Entity数组</span></span><br><span class="line"><span class="keyword">auto</span> group = m_Registry.<span class="built_in">group</span>&lt;TransformComponent&gt;(entt::get&lt;SpriteRendererComponent&gt;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> entity : group)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; [transform, spriteRenderer] = group.<span class="built_in">get</span>&lt;TransformComponent, SpriteRendererComponent&gt;(entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">介绍实体组件系统(ECS)的好处以及为什么要实体组件系统</summary>
    
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>HEngine游戏引擎-31-60</title>
    <link href="https://donghuiw.github.io/posts/3ad536fd"/>
    <id>https://donghuiw.github.io/posts/3ad536fd</id>
    <published>2025-03-11T13:02:20.000Z</published>
    <updated>2025-03-17T12:06:28.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三十一、设计着色器库">三十一、设计着色器库</h2><ul><li><p>为什么要Shader库</p><p>为了重复使用shader，把shader存储在cpu中，需要的时候可以直接使用，不用再创建。</p></li></ul><h4 id="代码修改">代码修改</h4><ul><li><p>Shader</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShaderLibrary</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Ref&lt;Shader&gt;&amp; shader)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Ref&lt;Shader&gt;&amp; shader)</span></span>;</span><br><span class="line">    <span class="function">Ref&lt;Shader&gt; <span class="title">Load</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span>;</span><br><span class="line">    <span class="function">Ref&lt;Shader&gt; <span class="title">Load</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; filepath)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Ref&lt;Shader&gt; <span class="title">Get</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Exists</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, Ref&lt;Shader&gt;&gt; m_Shaders;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderLibrary::Add</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> Ref&lt;Shader&gt;&amp; shader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(!<span class="built_in">Exists</span>(name), <span class="string">&quot;Shader already exists!&quot;</span>);</span><br><span class="line">    m_Shaders[name] = shader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShaderLibrary::Add</span><span class="params">(<span class="type">const</span> Ref&lt;Shader&gt;&amp; shader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; name = shader-&gt;<span class="built_in">GetName</span>();</span><br><span class="line">    <span class="built_in">Add</span>(name, shader);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HEngine::Ref&lt;HEngine::Shader&gt; <span class="title">ShaderLibrary::Load</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> shader = Shader::<span class="built_in">Create</span>(filepath);</span><br><span class="line">    <span class="built_in">Add</span>(shader);</span><br><span class="line">    <span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HEngine::Ref&lt;HEngine::Shader&gt; <span class="title">ShaderLibrary::Load</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> shader = Shader::<span class="built_in">Create</span>(filepath);</span><br><span class="line">    <span class="built_in">Add</span>(name,shader);</span><br><span class="line">    <span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HEngine::Ref&lt;HEngine::Shader&gt; <span class="title">ShaderLibrary::Get</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="built_in">Exists</span>(name), <span class="string">&quot;Shader not found!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> m_Shaders[name];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ShaderLibrary::Exists</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_Shaders.<span class="built_in">find</span>(name) != m_Shaders.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Sandboxapp.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m_Shader = HEngine::Shader::<span class="built_in">Create</span>(<span class="string">&quot;VertexPosColor&quot;</span>, vertexSrc, fragmentSrc);</span><br><span class="line"></span><br><span class="line">m_FlatColorShader = HEngine::Shader::<span class="built_in">Create</span>(<span class="string">&quot;FlatColor&quot;</span>,flatColorShaderVertexSrc, flatColorShaderFragmentSrc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> textureShader = m_ShaderLibrary.<span class="built_in">Load</span>(<span class="string">&quot;assets/shaders/Texture.glsl&quot;</span>);</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(textureShader)-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(textureShader)-&gt;<span class="built_in">UploadUniformInt</span>(<span class="string">&quot;u_Texture&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> textureShader = m_ShaderLibrary.<span class="built_in">Get</span>(<span class="string">&quot;Texture&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="三十二、添加相机控制器">三十二、添加相机控制器</h2><ul><li><p>此节目的</p><p>在SandboxApp里面有camera移动旋转的方法，希望能将Camera抽象成一个<strong>类</strong></p></li></ul><h4 id="关键代码">关键代码</h4><ul><li><p>宽高比</p><p>在1280*720下的界面，宽1280&gt;高720，宽明显比高 像素占位<strong>多</strong>。</p><p>需传入1280/720=1.7左右，将宽放大，从而<strong>左右视角变大</strong>，达到正常比例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ExampleLayer</span>() : <span class="built_in">Layer</span>(<span class="string">&quot;Example&quot;</span>), <span class="built_in">m_CameraController</span>(<span class="number">1280.0f</span> / <span class="number">720.0f</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure></li><li><p>m_ZoomLevel视野影响物体大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">m_Camera</span>(-m_AspectRatio * m_ZoomLevel, m_AspectRatio* m_ZoomLevel,-m_ZoomLevel, m_ZoomLevel)</span><br></pre></td></tr></table></figure><ul><li>视野<strong>放大</strong>，物体缩小</li><li>视野<strong>缩小</strong>，物体放大</li></ul></li><li><p>m_ZoomLevel视野影响摄像机移动速度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视野放大，摄像机移动速度变快，视野缩小，摄像机移动速度变慢</span></span><br><span class="line">m_CameraTranslationSpeed = m_ZoomLevel;</span><br></pre></td></tr></table></figure><ul><li>视野<strong>放大</strong>，物体缩小，摄像机移动速度变<strong>快</strong></li><li>视野<strong>缩小</strong>，物体放大，摄像机移动速度变<strong>慢</strong></li></ul></li></ul><h4 id="代码修改-2">代码修改</h4><ul><li><p>新建OrthographicCameraController类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrthographicCameraController</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrthographicCameraController</span>(<span class="type">float</span> aspectRatio, <span class="type">bool</span> rotation = <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(Timestep ts)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span><span class="title">OnEvent</span><span class="params">(Event&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">OrthographiCamera&amp; <span class="title">GetCamera</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> m_Camera; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> OrthographiCamera&amp; <span class="title">GetCamera</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Camera; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OnMouseScrolled</span><span class="params">(MouseScrolledEvent&amp; e)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">OnWindowResized</span><span class="params">(WindowResizeEvent&amp; e)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">float</span> m_AspectRatio;</span><br><span class="line">    <span class="type">float</span> m_ZoomLevel = <span class="number">1.0f</span>;</span><br><span class="line">    OrthographiCamera m_Camera;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> m_Rotation;</span><br><span class="line"></span><br><span class="line">    glm::vec3 m_CameraPosition = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    <span class="type">float</span> m_CameraRotation = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="type">float</span> m_CameraTranslationSpeed = <span class="number">10.0f</span>, m_CameraRotationSpeed = <span class="number">180.0f</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>OrthographicCameraController.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">OrthographicCameraController::<span class="built_in">OrthographicCameraController</span>(<span class="type">float</span> aspectRatio, <span class="type">bool</span> rotation)</span><br><span class="line">: <span class="built_in">m_AspectRatio</span>(aspectRatio), <span class="built_in">m_Camera</span>(-m_AspectRatio * m_ZoomLevel, m_AspectRatio * m_ZoomLevel, -m_ZoomLevel, m_ZoomLevel), <span class="built_in">m_Rotation</span>(rotation)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OrthographicCameraController::OnUpdate</span><span class="params">(Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_A))</span><br><span class="line">m_CameraPosition.x -= m_CameraTranslationSpeed * ts;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_D))</span><br><span class="line">m_CameraPosition.x += m_CameraTranslationSpeed * ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_W))</span><br><span class="line">m_CameraPosition.y += m_CameraTranslationSpeed * ts;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_S))</span><br><span class="line">m_CameraPosition.y -= m_CameraTranslationSpeed * ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_Rotation)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_Q))</span><br><span class="line">m_CameraRotation += m_CameraRotationSpeed * ts;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_E))</span><br><span class="line">m_CameraRotation -= m_CameraRotationSpeed * ts;</span><br><span class="line"></span><br><span class="line">m_Camera.<span class="built_in">SetRotation</span>(m_CameraRotation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_Camera.<span class="built_in">SetPosition</span>(m_CameraPosition);</span><br><span class="line"></span><br><span class="line">m_CameraTranslationSpeed = m_ZoomLevel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OrthographicCameraController::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">EventDispatcher <span class="title">dispatcher</span><span class="params">(e)</span></span>;</span><br><span class="line">dispatcher.<span class="built_in">Dispatch</span>&lt;MouseScrolledEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(OrthographicCameraController::OnMouseScrolled));</span><br><span class="line">dispatcher.<span class="built_in">Dispatch</span>&lt;WindowResizeEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(OrthographicCameraController::OnWindowResized));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OrthographicCameraController::OnMouseScrolled</span><span class="params">(MouseScrolledEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_ZoomLevel -= e.<span class="built_in">GetYOffset</span>() * <span class="number">0.25f</span>;</span><br><span class="line">m_ZoomLevel = std::<span class="built_in">max</span>(m_ZoomLevel, <span class="number">0.25f</span>);</span><br><span class="line">m_Camera.<span class="built_in">SetProjection</span>(-m_AspectRatio * m_ZoomLevel, m_AspectRatio * m_ZoomLevel, -m_ZoomLevel, m_ZoomLevel);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OrthographicCameraController::OnWindowResized</span><span class="params">(WindowResizeEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_AspectRatio = (<span class="type">float</span>)e.<span class="built_in">GetWidth</span>() / (<span class="type">float</span>)e.<span class="built_in">GetHeight</span>();</span><br><span class="line">m_Camera.<span class="built_in">SetProjection</span>(-m_AspectRatio * m_ZoomLevel, m_AspectRatio * m_ZoomLevel, -m_ZoomLevel, m_ZoomLevel);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SandboxApp.cpp</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ExampleLayer</span>()</span><br><span class="line">    : <span class="built_in">Layer</span>(<span class="string">&quot;Example&quot;</span>), <span class="built_in">m_CameraController</span>(<span class="number">1280.0f</span> / <span class="number">720.0f</span>, <span class="literal">false</span>)</span><br><span class="line">    &#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(HEngine::Timestep ts)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_CameraController.<span class="built_in">OnUpdate</span>(ts);</span><br><span class="line">    </span><br><span class="line">    HEngine::Renderer::<span class="built_in">BeginScene</span>(m_CameraController.<span class="built_in">GetCamera</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnEvent</span><span class="params">(HEngine::Event&amp; e)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_CameraController.<span class="built_in">OnEvent</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三十三、窗口大小调整功能">三十三、窗口大小调整功能</h2><p>三十二节虽然设置了CameraController的窗口resize事件，但是OpenGL并没有改变渲染的位置，依旧是<strong>原先的大小和位置</strong>，所以需要调整OpenGL的渲染视口。</p><p>后期我们需要为引擎实现不依靠停留在窗口也可以渲染的区域，需要用到OpenGL的frame buffer</p><ul><li><p>此节目的</p><p>为了实现调整窗口大小后</p><ul><li><p>OpenGL<strong>绘图的区域</strong>也会相应调整</p><p>窗口调为0*0，OpenGL不应该渲染图形了</p></li><li><p>摄像机也会根据窗口大小的变换，依旧保持正确的<strong>宽高比</strong></p></li></ul></li></ul><h4 id="关键代码-2">关键代码</h4><ul><li><p>Application.cpp</p><p>使用事件调度器捕捉响应Window调整大小事件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dispatcher.<span class="built_in">Dispatch</span>&lt;WindowResizeEvent&gt;(<span class="built_in">BIND_EVENT_FN</span>(OnWindowResize));<span class="comment">// 捕捉响应Window调整大小事件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Application::OnWindowResize</span><span class="params">(WindowResizeEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.<span class="built_in">GetWidth</span>() == <span class="number">0</span> || e.<span class="built_in">GetHeight</span>() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Minimized = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m_Minimized = <span class="literal">false</span>;</span><br><span class="line">    Renderer::<span class="built_in">OnWindowResize</span>(e.<span class="built_in">GetWidth</span>(), e.<span class="built_in">GetHeight</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!m_Minimized) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Layer* layer : m_LayerStack) &#123;</span><br><span class="line">        layer-&gt;<span class="built_in">OnUpdate</span>(timestep);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>OpenGL改变视口：<strong>绘图的区域</strong>改变</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::SetViewport</span><span class="params">(<span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y, <span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glViewport</span>(x, y, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>窗口大小调整，摄像机需要依旧保持正确的宽高比</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> HEngine::OrthographicCameraController::<span class="built_in">OnWindowResized</span>(WindowResizeEvent&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重新计算宽高比</span></span><br><span class="line">    m_AspectRatio = (<span class="type">float</span>)e.<span class="built_in">GetWidth</span>() / (<span class="type">float</span>)e.<span class="built_in">GetHeight</span>();</span><br><span class="line">    m_Camera.<span class="built_in">SetProjection</span>(-m_AspectRatio * m_ZoomLevel, m_AspectRatio * m_ZoomLevel, -m_ZoomLevel, m_ZoomLevel);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="三十四、创建SandBox2D">三十四、创建SandBox2D</h2><ul><li><p>此节所做</p><p>将Sandbox项目中的ExampleLayer渲染代码<strong>移到</strong>在Sandbox项目中新创建的SandBox2D(Layer)类中。</p><p>在SandBox2D类中<strong>调用</strong>HEngine项目中的OpenGLRenderer类。</p></li></ul><h4 id="代码修改-3">代码修改</h4><p>Sandbox2D.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sandbox2D</span> : <span class="keyword">public</span> HEngine::Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Sandbox2D</span>();</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Sandbox2D</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnAttach</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDetach</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(HEngine::Timestep ts)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnEvent</span><span class="params">(HEngine::Event&amp; e)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HEngine::OrthographicCameraController m_CameraController;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Temp</span></span><br><span class="line">HEngine::Ref&lt;HEngine::VertexArray&gt; m_SquareVA;</span><br><span class="line">HEngine::Ref&lt;HEngine::Shader&gt; m_FlatColorShader;</span><br><span class="line"></span><br><span class="line">glm::vec4 m_SquareColor = &#123; <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Sandbox2D.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Sandbox2D::<span class="built_in">Sandbox2D</span>()</span><br><span class="line">:<span class="built_in">Layer</span>(<span class="string">&quot;Sandbox2D&quot;</span>), <span class="built_in">m_CameraController</span>(<span class="number">1280.0f</span> / <span class="number">720.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnAttach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_SquareVA = HEngine::VertexArray::<span class="built_in">Create</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> squareVertices[<span class="number">5</span> * <span class="number">4</span>] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line"> <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line"><span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HEngine::Ref&lt;HEngine::VertexBuffer&gt; squareVB;</span><br><span class="line">squareVB.<span class="built_in">reset</span>(HEngine::VertexBuffer::<span class="built_in">Create</span>(squareVertices, <span class="built_in">sizeof</span>(squareVertices)));</span><br><span class="line">squareVB-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">&#123;HEngine::ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line">m_SquareVA-&gt;<span class="built_in">AddVertexBuffer</span>(squareVB);</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> squareIndices[<span class="number">6</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span> &#125;;</span><br><span class="line">HEngine::Ref&lt;HEngine::IndexBuffer&gt; squareIB;</span><br><span class="line">squareIB.<span class="built_in">reset</span>(HEngine::IndexBuffer::<span class="built_in">Create</span>(squareIndices, <span class="built_in">sizeof</span>(squareIndices) / <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line">m_SquareVA-&gt;<span class="built_in">SetIndexBuffer</span>(squareIB);</span><br><span class="line"></span><br><span class="line">m_FlatColorShader = HEngine::Shader::<span class="built_in">Create</span>(<span class="string">&quot;assets/shaders/FlatColor.glsl&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnUpdate</span><span class="params">(HEngine::Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Update</span></span><br><span class="line">m_CameraController.<span class="built_in">OnUpdate</span>(ts);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Render</span></span><br><span class="line">HEngine::RenderCommand::<span class="built_in">SetClearColor</span>(&#123; <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1</span> &#125;);</span><br><span class="line">HEngine::RenderCommand::<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">HEngine::Renderer::<span class="built_in">BeginScene</span>(m_CameraController.<span class="built_in">GetCamera</span>());</span><br><span class="line"></span><br><span class="line">std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(m_FlatColorShader)-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(m_FlatColorShader)-&gt;<span class="built_in">UploadUniformFloat4</span>(<span class="string">&quot;u_Color&quot;</span>, m_SquareColor);</span><br><span class="line"></span><br><span class="line">HEngine::Renderer::<span class="built_in">Submit</span>(m_FlatColorShader, m_SquareVA, glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">1.5f</span>)));</span><br><span class="line"></span><br><span class="line">HEngine::Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Settings&quot;</span>);</span><br><span class="line">ImGui::<span class="built_in">ColorEdit4</span>(<span class="string">&quot;Square Color&quot;</span>, glm::<span class="built_in">value_ptr</span>(m_SquareColor));</span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnEvent</span><span class="params">(HEngine::Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_CameraController.<span class="built_in">OnEvent</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三十五、创建Renderer2D">三十五、创建Renderer2D</h2><ul><li>此节所作<ul><li>在Sandbox2D类的基础上再做一次封装，将去除关于着色器、顶点缓冲这些关于代码，只需使用简单的Api调用就能绘制<strong>单个quad图形</strong>。</li><li><strong>新建一个</strong>Renderer2D类来渲染单个2Dquad图形，而不是用Rednerer类来渲染一个大场景。</li></ul></li></ul><h4 id="2D渲染类的函数是静态的解释">2D渲染类的函数是静态的解释</h4><ol><li>OpenGL绘图是一个设置<strong>状态顺序</strong>的过程</li><li>在2D渲染类中只是简单的调用设置OpenGL状态，并<strong>不需要实例化</strong></li><li><strong>不需要</strong>让一个2D渲染类开始场景，另一个2D渲染类绘制</li><li>综上，只需要一个就行，所以静态即可</li></ol><h4 id="代码改变">代码改变</h4><ul><li><p>Renderer2D</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer2D</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BeginScene</span><span class="params">(<span class="type">const</span> OrthographiCamera&amp; camera)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">EndScene</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//Primitives</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DrawQuad</span><span class="params">(<span class="type">const</span> glm::vec2&amp; position, <span class="type">const</span> glm::vec2 size, <span class="type">const</span> glm::vec4&amp; color)</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DrawQuad</span><span class="params">(<span class="type">const</span> glm::vec3&amp; position, <span class="type">const</span> glm::vec2 size, <span class="type">const</span> glm::vec4&amp; color)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Renderer2D.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Renderer2DStorage</span></span><br><span class="line">&#123;</span><br><span class="line">    Ref&lt;VertexArray&gt; QuadVertexArray;</span><br><span class="line">    Ref&lt;Shader&gt; FlatColorShader;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> Renderer2DStorage* s_Data;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::BeginScene</span><span class="params">(<span class="type">const</span> OrthographiCamera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">dynamic_pointer_cast</span>&lt;OpenGLShader&gt;(s_Data-&gt;FlatColorShader)-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    std::<span class="built_in">dynamic_pointer_cast</span>&lt;OpenGLShader&gt;(s_Data-&gt;FlatColorShader)-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_ViewProjection&quot;</span>, camera.<span class="built_in">GetViewProjectionMatrix</span>());</span><br><span class="line">    std::<span class="built_in">dynamic_pointer_cast</span>&lt;OpenGLShader&gt;(s_Data-&gt;FlatColorShader)-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_Transform&quot;</span>, glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawQuad</span><span class="params">(<span class="type">const</span> glm::vec2&amp; position, <span class="type">const</span> glm::vec2 size, <span class="type">const</span> glm::vec4&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DrawQuad</span>(&#123; position.x,position.y,<span class="number">0.0f</span> &#125;, size, color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawQuad</span><span class="params">(<span class="type">const</span> glm::vec3&amp; position, <span class="type">const</span> glm::vec2 size, <span class="type">const</span> glm::vec4&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">dynamic_pointer_cast</span>&lt;OpenGLShader&gt;(s_Data-&gt;FlatColorShader)-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    std::<span class="built_in">dynamic_pointer_cast</span>&lt;OpenGLShader&gt;(s_Data-&gt;FlatColorShader)-&gt;<span class="built_in">UploadUniformFloat4</span>(<span class="string">&quot;u_Color&quot;</span>, color);</span><br><span class="line"></span><br><span class="line">    s_Data-&gt;QuadVertexArray-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(s_Data-&gt;QuadVertexArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Sandbox2D.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnUpdate</span><span class="params">(HEngine::Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">BeginScene</span>(m_CameraController.<span class="built_in">GetCamera</span>());</span><br><span class="line">HEngine::Renderer2D::<span class="built_in">DrawQuad</span>(&#123; <span class="number">0.0f</span>,<span class="number">0.0f</span> &#125;, &#123; <span class="number">1.0f</span>,<span class="number">1.0f</span> &#125;, &#123; <span class="number">0.8f</span>,<span class="number">0.2f</span>,<span class="number">0.3f</span>,<span class="number">1.0f</span> &#125;);</span><br><span class="line">HEngine::Renderer2D::<span class="built_in">EndScene</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三十六、实现单个着色器">三十六、实现单个着色器</h2><p>目前的Renderer2D有两个Shader，FlatColorShader和TextureShader，其实可以把两个Shader合为一个Shader，毕竟Shader的编译还是要消耗不少性能的。</p><p>这么做的思路是，使用两个uniform，一个是代表color的float4的uniform，一个是代表texture的sampler2D的uniform，片元着色器如下所示：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> u_Color;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> u_Texture;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">color = <span class="built_in">texture</span>(u_Texture, v_TexCoord * <span class="number">10.0</span>) * u_Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心思路是，当我想要把Shader用作TextureShader时，那么传入我要渲染的Texture，u_Color传入(1,1,1,1)即可；当我想要把Shader用作FlatShader时，u_Color里传入我要显示的FlatColor，同时传入一个特殊的WhiteTexture，这个Texture的Sample的返回值永远是(1,1,1,1)。</p><p>Renderer2D.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Renderer2DStorage</span></span><br><span class="line">&#123;</span><br><span class="line">std::shared_ptr&lt;VertexArray&gt; QuadVertexArray;</span><br><span class="line"><span class="comment">// std::shared_ptr&lt;Shader&gt; FlatColorShader; 删除</span></span><br><span class="line">std::shared_ptr&lt;Shader&gt; TextureShader;</span><br><span class="line">std::shared_ptr&lt;Texture2D&gt; WhiteTexture;<span class="comment">// 这张图是白色的, 用作FlatColor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawQuad</span><span class="params">(<span class="type">const</span> glm::vec3&amp; position, <span class="type">const</span> glm::vec2 size, <span class="type">const</span> glm::vec4&amp; color)</span><span class="comment">//不要纹理时只传入Color</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_Data-&gt;TextureShader-&gt;<span class="built_in">SetFloat4</span>(<span class="string">&quot;u_Color&quot;</span>, color);</span><br><span class="line">    s_Data-&gt;WhiteTexture-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">    glm::mat4 transform = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), position) * glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), &#123; size.x, size.y,<span class="number">1.0f</span> &#125;);</span><br><span class="line">    s_Data-&gt;TextureShader-&gt;<span class="built_in">SetMat4</span>(<span class="string">&quot;u_Transform&quot;</span>, transform);</span><br><span class="line"></span><br><span class="line">    s_Data-&gt;QuadVertexArray-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(s_Data-&gt;QuadVertexArray);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawQuad</span><span class="params">(<span class="type">const</span> glm::vec3&amp; position, <span class="type">const</span> glm::vec2 size, <span class="type">const</span> Ref&lt;Texture2D&gt;&amp; texture)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s_Data-&gt;TextureShader-&gt;<span class="built_in">SetFloat4</span>(<span class="string">&quot;u_Color&quot;</span>, glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>));</span><br><span class="line">    texture-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">    glm::mat4 transform = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), position) * glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), &#123; size.x, size.y,<span class="number">1.0f</span> &#125;);</span><br><span class="line">    s_Data-&gt;TextureShader-&gt;<span class="built_in">SetMat4</span>(<span class="string">&quot;u_Transform&quot;</span>, transform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sandbox2D.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnUpdate</span><span class="params">(HEngine::Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">DrawQuad</span>(&#123; <span class="number">-1.0f</span>, <span class="number">0.0f</span> &#125;, &#123; <span class="number">0.8f</span>, <span class="number">0.8f</span> &#125;, &#123; <span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">DrawQuad</span>(&#123; <span class="number">0.5f</span>, <span class="number">-0.5f</span> &#125;, &#123; <span class="number">0.5f</span>, <span class="number">0.75f</span> &#125;, &#123; <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">DrawQuad</span>(&#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-0.1f</span> &#125;, &#123; <span class="number">10.0f</span>, <span class="number">10.0f</span> &#125;, m_CheckerboardTexture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三十七、添加程序性能检测功能">三十七、添加程序性能检测功能</h2><p>对于C++程序的性能优劣，程序所用时长是一个很重要的指标，为了方便预览和分析程序里想要分析的代码片段每帧所花的时间，这里选了一个很简单的方法，就是在Runtime把Profile信息写到一个JSON文件里，然后利用Chrome提供的Chrome Tracing工具(只要在谷歌浏览器里输入chrome://tracing即可打开它)，来帮忙分析这个JSON文件。</p><p>实现写入JSON文件的类叫<code>instrumentor</code>，这个单词在英语里其实并不存在，它源自于单词<code>instrumentation</code>，本意是一套仪器、仪表，在CS里的意思是对程序性能、错误等方面的监测</p><p>所以<code>instrumentor</code>可以翻译为程序性能检测者，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ProfileResult</span></span><br><span class="line">&#123;</span><br><span class="line">std::string Name;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> Start, End;</span><br><span class="line"><span class="type">uint32_t</span> ThreadID;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">InstrumentationSession</span></span><br><span class="line">&#123;</span><br><span class="line">std::string Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Instrumentor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">InstrumentationSession* m_CurrentSession;</span><br><span class="line">std::ofstream m_OutputStream;</span><br><span class="line"><span class="type">int</span> m_ProfileCount;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Instrumentor</span>()</span><br><span class="line">: <span class="built_in">m_CurrentSession</span>(<span class="literal">nullptr</span>), <span class="built_in">m_ProfileCount</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BeginSession</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> std::string&amp; filepath = <span class="string">&quot;results.json&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_OutputStream.<span class="built_in">open</span>(filepath);</span><br><span class="line"><span class="built_in">WriteHeader</span>();</span><br><span class="line">m_CurrentSession = <span class="keyword">new</span> InstrumentationSession&#123; name &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EndSession</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">WriteFooter</span>();</span><br><span class="line">m_OutputStream.<span class="built_in">close</span>();</span><br><span class="line"><span class="keyword">delete</span> m_CurrentSession;</span><br><span class="line">m_CurrentSession = <span class="literal">nullptr</span>;</span><br><span class="line">m_ProfileCount = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteProfile</span><span class="params">(<span class="type">const</span> ProfileResult&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_ProfileCount++ &gt; <span class="number">0</span>)</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::string name = result.Name;</span><br><span class="line">std::<span class="built_in">replace</span>(name.<span class="built_in">begin</span>(), name.<span class="built_in">end</span>(), <span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;\&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;\&quot;cat\&quot;:\&quot;function\&quot;,&quot;</span>;</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;\&quot;dur\&quot;:&quot;</span> &lt;&lt; (result.End - result.Start) &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;\&quot;name\&quot;:\&quot;&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;\&quot;,&quot;</span>;</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;\&quot;ph\&quot;:\&quot;X\&quot;,&quot;</span>;</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;\&quot;pid\&quot;:0,&quot;</span>;</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;\&quot;tid\&quot;:&quot;</span> &lt;&lt; result.ThreadID &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;\&quot;ts\&quot;:&quot;</span> &lt;&lt; result.Start;</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">m_OutputStream.<span class="built_in">flush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteHeader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;&#123;\&quot;otherData\&quot;: &#123;&#125;,\&quot;traceEvents\&quot;:[&quot;</span>;</span><br><span class="line">m_OutputStream.<span class="built_in">flush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteFooter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_OutputStream &lt;&lt; <span class="string">&quot;]&#125;&quot;</span>;</span><br><span class="line">m_OutputStream.<span class="built_in">flush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> Instrumentor&amp; <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> Instrumentor instance;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InstrumentationTimer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">InstrumentationTimer</span>(<span class="type">const</span> <span class="type">char</span>* name)</span><br><span class="line">: <span class="built_in">m_Name</span>(name), <span class="built_in">m_Stopped</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_StartTimepoint = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">InstrumentationTimer</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!m_Stopped)</span><br><span class="line"><span class="built_in">Stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> endTimepoint = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> start = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(m_StartTimepoint).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> end = std::chrono::<span class="built_in">time_point_cast</span>&lt;std::chrono::microseconds&gt;(endTimepoint).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> threadID = std::hash&lt;std::thread::id&gt;&#123;&#125;(std::this_thread::<span class="built_in">get_id</span>());</span><br><span class="line">Instrumentor::<span class="built_in">Get</span>().<span class="built_in">WriteProfile</span>(&#123; m_Name, start, end, threadID &#125;);</span><br><span class="line"></span><br><span class="line">m_Stopped = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* m_Name;</span><br><span class="line">std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_StartTimepoint;</span><br><span class="line"><span class="type">bool</span> m_Stopped;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_PROFILE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> HE_PROFILE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_PROFILE_BEGIN_SESSION(name, filepath) ::HEngine::Instrumentor::Get().BeginSession(name, filepath)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_PROFILE_END_SESSION() ::HEngine::Instrumentor::Get().EndSession()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_PROFILE_SCOPE(name) ::HEngine::InstrumentationTimer timer##__LINE__(name);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_PROFILE_FUNCTION() HE_PROFILE_SCOPE(__FUNCSIG__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_PROFILE_BEGIN_SESSION(name, filepath)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_PROFILE_END_SESSION()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_PROFILE_SCOPE(name)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_PROFILE_FUNCTION()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="三十八、改进Renderer2D">三十八、改进Renderer2D</h2><ul><li>此节目的，对Renderer2D API进行改进，重载DrawQuad方法进行<strong>添加旋转</strong>的功能。</li></ul><h4 id="改进">改进</h4><ul><li><p>glsl纹理采样坐标从0-1到0-10应由CPP绘图API控制</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">color = <span class="built_in">texture</span>(u_Texture, v_TexCoord * <span class="number">10.0</span>) * u_Color;</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#type fragment</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">layout</span>(<span class="keyword">location</span> = <span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> color;</span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> v_TexCoord;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> u_Color;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> u_TilingFactor;<span class="comment">// 由这个控制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> u_Texture; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">color = <span class="built_in">texture</span>(u_Texture, v_TexCoord * u_TilingFactor) * u_Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="代码">代码</h4><ul><li><p>Renderer2D.cpp新增和扩展API</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawRotatedQuad</span><span class="params">(<span class="type">const</span> glm::vec2&amp; position, <span class="type">const</span> glm::vec2 size, <span class="type">float</span> rotation, <span class="type">const</span> glm::vec4&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">DrawRotatedQuad</span>(&#123; position.x,position.y,<span class="number">0.0f</span> &#125;, size, rotation, color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawRotatedQuad</span><span class="params">(<span class="type">const</span> glm::vec3&amp; position, <span class="type">const</span> glm::vec2 size, <span class="type">float</span> rotation, <span class="type">const</span> glm::vec4&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_PROFILE_FUNCTION</span>();</span><br><span class="line"></span><br><span class="line">    s_Data-&gt;TextureShader-&gt;<span class="built_in">SetFloat4</span>(<span class="string">&quot;u_Color&quot;</span>, color);</span><br><span class="line">    s_Data-&gt;TextureShader-&gt;<span class="built_in">SetFloat</span>(<span class="string">&quot;u_TilingFactor&quot;</span>, <span class="number">1.0f</span>);</span><br><span class="line">    s_Data-&gt;WhiteTexture-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">    glm::mat4 transform = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), position)</span><br><span class="line">        * glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), rotation, &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;)</span><br><span class="line">        * glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), &#123; size.x, size.y, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    s_Data-&gt;TextureShader-&gt;<span class="built_in">SetMat4</span>(<span class="string">&quot;u_Transform&quot;</span>, transform);</span><br><span class="line">    s_Data-&gt;QuadVertexArray-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(s_Data-&gt;QuadVertexArray);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>Sandbox2D.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnUpdate</span><span class="params">(HEngine::Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">DrawRotatedQuad</span>(&#123; <span class="number">-1.0f</span>, <span class="number">0.0f</span> &#125;, &#123; <span class="number">0.8f</span>, <span class="number">0.8f</span> &#125;, <span class="number">45.0f</span>, &#123; <span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">DrawQuad</span>(&#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-0.1f</span> &#125;, &#123; <span class="number">10.0f</span>, <span class="number">10.0f</span> &#125;, m_CheckerboardTexture, <span class="number">10.0f</span>, glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>, <span class="number">0.9f</span>, <span class="number">0.9f</span>, <span class="number">1.0f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="三十九、实现批处理2D渲染">三十九、实现批处理2D渲染</h2><h4 id="前言">前言</h4><ul><li><p>目的</p><p>实现OpenGL的批处理渲染，<strong>减少</strong>OpenGL绘制命令的调用，用<strong>一次</strong>OpenGL绘制命令，绘制<strong>多个</strong>图形</p></li><li><p>大致思路</p><p>CPU和GPU都开辟同样大小的一大块内存（为了存储顶点信息）</p><p>索引在程序运行时生成对应规则后绑定到索引缓冲中</p><p>动态生成顶点信息（现在改成Drawquad只是确定图形顶点的位置）</p><p>然后在Endscene，将CPU的动态生成的顶点数据<strong>上传</strong>给GPU，然后再<strong>绘制</strong>出来。</p></li></ul><h4 id="关键代码流程">关键代码流程</h4><ul><li><p>CPU和GPU都开辟同样大小的一大块内存（为了存储顶点信息）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在CPU开辟存储s_Data.MaxVertices个的QuadVertex的内存</span></span><br><span class="line">s_Data.QuadVertexBufferBase = <span class="keyword">new</span> QuadVertex[s_Data.MaxVertices];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建顶点缓冲区,先在GPU开辟一块s_Data.MaxVertices * sizeof(QuadVertex)大小的内存</span></span><br><span class="line">s_Data.QuadVertexBuffer = VertexBuffer::<span class="built_in">Create</span>(s_Data.MaxVertices * <span class="built_in">sizeof</span>(QuadVertex));</span><br></pre></td></tr></table></figure></li><li><p>索引在程序运行时生成对应规则后绑定到索引缓冲中</p><p>（规则就是2个三角形组成的Quad，本来2个三角形共6个顶点，用索引后可以重复利用顶点，从而减少到4个顶点组成一个四方形）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span>* quadIndices = <span class="keyword">new</span> <span class="type">uint32_t</span>[s_Data.MaxIndices];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个quad用6个索引，012 230</span></span><br><span class="line"><span class="type">uint32_t</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; s_Data.MaxIndices; i += <span class="number">6</span>) &#123;</span><br><span class="line">    quadIndices[i + <span class="number">0</span>] = offset + <span class="number">0</span>;</span><br><span class="line">    quadIndices[i + <span class="number">1</span>] = offset + <span class="number">1</span>;</span><br><span class="line">    quadIndices[i + <span class="number">2</span>] = offset + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    quadIndices[i + <span class="number">3</span>] = offset + <span class="number">2</span>;</span><br><span class="line">    quadIndices[i + <span class="number">4</span>] = offset + <span class="number">3</span>;</span><br><span class="line">    quadIndices[i + <span class="number">5</span>] = offset + <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    offset += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ref&lt;IndexBuffer&gt; flatIB = IndexBuffer::<span class="built_in">Create</span>(quadIndices, s_Data.MaxIndices);</span><br><span class="line"></span><br><span class="line">s_Data.QuadVertexArray-&gt;<span class="built_in">SetIndexBuffer</span>(flatIB);</span><br><span class="line"><span class="keyword">delete</span>[] quadIndices;</span><br></pre></td></tr></table></figure></li><li><p>动态生成顶点信息，主要是位置、纹理坐标</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> HEngine::Renderer2D::<span class="built_in">DrawQuad</span>(<span class="type">const</span> glm::vec3&amp; position, <span class="type">const</span> glm::vec2&amp; size, <span class="type">const</span> glm::vec4&amp; color)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// quad的左下角为起点</span></span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Position = position;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Color = color;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexCoord = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Position = &#123; position.x + size.x, position.y, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Color = color;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexCoord = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Position = &#123; position.x + size.x, position.y + size.y, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Color = color;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexCoord = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Position = &#123; position.x, position.y +size.y , <span class="number">0.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Color = color;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexCoord = &#123; <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">    s_Data.QuadIndexCount += <span class="number">6</span>;<span class="comment">// 每一个quad用6个索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后在Endscene，将CPU的动态生成的顶点数据(主要是<strong>位置</strong>信息）上传给GPU，然后再绘制出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> HEngine::Renderer2D::<span class="built_in">EndScene</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算当前绘制需要多少个顶点数据</span></span><br><span class="line">    <span class="type">uint32_t</span> dataSize = (<span class="type">uint8_t</span>*)s_Data.QuadVertexBufferPtr - (<span class="type">uint8_t</span>*)s_Data.QuadVertexBufferBase;</span><br><span class="line">    <span class="comment">// 截取部分CPU的顶点数据上传OpenGL</span></span><br><span class="line">    s_Data.QuadVertexBuffer-&gt;<span class="built_in">SetData</span>(s_Data.QuadVertexBufferBase, dataSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Flush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::Flush</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(s_Data.QuadVertexArray, s_Data.QuadIndexCount);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLVertexBuffer::SetData</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">    <span class="comment">// 截取部分CPU的顶点数据上传OpenGL</span></span><br><span class="line">    <span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">0</span>, size, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Glsl的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#type vertex</span></span><br><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">0</span>) in vec3 a_Position;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">1</span>) in vec4 a_Color;</span><br><span class="line"><span class="built_in">layout</span>(location = <span class="number">2</span>) in vec2 a_TexCoord;</span><br><span class="line"></span><br><span class="line">uniform mat4 u_ViewProjection;</span><br><span class="line"><span class="comment">// uniform mat4 u_Transform;</span></span><br><span class="line"></span><br><span class="line">out vec4 v_Color;</span><br><span class="line">out vec2 v_TexCoord;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">v_Color = a_Color;</span><br><span class="line">v_TexCoord = a_TexCoord;</span><br><span class="line">    <span class="comment">// 由规则动态生成的顶点位置（基于本地空间）没有涉及transform变换顶点位置</span></span><br><span class="line">    <span class="comment">// gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0); </span></span><br><span class="line">gl_Position = u_ViewProjection * <span class="built_in">vec4</span>(a_Position, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="四十、-Batch-Textures">四十、 Batch Textures</h2><h4 id="前言-2">前言</h4><ul><li><p>回顾纹理采样个人理解。</p><ol><li>加载纹理资源，设置这个纹理资源开辟的缓冲区m_RendererID绑定在纹理槽0号上</li><li>glsl上采样的纹理，在纹理槽0号上采样，纹理槽0号指向了第1步的纹理资源，这样就完成对这个加载的纹理采样。</li></ol></li><li><p>OpenGL的纹理槽</p><p>OpenGL限制了一次drawcall能使用多少个纹理槽，HEngine设置为<strong>32</strong>个</p><p>若想超过32有40个纹理需要使用，可以：</p><ul><li>分两次，第一次drawcall32个，然后清空重新加载纹理再drawcall</li><li>用纹理集，texture altas</li></ul></li></ul><h4 id="大致流程">大致流程</h4><ol><li><p>先提前为此次的shader上传一个默认的大小为32的采样<strong>数组</strong></p><p>u_Textures[i] = i，u_Textures[1] = 1表示片段着色器采样纹理槽<strong>1</strong>号上的纹理</p></li><li><p>加载一个纹理得到纹理对象，用数组保存这个纹理对象</p></li><li><p>在绘制<strong>带有纹理</strong>的quad图形时，判断数组中是否有这个纹理对象</p></li><li><p>设置当前顶点采样的纹理单元是 <strong>i</strong>，后续会将这个纹理槽号 <strong>i</strong> 从顶点阶段传入到fragment片段着色器阶段</p></li><li><p>在Drawcall前，TextureSlots数组上存储已经加载的纹理，按照顺序依次<strong>绑定到对应的纹理槽</strong>上</p></li><li><p>Drawcall时，在片段着色器上，读取采样对应纹理槽号<strong>i</strong>上的纹理</p></li></ol><h4 id="代码-2">代码</h4><ul><li><p>先记住数据结构</p><ul><li><p>std::array&lt;Ref, MaxTextureSlots&gt; TextureSlots;</p><p>是一个32大小的数组，数组的元素是纹理对象指针，用来存储加载好了的纹理对象的</p></li><li><p>int32_t samplers[s_Data.MaxTextureSlots];</p><p>是一个32大小的数组，数组的元素是int值，用来上传给glsl的</p></li></ul></li></ul><ol><li><p>先提前为此次的shader上传一个默认的大小为32的采样数组，u_Textures[i] = j, 其中i = j,u_Textures[1] = 1表示采样纹理槽1号上的纹理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 纹理的shader</span></span><br><span class="line">s_Data.TextureShader = Shader::<span class="built_in">Create</span>(<span class="string">&quot;assets/shaders/Texture.glsl&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> samplers[s_Data.MaxTextureSlots];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; s_Data.MaxTextureSlots; i++) &#123;</span><br><span class="line">samplers[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">s_Data.TextureShader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"><span class="comment">// 为TextureShader上传一个默认的大小为32的采样数组</span></span><br><span class="line">s_Data.TextureShader-&gt;<span class="built_in">SetIntArray</span>(<span class="string">&quot;u_Textures&quot;</span>, samplers, s_Data.MaxTextureSlots);</span><br></pre></td></tr></table></figure></li><li><p>加载一个纹理得到纹理对象，用数组保存这个纹理对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 白色纹理</span></span><br><span class="line"><span class="comment">// 创建一个白色Texture</span></span><br><span class="line">s_Data.WhiteTexture = Texture2D::<span class="built_in">Create</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">uint32_t</span> whiteTextureData = <span class="number">0xffffffff</span>;</span><br><span class="line">s_Data.WhiteTexture-&gt;<span class="built_in">SetData</span>(&amp;whiteTextureData, <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0号纹理槽对应白色纹理缓冲区</span></span><br><span class="line">s_Data.TextureSlots[<span class="number">0</span>] = s_Data.WhiteTexture;</span><br></pre></td></tr></table></figure></li><li><p>在当前绘制quad图形时，判断TextureSlots数组是否有这个纹理，有就取出 i 下标，没有就加在数组已有纹理的末尾，并且记录下标 <strong>i</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> textureIndex = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">1</span>; i &lt; s_Data.TextureSlotIndex; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当前纹理，如果已经存储在纹理槽，就直接读取</span></span><br><span class="line">    <span class="keyword">if</span> (*s_Data.TextureSlots[i].<span class="built_in">get</span>() == *texture.<span class="built_in">get</span>()) &#123;</span><br><span class="line">        textureIndex = (<span class="type">float</span>)i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (textureIndex == <span class="number">0.0f</span>) &#123;</span><br><span class="line">    textureIndex = (<span class="type">float</span>)s_Data.TextureSlotIndex;</span><br><span class="line">    s_Data.TextureSlots[s_Data.TextureSlotIndex] = texture;</span><br><span class="line">    s_Data.TextureSlotIndex++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在顶点数据数组设置当前顶点采样的纹理单元是 <strong>i</strong>，后续在第6步会将这个纹理槽号 <strong>i</strong> 传入到fragment阶段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// quad的左下角为起点</span></span><br><span class="line">s_Data.QuadVertexBufferPtr-&gt;Position = position;</span><br><span class="line">s_Data.QuadVertexBufferPtr-&gt;Color = color;</span><br><span class="line">s_Data.QuadVertexBufferPtr-&gt;TexCoord = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">s_Data.QuadVertexBufferPtr-&gt;TexIndex = textureIndex; <span class="comment">// 采样的纹理槽号</span></span><br><span class="line">s_Data.QuadVertexBufferPtr-&gt;TilingFactor = tilingFactor;</span><br><span class="line">s_Data.QuadVertexBufferPtr++;</span><br></pre></td></tr></table></figure><p>glsl相关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">in <span class="type">float</span> v_TexIndex;</span><br><span class="line">in <span class="type">float</span> v_TilingFactor;</span><br><span class="line"></span><br><span class="line">uniform sampler2D u_Textures[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">color = <span class="built_in">texture</span>(u_Textures[<span class="built_in">int</span>(v_TexIndex)], v_TexCoord * v_TilingFactor) * v_Color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Drawcall前，TextureSlots数组上存储已经加载的纹理，按照顺序依次<strong>绑定到对应的纹理槽</strong>上</p><p>这样就与第3、4步设置当前顶点采样的<strong>纹理槽号i</strong>是TextureSlots数组上的<strong>i号纹理</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::Flush</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对应i的texture绑定到i号纹理槽</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; s_Data.TextureSlotIndex; i++) &#123;</span><br><span class="line">        s_Data.TextureSlots[i]-&gt;<span class="built_in">Bind</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(s_Data.QuadVertexArray, s_Data.QuadIndexCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="四十一、优化批处理功能">四十一、优化批处理功能</h2><h4 id="前言-3">前言</h4><ul><li><p>前两节写的批处理留下来的问题</p><ol><li>批处理没有处理Quad旋转的函数</li><li>设计的顶点位置是基于自身空间的，没有经过transform变换位置，所以<strong>无旋转效果</strong></li></ol></li><li><p>此节所做</p><ol><li><p>处理Quad旋转函数</p></li><li><p>将顶点位置在<strong>Cpu</strong>上计算，通过transform矩阵（平移、缩放、旋转）变换到世界空间</p><p>与060之前不同，之前将顶点从局部空间转换到世界空间是在GPU(GLSL代码）上运行的。</p></li></ol></li><li><p>流程：</p><ol><li><p>给所有quad以原点为初始位置（<strong>局部空间</strong>）</p></li><li><p>再接受旋转角度，用初始位置transform矩阵 = 平移<em>旋转</em>缩放，再乘以顶点转换到<strong>世界空间</strong></p><p>（提下，<strong>写代码顺序</strong>是：平移<em>旋转</em>缩放，但<strong>解读顺序</strong>是：从右往左读，先进行缩放，再进行旋转最后平移)</p></li><li><p>将最终世界空间的位置上传到GLSL的顶点着色器阶段</p></li></ol></li></ul><h4 id="关键代码-3">关键代码</h4><p>Renderer2D.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::DrawrRotatedQuad</span><span class="params">(<span class="type">const</span> glm::vec3&amp; position, <span class="type">const</span> glm::vec2&amp; size, <span class="type">float</span> rotation, <span class="type">const</span> Ref&lt;Texture2D&gt;&amp; texture, <span class="type">float</span> tilingFactor, <span class="type">const</span> glm::vec4&amp; tintColor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> glm::vec4 color = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> textureIndex = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">1</span>; i &lt; s_Data.TextureSlotIndex; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*s_Data.TextureSlots[i].<span class="built_in">get</span>() == *texture.<span class="built_in">get</span>()) &#123;</span><br><span class="line">            textureIndex = (<span class="type">float</span>)i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (textureIndex == <span class="number">0.0f</span>) &#123;</span><br><span class="line">        textureIndex = (<span class="type">float</span>)s_Data.TextureSlotIndex;</span><br><span class="line">        s_Data.TextureSlots[s_Data.TextureSlotIndex] = texture;</span><br><span class="line">        s_Data.TextureSlotIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置transform</span></span><br><span class="line">    glm::mat4 tranform = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), position) *</span><br><span class="line">        glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(rotation), &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;) *</span><br><span class="line">        glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), &#123; size.x, size.y, <span class="number">1.0f</span> &#125;);</span><br><span class="line"></span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Position = tranform * s_Data.QuadVertexPosition[<span class="number">0</span>];</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Color = color;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexCoord = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexIndex = textureIndex;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TilingFactor = tilingFactor;</span><br><span class="line">    s_Data.QuadVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Position = tranform * s_Data.QuadVertexPosition[<span class="number">1</span>];</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Color = color;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexCoord = &#123; <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexIndex = textureIndex;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TilingFactor = tilingFactor;</span><br><span class="line">    s_Data.QuadVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Position = tranform * s_Data.QuadVertexPosition[<span class="number">2</span>];</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Color = color;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexCoord = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexIndex = textureIndex;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TilingFactor = tilingFactor;</span><br><span class="line">    s_Data.QuadVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Position = tranform * s_Data.QuadVertexPosition[<span class="number">3</span>];</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;Color = color;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexCoord = &#123; <span class="number">0.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TexIndex = textureIndex;</span><br><span class="line">    s_Data.QuadVertexBufferPtr-&gt;TilingFactor = tilingFactor;</span><br><span class="line">    s_Data.QuadVertexBufferPtr++;</span><br><span class="line"></span><br><span class="line">    s_Data.QuadIndexCount += <span class="number">6</span>;<span class="comment">// 每一个quad用6个索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sandbox2D.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnUpdate</span><span class="params">(HEngine::Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">float</span> rotation = <span class="number">0.0f</span>;</span><br><span class="line">rotation += ts * <span class="number">50.0f</span>;</span><br><span class="line"></span><br><span class="line">HEngine::Renderer2D::<span class="built_in">DrawRotatedQuad</span>(&#123; <span class="number">-1.0f</span>, <span class="number">0.0f</span> &#125;, &#123; <span class="number">0.8f</span>, <span class="number">0.8f</span> &#125;, <span class="number">45.0f</span>, &#123; <span class="number">0.9f</span>, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">        HEngine::Renderer2D::<span class="built_in">DrawRotatedQuad</span>(&#123; <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span> &#125;, &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;, rotation, m_CheckerboardTexture, <span class="number">20.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四十二、重置绘画缓存">四十二、重置绘画缓存</h2><h4 id="前言-4">前言</h4><ul><li><p>之前批处理设计带来的问题</p><p>当绘画的图形所占的内存<strong>超过</strong>我们得预先给定的空间，应该<strong>分两次</strong>Drawcall</p><p>第二次drawcall时候需要<strong>重置内存数据</strong>，以便能开始<strong>下一轮</strong>批处理。</p></li></ul><h4 id="此节代码思路">此节代码思路</h4><ol><li><p>需要知道当前渲染信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Renderer2D.h</span><br><span class="line"><span class="comment">// 当前渲染的信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Statistics</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> DrawCalls = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> QuadCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetTotalVertexCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> QuadCount * <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetTotalIndexCount</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> QuadCount * <span class="number">6</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>设置最大绘制数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Renderer2D.cpp</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Renderer2DData</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">uint32_t</span> MaxQuads = <span class="number">20000</span>;<span class="comment">// 一次绘制多少个Quad</span></span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    Renderer2D::Statistics Stats;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>当绘画的图形所占的内存<strong>超过</strong>我们得预先给定的空间，需要<strong>有判定</strong>（提交渲染和重置）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s_Data.QuadIndexCount &gt;= Renderer2DData::MaxIndices) &#123;<span class="comment">// 判断需要提交渲染和重置</span></span><br><span class="line">    <span class="built_in">FlushAndReset</span>();</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">s_Data.Stats.QuadCount++;</span><br></pre></td></tr></table></figure></li><li><p>当一次渲染超过这个数量，分两次渲染，第二次渲染时候需要<strong>重置内存数据</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存不够为了分批渲染要做的drawcall绘制和重置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::FlushAndReset</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">EndScene</span>();</span><br><span class="line"><span class="comment">//重置</span></span><br><span class="line">    s_Data.QuadIndexCount = <span class="number">0</span>;</span><br><span class="line">    s_Data.QuadVertexBufferPtr = s_Data.QuadVertexBufferBase;</span><br><span class="line">    s_Data.TextureSlotIndex = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> Renderer2D::EndScene&#123;</span><br><span class="line">    <span class="comment">// 计算上传大小</span></span><br><span class="line">    <span class="type">uint32_t</span> dataSize = (<span class="type">uint8_t</span>*)s_Data.QuadVertexBufferPtr - (<span class="type">uint8_t</span>*)s_Data.QuadVertexBufferBase;</span><br><span class="line">    s_Data.QuadVertexBuffer-&gt;<span class="built_in">SetData</span>(s_Data.QuadVertexBufferBase, dataSize);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Flush</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::Flush</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Bind textures</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; s_Data.TextureSlotIndex; i++)</span><br><span class="line">        s_Data.TextureSlots[i]-&gt;<span class="built_in">Bind</span>(i);</span><br><span class="line"></span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(s_Data.QuadVertexArray, s_Data.QuadIndexCount);</span><br><span class="line">    s_Data.Stats.DrawCalls++;</span><br><span class="line">&#125;</span><br><span class="line">.........................</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLVertexBuffer::SetData</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">uint32_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="number">0</span>, size, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用绘制Render2D API代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnUpdate</span><span class="params">(HEngine::Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_PROFILE_FUNCTION</span>();</span><br><span class="line"></span><br><span class="line">    m_CameraController.<span class="built_in">OnUpdate</span>(ts);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染信息初始化</span></span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">ResetStats</span>();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">BeginScene</span>(m_CameraController.<span class="built_in">GetCamera</span>());</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">DrawrRotatedQuad</span>(&#123; <span class="number">1.0f</span>, <span class="number">0.5f</span> &#125;, &#123; <span class="number">0.8f</span>, <span class="number">0.8f</span> &#125;,<span class="number">30.0f</span>, m_FlatColor);</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">DrawQuad</span>(&#123; <span class="number">-1.0f</span>, <span class="number">0.0f</span> &#125;, &#123; <span class="number">0.8f</span>, <span class="number">0.8f</span> &#125;, m_FlatColor);</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">DrawQuad</span>(&#123; <span class="number">0.5f</span>, <span class="number">-0.5f</span> &#125;, &#123; <span class="number">0.5f</span>, <span class="number">0.8f</span> &#125;, &#123;<span class="number">0.2f</span>, <span class="number">0.8f</span>, <span class="number">0.9f</span>, <span class="number">1.0f</span>&#125;);</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">DrawQuad</span>(&#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-0.1f</span> &#125;, &#123; <span class="number">20.0f</span>, <span class="number">20.0f</span> &#125;, m_SquareTexture, <span class="number">10.0f</span>);</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">DrawrRotatedQuad</span>(&#123; <span class="number">-0.5f</span>, <span class="number">-1.5f</span>, <span class="number">0.0f</span> &#125;, &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;, rotation, m_SquareTexture, <span class="number">20.0f</span>);</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">EndScene</span>();</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="四十三、-使用ImGui渲染纹理">四十三、  使用ImGui渲染纹理</h2><h4 id="前言-5">前言</h4><ul><li>接下来想做的<ol><li>使HEngine成为一个独立的工具</li><li>可以打开成窗口应用程序</li><li>可以操作程序添加场景</li><li>在场景上放入精灵、实体，再写脚本语言给实体添加一些行为</li><li>以及给实体添加组件</li><li>然后可以导出为游戏执行文件，可以在编辑器之外运行</li></ol></li></ul><h4 id="Dockspace">Dockspace</h4><ul><li><p>什么是dockspace</p><p>imgui提供的可以停靠在窗口上，能够实现重新布局窗口的功能。</p></li><li><p><strong>缺点</strong></p><ul><li><p>问题所在</p><p>使用了Imgui的dockspace，OpenGL绘制的场景不见了,因为imgui接管了窗口</p></li><li><p>如何解决</p><p>让Opengl渲染到<strong>framebuffer</strong>帧缓冲中，作为texture纹理，然后Imgui再渲染这个texture。</p></li><li><h4 id="代码：">代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnImgGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.....</span><br><span class="line">    &#123;</span><br><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Settings&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> stats = HEngine::Renderer2D::<span class="built_in">GetStats</span>();</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Renderer2D Stats:&quot;</span>);</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Draw Calls: %d&quot;</span>, stats.DrawCalls);</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Quads: %d&quot;</span>, stats.QuadCount);</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Vertices: %d&quot;</span>, stats.<span class="built_in">GetTotalVertexCount</span>());</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Indices: %d&quot;</span>, stats.<span class="built_in">GetTotalIndexCount</span>());</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">ColorEdit4</span>(<span class="string">&quot;Square Color&quot;</span>, glm::<span class="built_in">value_ptr</span>(m_SquareColor));</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> textureID = m_CheckerboardTexture-&gt;<span class="built_in">GetRendererID</span>();</span><br><span class="line">ImGui::<span class="built_in">Image</span>((<span class="type">void</span>*)textureID, ImVec2&#123; <span class="number">256.0f</span>, <span class="number">256.0f</span> &#125;);</span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Settings&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> stats = HEngine::Renderer2D::<span class="built_in">GetStats</span>();</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Renderer2D Stats:&quot;</span>);</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Draw Calls: %d&quot;</span>, stats.DrawCalls);</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Quads: %d&quot;</span>, stats.QuadCount);</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Vertices: %d&quot;</span>, stats.<span class="built_in">GetTotalVertexCount</span>());</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Indices: %d&quot;</span>, stats.<span class="built_in">GetTotalIndexCount</span>());</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">ColorEdit4</span>(<span class="string">&quot;Square Color&quot;</span>, glm::<span class="built_in">value_ptr</span>(m_SquareColor));</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> textureID = m_CheckerboardTexture-&gt;<span class="built_in">GetRendererID</span>();</span><br><span class="line">ImGui::<span class="built_in">Image</span>((<span class="type">void</span>*)textureID, ImVec2&#123; <span class="number">256.0f</span>, <span class="number">256.0f</span> &#125;);</span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="四十四、实现自定义帧缓冲">四十四、实现自定义帧缓冲</h2><h4 id="前言-6">前言</h4><p>帧缓冲（我的理解）</p><ol><li>可以将OpenGL渲染的场景放在这个帧缓冲中</li><li>然后可以把这个帧缓冲当做是颜色或者纹理采样区（取决于帧缓冲附加的缓冲<strong>附件类型</strong>）</li><li>在ImGui把这个帧缓冲当做颜色纹理渲染出来，就在ImGui界面上显示了原本应显示在屏幕上的场景</li></ol><h4 id="代码流程">代码流程</h4><ul><li><p>创建帧缓冲并<strong>附加</strong>纹理、深度与模板缓冲纹理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLFramebuffer::Invalidate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.创建帧缓冲</span></span><br><span class="line">    <span class="built_in">glCreateFramebuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, m_RendererID); <span class="comment">// 绑定这个帧缓冲</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.创建纹理</span></span><br><span class="line">    <span class="built_in">glCreateTextures</span>(GL_TEXTURE_2D, <span class="number">1</span>, &amp;m_ColorAttachment);;</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_ColorAttachment);</span><br><span class="line">    <span class="built_in">glTexImage2D</span>(GL_TEXTURE_2D, <span class="number">0</span>, GL_RGBA8, m_Specification.Width, m_Specification.Height, <span class="number">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">    <span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.1纹理附加到帧缓冲</span></span><br><span class="line">    <span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, m_ColorAttachment, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.创建深度模板缓冲纹理附加到帧缓冲中</span></span><br><span class="line">    <span class="built_in">glCreateTextures</span>(GL_TEXTURE_2D, <span class="number">1</span>, &amp;m_DepthAttachment);;</span><br><span class="line">    <span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, m_DepthAttachment);</span><br><span class="line">    <span class="built_in">glTexStorage2D</span>(GL_TEXTURE_2D, <span class="number">1</span>, GL_DEPTH24_STENCIL8, m_Specification.Width, m_Specification.Height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2深度模板缓冲纹理附加到帧缓冲中</span></span><br><span class="line">    <span class="built_in">glFramebufferTexture2D</span>(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, m_DepthAttachment, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="built_in">glCheckFramebufferStatus</span>(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE, <span class="string">&quot;帧缓冲未创建完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给创建的帧缓冲写入数据</p><ol><li>绑定自定义的帧缓冲</li><li>正常渲染图形，将本由OpenGL渲染在屏幕上的图像写入到自定义的帧缓冲中</li><li>解绑帧缓冲</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sandbox2D::OnUpdate</span><span class="params">(HEngine::Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HEngine::Renderer2D::<span class="built_in">ResetStats</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        m_Framebuffer-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">        HEngine::RenderCommand::<span class="built_in">SetClearColor</span>(&#123; <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1</span> &#125;);</span><br><span class="line">        HEngine::RenderCommand::<span class="built_in">Clear</span>();</span><br><span class="line">        HEngine::Renderer2D::<span class="built_in">DrawrRotatedQuad</span>(&#123; <span class="number">1.0f</span>, <span class="number">0.5f</span> &#125;, &#123; <span class="number">0.8f</span>, <span class="number">0.8f</span> &#125;,<span class="number">30.0f</span>, m_FlatColor);</span><br><span class="line">        HEngine::Renderer2D::<span class="built_in">DrawQuad</span>(&#123; <span class="number">-1.0f</span>, <span class="number">0.0f</span> &#125;, &#123; <span class="number">0.8f</span>, <span class="number">0.8f</span> &#125;, m_FlatColor);</span><br><span class="line">       .......</span><br><span class="line">        <span class="comment">// 3.解绑帧缓冲</span></span><br><span class="line">        m_Framebuffer-&gt;<span class="built_in">Unbind</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Imgui渲染自定义的帧缓冲</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Settings&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> stats = HEngine::Renderer2D::<span class="built_in">GetStats</span>();</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Renderer2D Stats:&quot;</span>);</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Draw Calls: %d&quot;</span>, stats.DrawCalls);</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Quads: %d&quot;</span>, stats.QuadCount);</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Vertices: %d&quot;</span>, stats.<span class="built_in">GetTotalVertexCount</span>());</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Indices: %d&quot;</span>, stats.<span class="built_in">GetTotalIndexCount</span>());</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">ColorEdit4</span>(<span class="string">&quot;Square Color&quot;</span>, glm::<span class="built_in">value_ptr</span>(m_SquareColor));</span><br><span class="line"><span class="comment">//在执行完Invalidate方法后，所有渲染内容都会存储到这个FBO的附件（ColorAttachment）中</span></span><br><span class="line"><span class="comment">//此时只要渲染这个纹理就会得出原来屏幕的画面</span></span><br><span class="line"><span class="type">uint32_t</span> textureID = m_Framebuffer-&gt;<span class="built_in">GetColorAttachmentRendererID</span>();</span><br><span class="line">ImGui::<span class="built_in">Image</span>((<span class="type">void</span>*)textureID, ImVec2&#123; <span class="number">1280</span>, <span class="number">720</span> &#125;, ImVec2&#123; <span class="number">0</span>, <span class="number">1</span>&#125;, ImVec2&#123; <span class="number">1</span>, <span class="number">0</span> &#125;);</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br></pre></td></tr></table></figure></li></ul><h4 id="BUG：ImGui上显示OpenGL渲染的图像">BUG：ImGui上显示OpenGL渲染的图像</h4><ul><li><p>Bug说明</p><p>可视化界面的wasd摄像机移动，显示相反（按a却成d的效果）。</p></li><li><p>Bug分析</p><p>由于imgui的uv默认是左下角为01，右下角为11，左上角为00，右上角是10（起始点在左上角）</p><p>而我们绘制的quad的uv是左下角为00，右下角10，左上角01，右上角11（起始点在左下角）</p></li><li><p>调整</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    ImVec2(0, 1):设置左上角点的uv是 0 1</span></span><br><span class="line"><span class="comment">    ImVec2(1, 0):设置右下角点的uv是 1 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ImGui::<span class="built_in">Image</span>((<span class="type">void</span>*)textureID, <span class="built_in">ImVec2</span>( <span class="number">1280</span>, <span class="number">720</span> ), <span class="built_in">ImVec2</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">ImVec2</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure></li></ul><p>补充：创建HEngine-Editor新项目并设置为启动项目, 用来做<strong>可视化界面</strong>，构建游戏，原先Sandbox项目的操作移动到Editor里面</p><hr><h2 id="四十五、调整视口大小处理">四十五、调整视口大小处理</h2><h4 id="前言-7">前言</h4><ul><li>此节目标<ul><li>实现调整<strong>ImGui视口</strong>大小后，摄像机、绘图的区域、帧缓冲纹理也相应调整</li></ul></li></ul><h4 id="代码流程-2">代码流程</h4><ul><li><p>EditorLayer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ImVec2 viewportPanelSize = ImGui::<span class="built_in">GetContentRegionAvail</span>();</span><br><span class="line"><span class="keyword">if</span> (m_ViewportSize != *((glm::vec2*)&amp;viewportPanelSize)) &#123; <span class="comment">// 如果改变了窗口大小</span></span><br><span class="line">    <span class="comment">// 调整帧缓冲区</span></span><br><span class="line">    m_Framebuffer-&gt;<span class="built_in">Resize</span>((<span class="type">uint32_t</span>)viewportPanelSize.x, (<span class="type">uint32_t</span>)viewportPanelSize.y);</span><br><span class="line">    m_ViewportSize = &#123; viewportPanelSize.x, viewportPanelSize.y &#125;;</span><br><span class="line">    <span class="comment">// 调整摄像机</span></span><br><span class="line">    m_CameraController.<span class="built_in">OnResize</span>(viewportPanelSize.x, viewportPanelSize.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> textureID = m_Framebuffer-&gt;<span class="built_in">GetColorAttachmentRendererID</span>();</span><br><span class="line">ImGui::<span class="built_in">Image</span>((<span class="type">void</span>*)textureID, <span class="built_in">ImVec2</span>(m_ViewportSize.x, m_ViewportSize.y), <span class="built_in">ImVec2</span>(<span class="number">0</span>, <span class="number">1</span>), <span class="built_in">ImVec2</span>(<span class="number">1</span>, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>OpenGLFramebuffer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLFramebuffer::Resize</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_Specification.Width = width;</span><br><span class="line">    m_Specification.Height = height;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Invalidate</span>(); <span class="comment">//重新生成帧缓冲</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下次帧缓冲被绑定时，OpenGL视口大小被设置为imgui视口大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLFramebuffer::Bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, m_RendererID);</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>, <span class="number">0</span>, m_Specification.Width, m_Specification.Height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="四十六、事件触发判定优化">四十六、事件触发判定优化</h2><p>发现一个bug，如鼠标放在ImGui的Settings窗口区域滑动鼠标滚轮，渲染方块的Viewport窗口也会响应，这就有问题了，应该是我鼠标放在窗口区域内并且点击了代表我选择这个窗口了，才能响应事件</p><p>解决方法：由ImGui视口能获取<strong>焦点</strong>和<strong>鼠标停留</strong>bool值，用这两个bool值来处理</p><h4 id="代码：-2">代码：</h4><p>EditorLayer.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnUpdate</span><span class="params">(HEngine::Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_ViewportFocused)<span class="comment">//只有鼠标选中当前区域才能触发摄像机移动等事件</span></span><br><span class="line">        m_CameraController.<span class="built_in">OnUpdate</span>(ts);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ViewportFocused = ImGui::<span class="built_in">IsWindowFocused</span>();</span><br><span class="line">    m_ViewportHovered = ImGui::<span class="built_in">IsWindowHovered</span>();</span><br><span class="line">    Application::<span class="built_in">Get</span>().<span class="built_in">GetImGuiLayer</span>()-&gt;<span class="built_in">BlockEvents</span>(!m_ViewportFocused || !m_ViewportHovered);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImGuiLayer.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_BlockEvents)<span class="comment">//在鼠标既不在渲染窗口位置也没点击选中时才能响应ImGui其他窗口</span></span><br><span class="line">&#123;</span><br><span class="line">    ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">    e.Handled |= e.<span class="built_in">IsInCategory</span>(EventCategoryMouse) &amp; io.WantCaptureMouse;</span><br><span class="line">    e.Handled |= e.<span class="built_in">IsInCategory</span>(EventCategoryKeyboard) &amp; io.WantCaptureKeyboard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四十七、设计实体组件系统">四十七、设计实体组件系统</h2><p>关于ECS的介绍单独写了比较详细的文章，<a href="https://winterdev.cn/posts/b6d9ed88">实体组件系统(ECS)</a></p><p>HEngine选择使用提供ECS模式的Entt库来实现我们的实体组件系统,Entt相关的内容可以直接看对应的github仓库的介绍,这里是他的<a href="https://github.com/skypjack/entt/wiki">Wiki</a></p><p>该库所有的内容，应该都放到一个叫<code>entt.hpp</code>的文件里了，我看了下，这个文件非常大，一共有17600行，就把它当头文件用就行了</p><h4 id="代码-3">代码:</h4><p>创建Scene类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;entt.hpp&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Scene</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Scene</span>();</span><br><span class="line">~<span class="built_in">Scene</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">entt::entity <span class="title">CreateEntity</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TEMP</span></span><br><span class="line"><span class="function">entt::registry&amp; <span class="title">Reg</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Registry; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(Timestep ts)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">entt::registry m_Registry;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scene.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于后面的Callback例子, 当Transform组件被创建时调用, 会加到entity上</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">OnTransformConstruct</span><span class="params">(entt::registry&amp; registry, entt::entity entity)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个registry, 可以把它理解为vector&lt;entity&gt;, 也就是包含所有entity的容器</span></span><br><span class="line">entt::registry m_Registry;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个entity, entt::entity其实是uint32_t</span></span><br><span class="line">entt::entity entity = m_Registry.<span class="built_in">create</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// emplace等同于AddComponent, 这里给entity添加TransformComponent</span></span><br><span class="line">m_Registry.<span class="built_in">emplace</span>&lt;TransformComponent&gt;(entity, glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// entt提供的Callback, 当TransformComponent被创建时, 调用OnTransformConstruct函数</span></span><br><span class="line">m_Registry.<span class="built_in">on_construct</span>&lt;TransformComponent&gt;().<span class="built_in">connect</span>&lt;&amp;OnTransformConstruct&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断entity上是否有TransformComponent</span></span><br><span class="line"><span class="keyword">if</span> (m_Registry.<span class="built_in">all_of</span>&lt;TransformComponent&gt;(entity))</span><br><span class="line"><span class="comment">// 从entity上get TransformComponent</span></span><br><span class="line">TransformComponent&amp; transform = m_Registry.<span class="built_in">get</span>&lt;TransformComponent&gt;(entity);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有带有TransformComponent的entity数组</span></span><br><span class="line"><span class="keyword">auto</span> view = m_Registry.<span class="built_in">view</span>&lt;TransformComponent&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> entity : view)</span><br><span class="line">&#123;</span><br><span class="line">TransformComponent&amp; transform = view.<span class="built_in">get</span>&lt;TransformComponent&gt;(entity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// group用来获取同时满足拥有多个Component的Entity数组</span></span><br><span class="line"><span class="keyword">auto</span> group = m_Registry.<span class="built_in">group</span>&lt;TransformComponent&gt;(entt::get&lt;SpriteRendererComponent&gt;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> entity : group)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; [transform, spriteRenderer] = group.<span class="built_in">get</span>&lt;TransformComponent, SpriteRendererComponent&gt;(entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComPonents.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TransformComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    glm::mat4 Transform&#123; <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TransformComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">TransformComponent</span>(<span class="type">const</span> TransformComponent&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">TransformComponent</span>(<span class="type">const</span> glm::mat4&amp; transform)</span><br><span class="line">    : <span class="built_in">Transform</span>(transform) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> glm::mat4&amp; () &#123; <span class="keyword">return</span> Transform; &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">const</span> glm::mat4&amp; () <span class="type">const</span> &#123; <span class="keyword">return</span> Transform; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SpriteRendererComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    glm::vec4 Color&#123; <span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SpriteRendererComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SpriteRendererComponent</span>(<span class="type">const</span> SpriteRendererComponent&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">SpriteRendererComponent</span>(<span class="type">const</span> glm::vec4&amp; color)</span><br><span class="line">        :<span class="built_in">Color</span>(color) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="四十八、添加Entity类">四十八、添加Entity类</h2><h4 id="前言-8">前言</h4><ul><li><p>此节目的</p><ul><li>创建出Entity实体类，作为中介连接场景与组件，能<strong>添加、删除</strong>组件</li></ul></li><li><p>思考Entt的API优缺点来设计出Scene、Entity类，之前学习到一个思路，设计一个API的时候应该先想象他需要拥有什么功能，然后再根据列出来的功能逐个实现就好了</p><p>游戏引擎开发人员的角度，是场景拥有实体、<strong>场景给实体添加组件</strong>，所以以下调用Entt代码是合理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 场景给square实体添加组件</span></span><br><span class="line">m_ActiveScene-&gt;<span class="built_in">Reg</span>().<span class="built_in">emplace</span>&lt;TransformComponent&gt;(square); <span class="comment">// 先要获取注册表才能添加组件</span></span><br><span class="line">m_ActiveScene-&gt;<span class="built_in">Reg</span>().<span class="built_in">emplace</span>&lt;SpriteRendererComponent&gt;(square, glm::<span class="built_in">vec4</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure><p>但是，这代码太长了，引擎开发人员应该站在<strong>游戏开发人员角度</strong>思考</p><ol><li>场景虽然拥有实体，可以获取实体给它添加组件</li><li><strong>实体也应拥有组件</strong>，只需简单的考虑<strong>实体添加组件</strong>这个行为，而<strong>忽略场景这个东西</strong></li><li>这有利于我们简化代码，目标是简化成Unity那样给gameobject添加组件的函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原先：场景给square实体添加组件</span></span><br><span class="line">m_ActiveScene-&gt;<span class="built_in">Reg</span>().<span class="built_in">emplace</span>&lt;TransformComponent&gt;(square); <span class="comment">// 先要获取注册表才能添加组件</span></span><br><span class="line">m_ActiveScene-&gt;<span class="built_in">Reg</span>().<span class="built_in">emplace</span>&lt;SpriteRendererComponent&gt;(square, glm::<span class="built_in">vec4</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"><span class="comment">// 化简为：square实体添加组件，忽略场景</span></span><br><span class="line">square.<span class="built_in">AddComponent</span>&lt;TransformComponent&gt;();</span><br><span class="line">square.<span class="built_in">AddComponent</span>&lt;SpriteRendererComponent&gt;(glm::<span class="built_in">vec4</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>));</span><br></pre></td></tr></table></figure></li></ul><h4 id="代码-4">代码</h4><ul><li><p>Entity.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Entity</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">Entity</span>(entt::entity handle, Scene* scene);</span><br><span class="line"><span class="built_in">Entity</span>(<span class="type">const</span> Entity&amp; other) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">T&amp; <span class="title">AddComponent</span><span class="params">(Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(!<span class="built_in">HasComponent</span>&lt;T&gt;(), <span class="string">&quot;Entity already has component!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> m_Scene-&gt;m_Registry.<span class="built_in">emplace</span>&lt;T&gt;(m_EntityHandle, std::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp; <span class="title">GetComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(<span class="built_in">HasComponent</span>&lt;T&gt;(), <span class="string">&quot;Entity does not have component!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> m_Scene-&gt;m_Registry.<span class="built_in">get</span>&lt;T&gt;(m_EntityHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HasComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Scene-&gt;m_Registry.<span class="built_in">all_of</span>&lt;T&gt;(m_EntityHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(<span class="built_in">HasComponent</span>&lt;T&gt;(), <span class="string">&quot;Entity does not have component!&quot;</span>);</span><br><span class="line">m_Scene-&gt;m_Registry.<span class="built_in">remove</span>&lt;T&gt;(m_EntityHandle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (<span class="type">uint32_t</span>)m_EntityHandle != <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">entt::entity m_EntityHandle&#123; null &#125;;</span><br><span class="line">Scene* m_Scene = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Entity.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">Entity::<span class="built_in">Entity</span>(entt::entity handle, Scene* scene)</span><br><span class="line">: <span class="built_in">m_EntityHandle</span>(handle), <span class="built_in">m_Scene</span>(scene)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Scene.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">entt::entity <span class="title">CreateEntity</span><span class="params">()</span></span>;<span class="comment">//删除</span></span><br><span class="line"><span class="function">Entity <span class="title">CreateEntity</span><span class="params">(<span class="type">const</span> std::string&amp; name = std::string())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Entity</span>;</span><br></pre></td></tr></table></figure><p>Scene.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entity <span class="title">Scene::CreateEntity</span><span class="params">(<span class="type">const</span> std::string&amp; name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Entity entity = &#123; m_Registry.<span class="built_in">create</span>(), <span class="keyword">this</span> &#125;;</span><br><span class="line">    entity.<span class="built_in">AddComponent</span>&lt;TransformComponent&gt;();</span><br><span class="line">    <span class="keyword">auto</span>&amp; tag = entity.<span class="built_in">AddComponent</span>&lt;TagComponent&gt;();</span><br><span class="line">    tag.Tag = name.<span class="built_in">empty</span>() ? <span class="string">&quot;Entity&quot;</span> : name;</span><br><span class="line">    <span class="keyword">return</span> entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>EditorLayer.cpp使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ImGui::<span class="built_in">Separator</span>();</span><br><span class="line"><span class="keyword">auto</span>&amp; tag = m_SquaerEntity.<span class="built_in">GetComponent</span>&lt;TagComponent&gt;().Tag;</span><br><span class="line">ImGui::<span class="built_in">Text</span>(<span class="string">&quot;%s&quot;</span>, tag.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp; squareColor = m_SquaerEntity.<span class="built_in">GetComponent</span>&lt;SpriteRendererComponent&gt;().Color;</span><br><span class="line">ImGui::<span class="built_in">ColorEdit4</span>(<span class="string">&quot;Square Color&quot;</span>, glm::<span class="built_in">value_ptr</span>(squareColor));</span><br><span class="line">ImGui::<span class="built_in">Separator</span>();</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="四十九、添加摄像头组件">四十九、添加摄像头组件</h2><ul><li><p>此节内容</p><ul><li><p>设计一个<strong>Camera组件</strong></p></li><li><p>这个Camera组件需拥有<strong>Camera类</strong>指针</p><p>Camera类拥有的属性与行为</p><ol><li>设置正交投影projection矩阵</li><li>是否主相机</li><li>获取projection投影矩阵</li></ol></li></ul></li></ul><h4 id="Camera类与Camera组件设计">Camera类与Camera组件设计</h4><ul><li><p>创建Camera.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Camera</span>(<span class="type">const</span> glm::mat4&amp; projection)</span><br><span class="line">: <span class="built_in">m_Projection</span>(projection) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> glm::mat4&amp; <span class="title">GetProjection</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Projection; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">glm::mat4 m_Projection;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Components.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CameraComponent</span> &#123;</span><br><span class="line">    Camera camera;</span><br><span class="line">    <span class="type">bool</span> primary = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CameraComponent</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">CameraComponent</span>(<span class="type">const</span> CameraComponent&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">CameraComponent</span>(<span class="type">const</span> glm::mat4 &amp; projection)</span><br><span class="line">        : <span class="built_in">camera</span>(projection) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="场景切换到主摄像机视角代码流程">场景切换到主摄像机视角代码流程</h4><ul><li><p>EditorLayer层<strong>添加</strong>一个实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entity m_CameraEntity;</span><br><span class="line">Entity m_SecondCamera;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> m_PrimaryCamera = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li><li><p>EditorLayer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m_CameraEntity = m_ActiveScene-&gt;<span class="built_in">CreateEntity</span>(<span class="string">&quot;Camera Entity&quot;</span>);</span><br><span class="line">m_CameraEntity.<span class="built_in">AddComponent</span>&lt;CameraComponent&gt;(glm::<span class="built_in">ortho</span>(<span class="number">-16.0f</span>, <span class="number">16.0f</span>, <span class="number">-9.0f</span>, <span class="number">9.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>));</span><br><span class="line"></span><br><span class="line">m_SecondCamera = m_ActiveScene-&gt;<span class="built_in">CreateEntity</span>(<span class="string">&quot;Clip-Space Entity&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span>&amp; cc =  m_SecondCamera.<span class="built_in">AddComponent</span>&lt;CameraComponent&gt;(glm::<span class="built_in">ortho</span>(<span class="number">-1.0f</span>,<span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">1.0f</span>,<span class="number">-1.0f</span>,<span class="number">1.0f</span>));</span><br><span class="line">cc.Primary = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>在scene onupdate方法中<strong>寻找主摄像机</strong>，以及获取主摄像机的transform用来计算视图矩阵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::OnUpdate</span><span class="params">(Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Camera* mainCamera = <span class="literal">nullptr</span>;</span><br><span class="line">    glm::mat4* cameraTransform = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> group = m_Registry.<span class="built_in">view</span>&lt;TransformComponent,CameraComponent&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> entity : group)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; [transform, camera] = group.<span class="built_in">get</span>&lt;TransformComponent, CameraComponent&gt;(entity);</span><br><span class="line">            <span class="keyword">if</span> (camera.Primary)</span><br><span class="line">            &#123;</span><br><span class="line">                mainCamera = &amp;camera.Camera;</span><br><span class="line">                cameraTransform = &amp;transform.Transform;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mainCamera)</span><br><span class="line">    &#123;</span><br><span class="line">    Renderer2D::<span class="built_in">BeginScene</span>(mainCamera-&gt;<span class="built_in">GetProjection</span>(), *cameraTransform);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> group = m_Registry.group &lt; TransformComponent&gt;(entt::get&lt;SpriteRendererComponent&gt;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> entity : group)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; [transform, sprite] = group.<span class="built_in">get</span>&lt;TransformComponent, SpriteRendererComponent&gt;(entity);</span><br><span class="line"></span><br><span class="line">        Renderer2D::<span class="built_in">DrawQuad</span>(transform, sprite.Color);</span><br><span class="line">    &#125;</span><br><span class="line">    Renderer2D::<span class="built_in">EndScene</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Renderer2D.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer2D::BeginScene</span><span class="params">(<span class="type">const</span> Camera&amp; camera, <span class="type">const</span> glm::mat4&amp; transform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_PROFILE_FUNCTION</span>();</span><br><span class="line">    glm::mat4 viewProj = camera.<span class="built_in">GetProjection</span>() * glm::<span class="built_in">inverse</span>(transform);</span><br><span class="line"></span><br><span class="line">    s_Data.TextureShader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    s_Data.TextureShader-&gt;<span class="built_in">SetMat4</span>(<span class="string">&quot;u_ViewProjection&quot;</span>, viewProj);</span><br><span class="line"></span><br><span class="line">    s_Data.QuadIndexCount = <span class="number">0</span>;</span><br><span class="line">    s_Data.QuadVertexBufferPtr = s_Data.QuadVertexBufferBase;</span><br><span class="line"></span><br><span class="line">    s_Data.TextureSlotIndex = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="五十、-Scene-Camera">五十、 Scene Camera</h2><ul><li><p>此节目的</p><p>当ImGui视口大小发生改变时，场景中所有实体所拥有的摄像机都能正确的设置<strong>宽高比</strong>，<strong>使图像不会变形</strong>。</p><ul><li>此节所作<ul><li>新建了一个SceneCamera类继承自Camera类，作为摄像机组件的摄像机类属性</li><li>视口改变，场景内所有摄像机都能更新宽高比</li></ul></li></ul></li></ul><h4 id="代码流程-3">代码流程</h4><ul><li><p>修改了Camera.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span> </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Camera</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Camera</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">glm::mat4 m_Projection = glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新添加了SceneCamera</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SceneCamera</span> : <span class="keyword">public</span> Camera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SceneCamera</span>();</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">SceneCamera</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetOrthographic</span><span class="params">(<span class="type">float</span> size, <span class="type">float</span> nearClip, <span class="type">float</span> farClip)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetViewportSize</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetOrthographicSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_OrthographicSize; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetOrthographicSize</span><span class="params">(<span class="type">float</span> size)</span> </span>&#123; m_OrthographicSize = size;  <span class="built_in">RecalculateProjection</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RecalculateProjection</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> m_OrthographicSize = <span class="number">10.0f</span>;</span><br><span class="line"><span class="type">float</span> m_OrthographicNear = <span class="number">-1.0f</span>, m_OrthographicFar = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> m_AspectRatio = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">SceneCamera::<span class="built_in">SceneCamera</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">RecalculateProjection</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneCamera::SetOrthographic</span><span class="params">(<span class="type">float</span> size, <span class="type">float</span> nearClip, <span class="type">float</span> farClip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_OrthographicSize = size;</span><br><span class="line">m_OrthographicNear = nearClip;</span><br><span class="line">m_OrthographicFar = farClip;</span><br><span class="line"><span class="built_in">RecalculateProjection</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneCamera::SetViewportSize</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_AspectRatio = (<span class="type">float</span>)width / (<span class="type">float</span>)height;</span><br><span class="line"><span class="built_in">RecalculateProjection</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneCamera::RecalculateProjection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">float</span> orthoLeft = -m_OrthographicSize * m_AspectRatio * <span class="number">0.5f</span>;</span><br><span class="line"><span class="type">float</span> orhoRight = m_OrthographicSize * m_AspectRatio * <span class="number">0.5f</span>;</span><br><span class="line"><span class="type">float</span> orthoBottom = -m_OrthographicSize * <span class="number">0.5f</span>;</span><br><span class="line"><span class="type">float</span> orthoTop = m_OrthographicSize * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">m_Projection = glm::<span class="built_in">ortho</span>(orthoLeft, orhoRight,</span><br><span class="line">orthoBottom, orthoTop, m_OrthographicNear, m_OrthographicFar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scene.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::OnViewportResize</span><span class="params">(<span class="type">uint32_t</span> width, <span class="type">uint32_t</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_ViewportWidth = width;</span><br><span class="line">    m_ViewportHeight = height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Resize our non-FixedAspectRatio cameras</span></span><br><span class="line">    <span class="keyword">auto</span> view = m_Registry.<span class="built_in">view</span>&lt;CameraComponent&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> entity : view)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; cameraComponent = view.<span class="built_in">get</span>&lt;CameraComponent&gt;(entity);</span><br><span class="line">        <span class="keyword">if</span> (!cameraComponent.FixedAspectRatio)</span><br><span class="line">            cameraComponent.Camera.<span class="built_in">SetViewportSize</span>(width, height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EditorLayer.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnUpdate</span><span class="params">(Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (FramebufferSpecification spec = m_Framebuffer-&gt;<span class="built_in">GetSpecification</span>();</span><br><span class="line">        m_ViewportSize.x &gt; <span class="number">0.0f</span> &amp;&amp; m_ViewportSize.y &gt; <span class="number">0.0f</span> &amp;&amp; <span class="comment">//zero sized framebuffer is invalid</span></span><br><span class="line">    (spec.Width != m_ViewportSize.x || spec.Height != m_ViewportSize.y))</span><br><span class="line">    &#123;</span><br><span class="line">        m_Framebuffer-&gt;<span class="built_in">Resize</span>((<span class="type">uint32_t</span>)m_ViewportSize.x, (<span class="type">uint32_t</span>)m_ViewportSize.y);</span><br><span class="line">        m_CameraController.<span class="built_in">OnResize</span>(m_ViewportSize.x, m_ViewportSize.y);</span><br><span class="line"></span><br><span class="line">        m_ActiveScene-&gt;<span class="built_in">OnViewportResize</span>((<span class="type">uint32_t</span>)m_ViewportSize.x, (<span class="type">uint32_t</span>)m_ViewportSize.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; camera = m_SecondCamera.<span class="built_in">GetComponent</span>&lt;CameraComponent&gt;().Camera;</span><br><span class="line">        <span class="type">float</span> orhoSize = camera.<span class="built_in">GetOrthographicSize</span>();</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Second Camera OrthO Size&quot;</span>, &amp;orhoSize))</span><br><span class="line">            camera.<span class="built_in">SetOrthographicSize</span>(orhoSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="五十一、提供C-脚本功能">五十一、提供C++脚本功能</h2><h4 id="前言-9">前言</h4><ul><li><p>此节目标</p><p>需要给实体添加<strong>脚本组件</strong>Native Scripting，实现可以用cpp语言来编写脚本</p></li><li><p>此节所作</p><p>给摄像机实体添加脚本组件，在引擎内的Scene视口中引擎人员和游戏开发人员都可以<strong>控制摄像机移动</strong></p></li><li><p>为什么需要添加cpp脚本组件</p><ul><li>引擎开发人员需要给引擎某个实体<strong>添加脚本功能</strong>，从而实现<strong>测试时候</strong>能运行想要的脚本功能。</li></ul></li></ul><h4 id="实现在Scene视口操作摄像机移动">实现在Scene视口操作摄像机移动</h4><ul><li><p>EditorLayer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CameraController</span> : <span class="keyword">public</span> ScriptableEntity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnCreate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnDestroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(Timestep ts)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; transform = <span class="built_in">GetComponent</span>&lt;TransformComponent&gt;().Transform;</span><br><span class="line">        <span class="type">float</span> speed = <span class="number">5.0f</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(KeyCode::A))</span><br><span class="line">            transform[<span class="number">3</span>][<span class="number">0</span>] -= speed * ts;</span><br><span class="line">        <span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(KeyCode::D))</span><br><span class="line">            transform[<span class="number">3</span>][<span class="number">0</span>] += speed * ts;</span><br><span class="line">        <span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(KeyCode::W))</span><br><span class="line">            transform[<span class="number">3</span>][<span class="number">1</span>] += speed * ts;</span><br><span class="line">        <span class="keyword">if</span> (Input::<span class="built_in">IsKeyPressed</span>(KeyCode::S))</span><br><span class="line">            transform[<span class="number">3</span>][<span class="number">1</span>] -= speed * ts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">m_CameraEntity.<span class="built_in">AddComponent</span>&lt;NativeScriptComponent&gt;().<span class="built_in">Bind</span>&lt;CameraController&gt;();</span><br></pre></td></tr></table></figure></li><li><p>Component.h添加NativeScriptComponent脚本组件接收到CameraController<strong>作为参数T</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NativeScriptComponent</span></span><br><span class="line">&#123;</span><br><span class="line">    ScriptableEntity* Instance = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; InstantiateFunction;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; DestroyInstanceFunction;</span><br><span class="line"></span><br><span class="line">    std::function&lt;<span class="type">void</span>(ScriptableEntity*)&gt; OnCreateFunction;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(ScriptableEntity*)&gt; OnDestroyFunction;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(ScriptableEntity*, Timestep)&gt; OnUpdateFunction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InstantiateFunction = [&amp;]() &#123; Instance = <span class="keyword">new</span> <span class="built_in">T</span>(); &#125;;</span><br><span class="line">        DestroyInstanceFunction = [&amp;]() &#123; <span class="built_in">delete</span> (T*)Instance; Instance = <span class="literal">nullptr</span>; &#125;;</span><br><span class="line"></span><br><span class="line">        OnCreateFunction = [](ScriptableEntity* instance) &#123; ((T*)instance)-&gt;<span class="built_in">OnCreate</span>(); &#125;;</span><br><span class="line">        OnDestroyFunction = [](ScriptableEntity* instance) &#123; ((T*)instance)-&gt;<span class="built_in">OnDestroy</span>(); &#125;;</span><br><span class="line">        OnUpdateFunction = [](ScriptableEntity* instance, Timestep ts) &#123; ((T*)instance)-&gt;<span class="built_in">OnUpdate</span>(ts); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在Scene.cpp的OnUpdate函数中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    m_Registry.<span class="built_in">view</span>&lt;NativeScriptComponent&gt;().<span class="built_in">each</span>([=](<span class="keyword">auto</span> entity, <span class="keyword">auto</span>&amp; nsc)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nsc.Instance)</span><br><span class="line">        &#123;</span><br><span class="line">            nsc.<span class="built_in">InstantiateFunction</span>();</span><br><span class="line">            nsc.Instance-&gt;m_Entity = Entity&#123; entity, <span class="keyword">this</span> &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nsc.OnCreateFunction)</span><br><span class="line">                nsc.<span class="built_in">OnCreateFunction</span>(nsc.Instance);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nsc.OnUpdateFunction)</span><br><span class="line">            nsc.<span class="built_in">OnUpdateFunction</span>(nsc.Instance, ts);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ScriptableEntity.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScriptableEntity</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp; <span class="title">GetComponent</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Entity.<span class="built_in">GetComponent</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Entity m_Entity;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Scene</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="五十二、优化C-脚本函数">五十二、优化C++脚本函数</h2><h4 id="前言-10">前言</h4><ul><li><p>这节目的</p><p>将上一节在NativeScriptComponent写的function执行的功能替换为<strong>虚函数</strong>(OnCreate、OnUpdate、OnDestroy)和<strong>函数指针</strong>（Instantiate、Destroy）</p></li></ul><h4 id="代码-5">代码</h4><ul><li><p>ScriptableEntity.h  函数定义为虚函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ScriptableEntity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">ScriptableEntity</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnCreate</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDestroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(Timestep ts)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>EditorLayer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CameraController</span> : <span class="keyword">public</span> ScriptableEntity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnCreate</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; transform = <span class="built_in">GetComponent</span>&lt;TransformComponent&gt;().Transform;</span><br><span class="line">        transform[<span class="number">3</span>][<span class="number">0</span>] = <span class="built_in">rand</span>() % <span class="number">10</span> - <span class="number">5.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDestory</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(Timestep ts)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Components.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">NativeScriptComponent</span> </span><br><span class="line">&#123;</span><br><span class="line">    ScriptableEntity* (*InstantiateScript)();</span><br><span class="line">    <span class="built_in">void</span> (*DestroyScript)(NativeScriptComponent*);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InstantiateScript = []() &#123;<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;ScriptableEntity*&gt;(<span class="keyword">new</span> <span class="built_in">T</span>()); &#125;;</span><br><span class="line">        DestroyScript = [](NativeScriptComponent* nsc) &#123;<span class="keyword">delete</span> nsc-&gt;Instance; nsc-&gt;Instance = <span class="literal">nullptr</span>; &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Scene.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::OnUpdate</span><span class="params">(Timestep ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Update scripts</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_Registry.<span class="built_in">view</span>&lt;NativeScriptComponent&gt;().<span class="built_in">each</span>([=](<span class="keyword">auto</span> entity, <span class="keyword">auto</span>&amp; nsc)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> Move to Scene::OnScenePlay</span></span><br><span class="line">            <span class="keyword">if</span> (!nsc.Instance)</span><br><span class="line">            &#123;</span><br><span class="line">                nsc.Instance = nsc.<span class="built_in">InstantiateScript</span>();</span><br><span class="line">                nsc.Instance-&gt;m_Entity = Entity&#123; entity, <span class="keyword">this</span> &#125;;</span><br><span class="line"></span><br><span class="line">                nsc.Instance-&gt;<span class="built_in">OnCreate</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            nsc.Instance-&gt;<span class="built_in">OnUpdate</span>(ts);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="五十三、场景Hierarchy面板">五十三、场景Hierarchy面板</h2><h4 id="前言-11">前言</h4><ul><li><p>此节目的</p><p>给引擎添加hierarchy界面面板，用ECS遍历当前场景的实体，用imgui显示当前场景存活的实体</p></li></ul><h4 id="代码-6">代码</h4><ul><li><p>EditorLayer.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SceneHierarchyPanel m_SceneHierarchyPanel;</span><br></pre></td></tr></table></figure></li><li><p>EditorLayer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnAttach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_SceneHierarchyPanel.<span class="built_in">SetContext</span>(m_ActiveScene);<span class="comment">// 设置上下文</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EditorLayer::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_SceneHierarchyPanel.<span class="built_in">OnImGuiRender</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SceneHierarchyPanel.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SceneHierarchyPanel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SceneHierarchyPanel</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="built_in">SceneHierarchyPanel</span>(<span class="type">const</span> Ref&lt;Scene&gt;&amp; scene);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetContext</span><span class="params">(<span class="type">const</span> Ref&lt;Scene&gt;&amp; scene)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DrawEntityNode</span><span class="params">(Entity entity)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Ref&lt;Scene&gt; m_Context;</span><br><span class="line">Entity m_SelectionContext;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SceneHierarchyPanel.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">SceneHierarchyPanel::<span class="built_in">SceneHierarchyPanel</span>(<span class="type">const</span> Ref&lt;Scene&gt;&amp; context)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">SetContext</span>(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::SetContext</span><span class="params">(<span class="type">const</span> Ref&lt;Scene&gt;&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Context = context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Scene Hierarchy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> entity : m_Context-&gt;m_Registry.<span class="built_in">view</span>&lt;entt::entity&gt;())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DrawEntityNode</span>( &#123; entity, m_Context.<span class="built_in">get</span>() &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::DrawEntityNode</span><span class="params">(Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span>&amp; tag = entity.<span class="built_in">GetComponent</span>&lt;TagComponent&gt;().Tag;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        ImGuiTreeNodeFlags_Selected：如果选中这个实体，则高亮这个实体。</span></span><br><span class="line"><span class="comment">ImGuiTreeNodeFlags_OpenOnArrow：使节点可以点击箭头展开，而不是整个区域都能展开。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ImGuiTreeNodeFlags  flags = ((m_SelectionContext == entity) ? ImGuiTreeNodeFlags_Selected : <span class="number">0</span>) | ImGuiTreeNodeFlags_OpenOnArrow;</span><br><span class="line">        <span class="comment">//TreeNodeEx 用于绘制一个可展开的树节点。</span></span><br><span class="line"><span class="type">bool</span> opened = ImGui::<span class="built_in">TreeNodeEx</span>((<span class="type">void</span>*)(<span class="type">uint64_t</span>)(<span class="type">uint32_t</span>)entity, flags, tag.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">if</span> (ImGui::<span class="built_in">IsItemClicked</span>())</span><br><span class="line">&#123;</span><br><span class="line">m_SelectionContext = entity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (opened)<span class="comment">//该节点是否被展开</span></span><br><span class="line">&#123;</span><br><span class="line">ImGuiTreeNodeFlags flags = ImGuiTreeNodeFlags_OpenOnArrow;</span><br><span class="line"><span class="type">bool</span> opened = ImGui::<span class="built_in">TreeNodeEx</span>((<span class="type">void</span>*)<span class="number">888888</span>, flags, tag.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="keyword">if</span> (opened)</span><br><span class="line">ImGui::<span class="built_in">TreePop</span>();</span><br><span class="line">ImGui::<span class="built_in">TreePop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="五十四、添加属性面板">五十四、添加属性面板</h2><h4 id="前言-12">前言</h4><ul><li><p>此节目的</p><p>写出像Unity点击Cube，显示的<strong>Inspector</strong>面板，上面显示Cube的所有组件：transform、Mesh等。</p></li></ul><h4 id="代码流程-4">代码流程</h4><ul><li><p>如果当前点击的实体有效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 优化：若当前在hierarchy面板并且没点击到实体，属性面板清空</span></span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">IsMouseDown</span>(<span class="number">0</span>) &amp;&amp; ImGui::<span class="built_in">IsWindowHovered</span>()) &#123;</span><br><span class="line">        m_SelectionContext = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//新增面板</span></span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Properties&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_SelectionContext) &#123; </span><br><span class="line">        <span class="built_in">DrawComponents</span>(m_SelectionContext);</span><br><span class="line">    &#125;</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::DrawComponents</span><span class="params">(Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;TagComponent&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; tag = entity.<span class="built_in">GetComponent</span>&lt;TagComponent&gt;().Tag;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">        <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">strcpy_s</span>(buffer, <span class="built_in">sizeof</span>(buffer), tag.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">InputText</span>(<span class="string">&quot;Tag&quot;</span>, buffer, <span class="built_in">sizeof</span>(buffer)))</span><br><span class="line">        &#123;</span><br><span class="line">            tag = std::<span class="built_in">string</span>(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;TransformComponent&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">TreeNodeEx</span>((<span class="type">void</span>*)<span class="built_in">typeid</span>(TransformComponent).<span class="built_in">hash_code</span>(), ImGuiTreeNodeFlags_DefaultOpen, <span class="string">&quot;Transform&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; transform = entity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;().Transform;</span><br><span class="line">            ImGui::<span class="built_in">DragFloat3</span>(<span class="string">&quot;Position&quot;</span>, glm::<span class="built_in">value_ptr</span>(transform[<span class="number">3</span>]), <span class="number">0.1f</span>);</span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">TreePop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="五十五、摄像头-UI">五十五、摄像头 UI</h2><h4 id="前言-13">前言</h4><ul><li>此节目的<ul><li>在属性面板上实现点击摄像机实体，属性面板<strong>显示</strong>摄像机实体的摄像机组件参数。</li><li>修改摄像机的参数，摄像机<strong>会做出相应的显示</strong>。</li><li>给摄像机添加<strong>透视投影</strong>类型。</li></ul></li></ul><h4 id="代码-7">代码</h4><ul><li><p>SceneHierarchyPanel.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::DrawComponents</span><span class="params">(Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;CameraComponent&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">TreeNodeEx</span>((<span class="type">void</span>*)<span class="built_in">typeid</span>(CameraComponent).<span class="built_in">hash_code</span>(), ImGuiTreeNodeFlags_DefaultOpen, <span class="string">&quot;Camera&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; cameraComponent = entity.<span class="built_in">GetComponent</span>&lt;CameraComponent&gt;();</span><br><span class="line">            <span class="keyword">auto</span>&amp; camera = cameraComponent.Camera;</span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Primary&quot;</span>, &amp;cameraComponent.Primary);</span><br><span class="line"></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* projectionTypeStrings[] = &#123; <span class="string">&quot;Perspective&quot;</span>, <span class="string">&quot;Orthographic&quot;</span> &#125;;</span><br><span class="line">            <span class="type">const</span> <span class="type">char</span>* currentProjectionTypeString = projectionTypeStrings[(<span class="type">int</span>)camera.<span class="built_in">GetProjectionType</span>()];</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">BeginCombo</span>(<span class="string">&quot;Projection&quot;</span>, currentProjectionTypeString))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> isSelected = currentProjectionTypeString == projectionTypeStrings[i];</span><br><span class="line">                    <span class="keyword">if</span> (ImGui::<span class="built_in">Selectable</span>(projectionTypeStrings[i], isSelected))</span><br><span class="line">                    &#123;</span><br><span class="line">                        currentProjectionTypeString = projectionTypeStrings[i];</span><br><span class="line">                        <span class="comment">//设置摄像头类型，重新计算投影矩阵</span></span><br><span class="line">                        camera.<span class="built_in">SetProjectionType</span>((SceneCamera::ProjectionType)i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (isSelected)</span><br><span class="line">                        ImGui::<span class="built_in">SetItemDefaultFocus</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                ImGui::<span class="built_in">EndCombo</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (camera.<span class="built_in">GetProjectionType</span>() == SceneCamera::ProjectionType::Perspective)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> verticalFov = glm::<span class="built_in">degrees</span>(camera.<span class="built_in">GetPerspectiveVerticalFOV</span>());</span><br><span class="line">                <span class="keyword">if</span> (ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Vertical FOV&quot;</span>, &amp;verticalFov))</span><br><span class="line">                    camera.<span class="built_in">SetPerspectiveVerticalFOV</span>(glm::<span class="built_in">radians</span>(verticalFov));</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> orthoNear = camera.<span class="built_in">GetPerspectiveNearClip</span>();</span><br><span class="line">                <span class="keyword">if</span> (ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Near&quot;</span>, &amp;orthoNear))</span><br><span class="line">                    camera.<span class="built_in">SetPerspectiveNearClip</span>(orthoNear);</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> orthoFar = camera.<span class="built_in">GetPerspectiveFarClip</span>();</span><br><span class="line">                <span class="keyword">if</span> (ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Far&quot;</span>, &amp;orthoFar))</span><br><span class="line">                    camera.<span class="built_in">SetPerspectiveFarClip</span>(orthoFar);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (camera.<span class="built_in">GetProjectionType</span>() == SceneCamera::ProjectionType::Orthographic)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">float</span> orthoSize =camera.<span class="built_in">GetOrthographicSize</span>();</span><br><span class="line">                <span class="keyword">if</span> (ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Size&quot;</span>, &amp;orthoSize))</span><br><span class="line">                    camera.<span class="built_in">SetOrthographicSize</span>(orthoSize);</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> orthoNear = camera.<span class="built_in">GetOrthographicNearClip</span>();</span><br><span class="line">                <span class="keyword">if</span> (ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Near&quot;</span>, &amp;orthoNear))</span><br><span class="line">                    camera.<span class="built_in">SetOrthographicNearClip</span>(orthoNear);</span><br><span class="line"></span><br><span class="line">                <span class="type">float</span> orthoFar = camera.<span class="built_in">GetOrthographicFarClip</span>();</span><br><span class="line">                <span class="keyword">if</span> (ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Far&quot;</span>, &amp;orthoFar))</span><br><span class="line">                    camera.<span class="built_in">SetOrthographicFarClip</span>(orthoFar);</span><br><span class="line"></span><br><span class="line">                ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Fixed Aspect Ratio&quot;</span>, &amp;cameraComponent.FixedAspectRatio);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Scene中绘制时，获取到主摄像机的投影矩阵，计算得到投影视图矩阵传入给OpenGL计算绘制的图形在世界的<strong>最终位置</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneCamera::RecalculateProjection</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 区分是正交还是透视</span></span><br><span class="line">    <span class="keyword">if</span> (m_ProjectionType == ProjectionType::Perspective) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//glm::perspective()计算透视投影矩阵</span></span><br><span class="line">        m_Projection = glm::<span class="built_in">perspective</span>(m_PerspectiveFOV, m_AspectRatio, m_PerspectiveNear, m_PerspectiveFar);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> orthoLeft = -m_OrthographicSize * m_AspectRatio * <span class="number">0.5f</span>;</span><br><span class="line">        <span class="type">float</span> orthoRight = m_OrthographicSize * m_AspectRatio * <span class="number">0.5f</span>;</span><br><span class="line">        <span class="type">float</span> orthoBottom = -m_OrthographicSize * <span class="number">0.5f</span>;</span><br><span class="line">        <span class="type">float</span> orthoTop = m_OrthographicSize * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        m_Projection = glm::<span class="built_in">ortho</span>(orthoLeft, orthoRight, orthoBottom,</span><br><span class="line">                                  orthoTop, m_OrthographicNear, m_OrthographicFar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="五十六、Sprite-UI">五十六、Sprite UI</h2><h4 id="前言-14">前言</h4><ul><li><p>此节目的</p><p>点击实体，在属性面板里显示这个实体的<strong>spriterenderer</strong>组件的属性，应包括颜色、texture、shader什么的（纹理)，但目前先只显示颜色</p></li></ul><h4 id="代码-8">代码</h4><p>SceneHierarchyPhanel.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实体transform组件</span></span><br><span class="line"><span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;SpriteRendererComponent&gt;()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">TreeNodeEx</span>((<span class="type">void</span>*)<span class="built_in">typeid</span>(SpriteRendererComponent).<span class="built_in">hash_code</span>(), ImGuiTreeNodeFlags_DefaultOpen, <span class="string">&quot;Sprite Renderer&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; src = entity.<span class="built_in">GetComponent</span>&lt;SpriteRendererComponent&gt;();</span><br><span class="line">        ImGui::<span class="built_in">ColorEdit4</span>(<span class="string">&quot;Color&quot;</span>, glm::<span class="built_in">value_ptr</span>(src.Color));</span><br><span class="line">        ImGui::<span class="built_in">TreePop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="五十七、TransForm-UI">五十七、TransForm UI</h2><h4 id="前言-15">前言</h4><ul><li><p>此节目的</p><p>点击实体，在属性面板显示实体的<strong>Transform组件</strong>的位置、缩放、旋转属性。</p><p>对UI有要求</p><ol><li>文字需在<strong>左边</strong>，属性按钮在右边</li><li>x不是label，而是按钮且带有颜色，且点击按钮可以复原值。</li></ol></li></ul><h4 id="代码-9">代码</h4><ul><li><p>Components.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TransformComponent</span> </span><br><span class="line">&#123; </span><br><span class="line">    glm::vec3 Translation = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;</span><br><span class="line">    glm::vec3 Rotation = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>,<span class="number">0.0f</span> &#125;;</span><br><span class="line">    glm::vec3 Scale = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">TransformComponent</span>(<span class="type">const</span> glm::vec3&amp; translation)    </span><br><span class="line">        : <span class="built_in">Translation</span>(translation) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">glm::mat4 <span class="title">GetTransform</span><span class="params">()</span><span class="type">const</span> </span>&#123;</span><br><span class="line">        glm::mat4 rotation = glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), Rotation.x, &#123; <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;)</span><br><span class="line">            * glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), Rotation.y, &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> &#125;)</span><br><span class="line">            * glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), Rotation.z, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), Translation)</span><br><span class="line">            * rotation</span><br><span class="line">            * glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), Scale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>SceneHierarchyPanel.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DrawVec3Control</span><span class="params">(<span class="type">const</span> std::string&amp; label, glm::vec3&amp; values, <span class="type">float</span> resetValue = <span class="number">0.0f</span>, <span class="type">float</span> columnWidth = <span class="number">100.0f</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ImGui::<span class="built_in">PushID</span>(label.<span class="built_in">c_str</span>()); <span class="comment">// 为每个控件组推入唯一ID，防止命名冲突</span></span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Columns</span>(<span class="number">2</span>); <span class="comment">// 设置两列布局</span></span><br><span class="line">    ImGui::<span class="built_in">SetColumnWidth</span>(<span class="number">0</span>, columnWidth); <span class="comment">// 第一列的宽度</span></span><br><span class="line">    ImGui::<span class="built_in">Text</span>(label.<span class="built_in">c_str</span>()); <span class="comment">// 显示标签</span></span><br><span class="line">    ImGui::<span class="built_in">NextColumn</span>(); <span class="comment">// 切换到第二列</span></span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">PushMultiItemsWidths</span>(<span class="number">3</span>, ImGui::<span class="built_in">CalcItemWidth</span>()); <span class="comment">// 设置 3 个元素的宽度</span></span><br><span class="line">    ImGui::<span class="built_in">PushStyleVar</span>(ImGuiStyleVar_ItemSpacing, ImVec2&#123; <span class="number">0</span>, <span class="number">0</span> &#125;); <span class="comment">// 设置控件间距为 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算按钮大小（基于字体大小）</span></span><br><span class="line">    <span class="type">float</span> lineHeight = GImGui-&gt;Font-&gt;FontSize + GImGui-&gt;Style.FramePadding.y * <span class="number">2.0f</span>;</span><br><span class="line">    ImVec2 buttonSize = &#123; lineHeight + <span class="number">3.0f</span>, lineHeight &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// X 轴按钮（红色）</span></span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_Button, ImVec4&#123; <span class="number">0.8f</span>, <span class="number">0.1f</span>, <span class="number">0.15f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonHovered, ImVec4&#123; <span class="number">0.9f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonActive, ImVec4&#123; <span class="number">0.8f</span>, <span class="number">0.1f</span>, <span class="number">0.15f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;X&quot;</span>, buttonSize)) <span class="comment">// 点击按钮时重置 X 值</span></span><br><span class="line">        values.x = resetValue;</span><br><span class="line">    ImGui::<span class="built_in">PopStyleColor</span>(<span class="number">3</span>); <span class="comment">// 恢复按钮颜色</span></span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>(); <span class="comment">// 让 X 轴拖动条与按钮在同一行</span></span><br><span class="line">    ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;##X&quot;</span>, &amp;values.x, <span class="number">0.1f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="string">&quot;%.2f&quot;</span>); <span class="comment">// 拖动条，调整 X 值</span></span><br><span class="line">    ImGui::<span class="built_in">PopItemWidth</span>(); <span class="comment">// 弹出 X 轴控件宽度</span></span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>(); <span class="comment">// 让 Y 轴按钮在同一行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Y 轴按钮（绿色）</span></span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_Button, ImVec4&#123; <span class="number">0.2f</span>, <span class="number">0.7f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonHovered, ImVec4&#123; <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonActive, ImVec4&#123; <span class="number">0.2f</span>, <span class="number">0.7f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Y&quot;</span>, buttonSize))</span><br><span class="line">        values.y = resetValue;</span><br><span class="line">    ImGui::<span class="built_in">PopStyleColor</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">    ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;##Y&quot;</span>, &amp;values.y, <span class="number">0.1f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="string">&quot;%.2f&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">PopItemWidth</span>();</span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Z 轴按钮（蓝色）</span></span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_Button, ImVec4&#123; <span class="number">0.1f</span>, <span class="number">0.25f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonHovered, ImVec4&#123; <span class="number">0.2f</span>, <span class="number">0.35f</span>, <span class="number">0.9f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    ImGui::<span class="built_in">PushStyleColor</span>(ImGuiCol_ButtonActive, ImVec4&#123; <span class="number">0.1f</span>, <span class="number">0.25f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span> &#125;);</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Z&quot;</span>, buttonSize))</span><br><span class="line">        values.z = resetValue;</span><br><span class="line">    ImGui::<span class="built_in">PopStyleColor</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>();</span><br><span class="line">    ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;##Z&quot;</span>, &amp;values.z, <span class="number">0.1f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="string">&quot;%.2f&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">PopItemWidth</span>();</span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">PopStyleVar</span>(); <span class="comment">// 恢复原始的 ItemSpacing</span></span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">Columns</span>(<span class="number">1</span>); <span class="comment">// 结束列布局</span></span><br><span class="line"></span><br><span class="line">    ImGui::<span class="built_in">PopID</span>(); <span class="comment">// 弹出 ID，防止影响其他控件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::DrawComponents</span><span class="params">(Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;TransformComponent&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; tc = entity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;();</span><br><span class="line">        <span class="built_in">DrawVec3Control</span>(<span class="string">&quot;Translation&quot;</span>, tc.Translation);</span><br><span class="line">        glm::vec3 rotation = glm::<span class="built_in">degrees</span>(tc.Rotation);</span><br><span class="line">        <span class="built_in">DrawVec3Control</span>(<span class="string">&quot;Rotation&quot;</span>, rotation);</span><br><span class="line">        tc.Rotation = glm::<span class="built_in">radians</span>(rotation);</span><br><span class="line">        <span class="built_in">DrawVec3Control</span>(<span class="string">&quot;Scale&quot;</span>, tc.Scale, <span class="number">1.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">                </span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="五十八、实体和组件增删的UI">五十八、实体和组件增删的UI</h2><h4 id="前言-16">前言</h4><ul><li><p>目的</p><p>此节需要完成像Unity那样</p><ul><li>右键实体可以弹出菜单可以<strong>删除实体</strong>，右键空白地方可以弹出菜单<strong>添加实体</strong></li><li>在属性面板显示实体的组件，有<strong>添加组件按钮</strong>，点击弹出菜单项可以添加相应组件。</li><li>在属性面板显示实体的组件，每个组件的下拉有按钮，点击弹出菜单项可以<strong>删除这个组件</strong></li></ul></li></ul><h4 id="代码-10">代码</h4><ul><li><p>删除、添加实体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断当前点击的实体是否存在</span></span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Properties&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (m_SelectionContext) &#123; <span class="comment">// operator uint32_t() 的是const，不然不会调用operator bool(),而是调用uint32_t()</span></span><br><span class="line">        <span class="built_in">DrawComponents</span>(m_SelectionContext);</span><br><span class="line">        <span class="comment">// 弹出菜单: 在属性面板显示添加组件按钮</span></span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Add Component&quot;</span>)) &#123;</span><br><span class="line">            ImGui::<span class="built_in">OpenPopup</span>(<span class="string">&quot;AddComponent&quot;</span>);<span class="comment">// AddComponent只是id</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">BeginPopup</span>(<span class="string">&quot;AddComponent&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Camera&quot;</span>)) &#123;</span><br><span class="line">                m_SelectionContext.<span class="built_in">AddComponent</span>&lt;CameraComponent&gt;();</span><br><span class="line">                ImGui::<span class="built_in">CloseCurrentPopup</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Sprite Renderer&quot;</span>)) &#123;</span><br><span class="line">                m_SelectionContext.<span class="built_in">AddComponent</span>&lt;SpriteRendererComponent&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            ImGui::<span class="built_in">EndPopup</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::DrawEntityNode</span><span class="params">(Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; tag = entity.<span class="built_in">GetComponent</span>&lt;TagComponent&gt;().Tag;</span><br><span class="line">    <span class="comment">// 若是被点击标记为选中状态|有下一级</span></span><br><span class="line">    ImGuiTreeNodeFlags flags = ((m_SelectionContext == entity) ? ImGuiTreeNodeFlags_Selected : <span class="number">0</span>) | ImGuiTreeNodeFlags_OpenOnArrow;</span><br><span class="line">    <span class="comment">// 第一个参数是唯一ID 64的，</span></span><br><span class="line">    <span class="type">bool</span> opened = ImGui::<span class="built_in">TreeNodeEx</span>((<span class="type">void</span>*)(<span class="type">uint64_t</span>)(<span class="type">uint32_t</span>)entity, flags, tag.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">IsItemClicked</span>()) &#123;</span><br><span class="line">        m_SelectionContext = entity; <span class="comment">// 记录当前点击的实体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右键实体 弹出菜单:删除实体</span></span><br><span class="line">    <span class="type">bool</span> entityDeleted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">BeginPopupContextItem</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Delete Entity&quot;</span>)) &#123;</span><br><span class="line">            entityDeleted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ImGui::<span class="built_in">EndPopup</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>ImGui弹出菜单与延迟删除</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::OnImGuiRender</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_SelectionContext) <span class="comment">//When item is not selected</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 右击空白面板-弹出菜单。0是ID 1是右键</span></span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">BeginPopupContextWindow</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Create Empty Entity&quot;</span>)) &#123;</span><br><span class="line">                m_Context-&gt;<span class="built_in">CreateEntity</span>(<span class="string">&quot;Empty Entity&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ImGui::<span class="built_in">EndPopup</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_SelectionContext)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;Add Component&quot;</span>))</span><br><span class="line">            ImGui::<span class="built_in">OpenPopup</span>(<span class="string">&quot;AddComponent&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">BeginPopup</span>(<span class="string">&quot;AddComponent&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Camera&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                m_SelectionContext.<span class="built_in">AddComponent</span>&lt;CameraComponent&gt;();</span><br><span class="line">                ImGui::<span class="built_in">CloseCurrentPopup</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Sprite Renderer&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                m_SelectionContext.<span class="built_in">AddComponent</span>&lt;SpriteRendererComponent&gt;();</span><br><span class="line">                ImGui::<span class="built_in">CloseCurrentPopup</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            ImGui::<span class="built_in">EndPopup</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneHierarchyPanel::DrawEntityNode</span><span class="params">(Entity entity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> entityDeleted = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">BeginPopupContextItem</span>())<span class="comment">//选中Item并右键触发</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Delete Entity&quot;</span>))</span><br><span class="line">            entityDeleted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">EndPopup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (entityDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        m_Context-&gt;<span class="built_in">DestoryEntity</span>(entity);</span><br><span class="line">        <span class="keyword">if</span> (m_SelectionContext == entity)</span><br><span class="line">            m_SelectionContext = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;SpriteRendererComponent&gt;())</span><br><span class="line">&#123;</span><br><span class="line">    ImGui::<span class="built_in">PushStyleVar</span>(ImGuiStyleVar_FramePadding, ImVec2&#123; <span class="number">4</span>, <span class="number">4</span> &#125;);</span><br><span class="line">    <span class="type">bool</span> open = ImGui::<span class="built_in">TreeNodeEx</span>((<span class="type">void</span>*)<span class="built_in">typeid</span>(SpriteRendererComponent).<span class="built_in">hash_code</span>(), treeNodeFlags, <span class="string">&quot;Sprite Renderer&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">SameLine</span>(ImGui::<span class="built_in">GetWindowWidth</span>() - <span class="number">25.0f</span>);</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;+&quot;</span>, ImVec2&#123; <span class="number">20</span>, <span class="number">20</span> &#125;))</span><br><span class="line">    &#123;</span><br><span class="line">        ImGui::<span class="built_in">OpenPopup</span>(<span class="string">&quot;ComponentSettings&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ImGui::<span class="built_in">PopStyleVar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> removeComponent = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (ImGui::<span class="built_in">BeginPopup</span>(<span class="string">&quot;ComponentSettings&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Remove component&quot;</span>))</span><br><span class="line">            removeComponent = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">EndPopup</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (removeComponent)</span><br><span class="line">        entity.<span class="built_in">RemoveComponent</span>&lt;SpriteRendererComponent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加摄像机组件的时候，设置视口大小计算投影矩阵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Scene.h</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">OnComponentAdded</span><span class="params">(Entity entity, T&amp; component)</span></span>;</span><br><span class="line">Scene.cpp</span><br><span class="line"><span class="comment">// 模板类定义在cpp中</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Scene::OnComponentAdded</span><span class="params">(Entity entity, T&amp; component)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 静态断言：false，代表在编译前就会执行， 但是编译器这里不会报错，说明这段代码不会编译吧。。</span></span><br><span class="line">    <span class="comment">// 而且打了断点，也不行，证明这段代码只是声明作用吧。</span></span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> Scene::<span class="built_in">OnComponentAdded</span>&lt;CameraComponent&gt;(Entity entity, CameraComponent&amp; component)</span><br><span class="line">&#123;</span><br><span class="line">    entity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;().Translation = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">5.0f</span> &#125;;</span><br><span class="line">    component.camera.<span class="built_in">SetViewportSize</span>(m_ViewportWidth, m_ViewportHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="五十九、新的主题外观">五十九、新的主题外观</h2><h4 id="前言-17">前言</h4><ul><li><p>此节目的</p><p>如此节标题，让编辑器更好看，主要有：</p><ol><li>更换字体</li><li>按钮字体加粗</li><li>调整布局</li><li>控制最小宽度</li><li>界面颜色</li><li>用模板函数去除重复代码</li></ol></li></ul><h4 id="关键代码-4">关键代码</h4><ul><li><p>ImGui相关</p><ul><li><p>更换字体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完善UI：设置界面主题字体</span></span><br><span class="line">io.Fonts-&gt;<span class="built_in">AddFontFromFileTTF</span>(<span class="string">&quot;assets/fonts/opensans/OpenSans-Bold.ttf&quot;</span>, <span class="number">18.0f</span>);</span><br><span class="line">io.FontDefault = io.Fonts-&gt;<span class="built_in">AddFontFromFileTTF</span>(<span class="string">&quot;assets/fonts/opensans/OpenSans-Regular.ttf&quot;</span>, <span class="number">18.0f</span>);</span><br></pre></td></tr></table></figure></li><li><p>按钮字体加粗</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完善UI：加粗字体</span></span><br><span class="line">ImGui::<span class="built_in">PushFont</span>(boldFont);</span><br><span class="line"><span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;X&quot;</span>, buttonSize) )&#123;</span><br><span class="line">    values.x = resetValue;</span><br><span class="line">&#125;</span><br><span class="line">ImGui::<span class="built_in">PopFont</span>();</span><br><span class="line">ImGui::<span class="built_in">PopStyleColor</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><p>控制最小宽度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完善UI：设置面板最小宽度</span></span><br><span class="line"><span class="type">float</span> minWinSizeX = style.WindowMinSize.x;</span><br><span class="line">style.WindowMinSize.x = <span class="number">370.f</span>;</span><br><span class="line"><span class="keyword">if</span> (io.ConfigFlags &amp; ImGuiConfigFlags_DockingEnable)</span><br><span class="line">&#123;</span><br><span class="line">    ImGuiID dockspace_id = ImGui::<span class="built_in">GetID</span>(<span class="string">&quot;MyDockSpace&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">DockSpace</span>(dockspace_id, <span class="built_in">ImVec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>), dockspace_flags);</span><br><span class="line">&#125;</span><br><span class="line">style.WindowMinSize.x = minWinSizeX; <span class="comment">// 恢复</span></span><br></pre></td></tr></table></figure></li><li><p>界面颜色</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::SetDarkThemeColors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; colors = ImGui::<span class="built_in">GetStyle</span>().Colors;</span><br><span class="line">    colors[ImGuiCol_WindowBg] = ImVec4&#123; <span class="number">0.1f</span>, <span class="number">0.105f</span>, <span class="number">0.11f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Headers</span></span><br><span class="line">    colors[ImGuiCol_Header] = ImVec4&#123; <span class="number">0.2f</span>, <span class="number">0.205f</span>, <span class="number">0.21f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_HeaderHovered] = ImVec4&#123; <span class="number">0.3f</span>, <span class="number">0.305f</span>, <span class="number">0.31f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_HeaderActive] = ImVec4&#123; <span class="number">0.15f</span>, <span class="number">0.1505f</span>, <span class="number">0.151f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Buttons</span></span><br><span class="line">    colors[ImGuiCol_Button] = ImVec4&#123; <span class="number">0.2f</span>, <span class="number">0.205f</span>, <span class="number">0.21f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_ButtonHovered] = ImVec4&#123; <span class="number">0.3f</span>, <span class="number">0.305f</span>, <span class="number">0.31f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_ButtonActive] = ImVec4&#123; <span class="number">0.15f</span>, <span class="number">0.1505f</span>, <span class="number">0.151f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Frame BG</span></span><br><span class="line">    colors[ImGuiCol_FrameBg] = ImVec4&#123; <span class="number">0.2f</span>, <span class="number">0.205f</span>, <span class="number">0.21f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_FrameBgHovered] = ImVec4&#123; <span class="number">0.3f</span>, <span class="number">0.305f</span>, <span class="number">0.31f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_FrameBgActive] = ImVec4&#123; <span class="number">0.15f</span>, <span class="number">0.1505f</span>, <span class="number">0.151f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tabs</span></span><br><span class="line">    colors[ImGuiCol_Tab] = ImVec4&#123; <span class="number">0.15f</span>, <span class="number">0.1505f</span>, <span class="number">0.151f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_TabHovered] = ImVec4&#123; <span class="number">0.38f</span>, <span class="number">0.3805f</span>, <span class="number">0.381f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_TabActive] = ImVec4&#123; <span class="number">0.28f</span>, <span class="number">0.2805f</span>, <span class="number">0.281f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_TabUnfocused] = ImVec4&#123; <span class="number">0.15f</span>, <span class="number">0.1505f</span>, <span class="number">0.151f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_TabUnfocusedActive] = ImVec4&#123; <span class="number">0.2f</span>, <span class="number">0.205f</span>, <span class="number">0.21f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Title</span></span><br><span class="line">    colors[ImGuiCol_TitleBg] = ImVec4&#123; <span class="number">0.15f</span>, <span class="number">0.1505f</span>, <span class="number">0.151f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_TitleBgActive] = ImVec4&#123; <span class="number">0.15f</span>, <span class="number">0.1505f</span>, <span class="number">0.151f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">    colors[ImGuiCol_TitleBgCollapsed] = ImVec4&#123; <span class="number">0.15f</span>, <span class="number">0.1505f</span>, <span class="number">0.151f</span>, <span class="number">1.0f</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>用模板函数去除重复代码</p></li><li><p>SceneHierarchyPanel.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> UIFunction&gt;</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">DrawComponent</span><span class="params">(<span class="type">const</span> std::string&amp; name, Entity entity, UIFunction uiFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> ImGuiTreeNodeFlags treeNodeFlags = ImGuiTreeNodeFlags_DefaultOpen | ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_AllowItemOverlap | ImGuiTreeNodeFlags_FramePadding;</span><br><span class="line">    <span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;T&gt;())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; component = entity.<span class="built_in">GetComponent</span>&lt;T&gt;();</span><br><span class="line">        ImVec2 contentRegionAvailable = ImGui::<span class="built_in">GetContentRegionAvail</span>();</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">PushStyleVar</span>(ImGuiStyleVar_FramePadding, ImVec2&#123; <span class="number">4</span>, <span class="number">4</span> &#125;);</span><br><span class="line">        <span class="type">float</span> lineHeight = GImGui-&gt;Font-&gt;FontSize + GImGui-&gt;Style.FramePadding.y * <span class="number">2.0f</span>;</span><br><span class="line">        ImGui::<span class="built_in">Separator</span>();</span><br><span class="line">        <span class="type">bool</span> open = ImGui::<span class="built_in">TreeNodeEx</span>((<span class="type">void</span>*)<span class="built_in">typeid</span>(T).<span class="built_in">hash_code</span>(), treeNodeFlags, name.<span class="built_in">c_str</span>());</span><br><span class="line">        ImGui::<span class="built_in">PopStyleVar</span>();</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">SameLine</span>(contentRegionAvailable.x - lineHeight * <span class="number">0.5f</span>);</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">Button</span>(<span class="string">&quot;+&quot;</span>, ImVec2&#123; lineHeight, lineHeight &#125;))</span><br><span class="line">        &#123;</span><br><span class="line">            ImGui::<span class="built_in">OpenPopup</span>(<span class="string">&quot;ComponentSettings&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> removeComponent = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (ImGui::<span class="built_in">BeginPopup</span>(<span class="string">&quot;ComponentSettings&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">MenuItem</span>(<span class="string">&quot;Remove component&quot;</span>))</span><br><span class="line">                removeComponent = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">EndPopup</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (open)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">uiFunction</span>(component);</span><br><span class="line">            ImGui::<span class="built_in">TreePop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (removeComponent)</span><br><span class="line">            entity.<span class="built_in">RemoveComponent</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="built_in">DrawComponent</span>&lt;TransformComponent&gt;(<span class="string">&quot;Transform&quot;</span>, entity, [](<span class="keyword">auto</span>&amp; component)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">DrawVec3Control</span>(<span class="string">&quot;Translation&quot;</span>, component.Translation);</span><br><span class="line">    glm::vec3 rotation = glm::<span class="built_in">degrees</span>(component.Rotation);</span><br><span class="line">    <span class="built_in">DrawVec3Control</span>(<span class="string">&quot;Rotation&quot;</span>, rotation);</span><br><span class="line">    component.Rotation = glm::<span class="built_in">radians</span>(rotation);</span><br><span class="line">    <span class="built_in">DrawVec3Control</span>(<span class="string">&quot;Scale&quot;</span>, component.Scale, <span class="number">1.0f</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">DrawComponent</span>&lt;CameraComponent&gt;(<span class="string">&quot;Camera&quot;</span>, entity, [](<span class="keyword">auto</span>&amp; component)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; camera = component.Camera;</span><br><span class="line">        ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Primary&quot;</span>, &amp;component.Primary);</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* projectionTypeStrings[] = &#123; <span class="string">&quot;Perspective&quot;</span>, <span class="string">&quot;Orthographic&quot;</span> &#125;;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* currentProjectionTypeString = projectionTypeStrings[(<span class="type">int</span>)camera.<span class="built_in">GetProjectionType</span>()];</span><br><span class="line">@@ <span class="number">-256</span>,<span class="number">41</span> +<span class="number">298</span>,<span class="number">13</span> @@ <span class="keyword">namespace</span> HEngine</span><br><span class="line">            <span class="keyword">if</span> (ImGui::<span class="built_in">DragFloat</span>(<span class="string">&quot;Far&quot;</span>, &amp;orthoFar))</span><br><span class="line">                camera.<span class="built_in">SetOrthographicFarClip</span>(orthoFar);</span><br><span class="line"></span><br><span class="line">            ImGui::<span class="built_in">Checkbox</span>(<span class="string">&quot;Fixed Aspect Ratio&quot;</span>, &amp;component.FixedAspectRatio);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="六十、-保存和加载场景">六十、 保存和加载场景</h2><h4 id="前言-18">前言</h4><ul><li><p>目的</p><p>为了实现像unity那样<strong>保存场景到本地</strong>和<strong>从本地加载场景</strong>的功能，这功能其实就是将场景的实体和组件用<strong>文本信息</strong>保存起来，加载场景的话就是<strong>读取文本信息</strong>，根据文本存储的信息，<strong>创建实体</strong>并且<strong>设置组件和组件数据</strong>。</p></li></ul><h4 id="将yaml项目作为子模块融入项目中">将yaml项目作为子模块融入项目中</h4><ol><li><p>cmd</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https:<span class="comment">//github.com/jbeder/yaml-cpp</span></span><br></pre></td></tr></table></figure></li><li><p>打开yaml-cpp文件夹下的premake.lua，将staticruntime &quot;off&quot;改为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">staticruntime <span class="string">&quot;on&quot;</span></span><br></pre></td></tr></table></figure><p>目的是使yaml-cpp项目作为<strong>静态链接</strong></p></li></ol><h4 id="关键的代码">关键的代码</h4><ul><li><p>存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SceneSerializer::Serialize</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    YAML::Emitter out;</span><br><span class="line">    out &lt;&lt; YAML::BeginMap;</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Scene&quot;</span> &lt;&lt; YAML::Value &lt;&lt; <span class="string">&quot;Untitled&quot;</span>;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Entities&quot;</span> &lt;&lt; YAML::Value &lt;&lt; YAML::BeginSeq;<span class="comment">// 开始序列化</span></span><br><span class="line">    m_Scene-&gt;m_Registry.<span class="built_in">each</span>([&amp;](<span class="keyword">auto</span> entityID) &#123;</span><br><span class="line">        Entity entity = &#123; entityID ,m_Scene.<span class="built_in">get</span>() &#125;;</span><br><span class="line">        <span class="keyword">if</span> (!entity)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 序列化实体</span></span><br><span class="line">        <span class="built_in">SerializeEntity</span>(out, entity);</span><br><span class="line">    &#125;);</span><br><span class="line">    out &lt;&lt; YAML::EndSeq; <span class="comment">// 结束序列化</span></span><br><span class="line"></span><br><span class="line">    out &lt;&lt; YAML::EndMap;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ofstream <span class="title">fout</span><span class="params">(filepath)</span></span>;</span><br><span class="line">    fout &lt;&lt; out.<span class="built_in">c_str</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SerializeEntity</span><span class="params">(YAML::Emitter&amp; out, Entity entity)</span> </span>&#123;</span><br><span class="line">    out &lt;&lt; YAML::BeginMap;</span><br><span class="line">    out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Entity&quot;</span> &lt;&lt; YAML::Value &lt;&lt; <span class="string">&quot;16816816816888&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (entity.<span class="built_in">HasComponent</span>&lt;TagComponent&gt;()) &#123;</span><br><span class="line">        out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;TagComponent&quot;</span>;</span><br><span class="line">        out &lt;&lt; YAML::BeginMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span>&amp; tag = entity.<span class="built_in">GetComponent</span>&lt;TagComponent&gt;().Tag;</span><br><span class="line">        out &lt;&lt; YAML::Key &lt;&lt; <span class="string">&quot;Tag&quot;</span> &lt;&lt; YAML::Value &lt;&lt; tag;</span><br><span class="line"></span><br><span class="line">        out &lt;&lt; YAML::EndMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其它组件类似</span></span><br><span class="line">    out &lt;&lt; YAML::EndMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ifstream <span class="title">stream</span><span class="params">(filepath)</span></span>;</span><br><span class="line">std::stringstream strStream;</span><br><span class="line">strStream &lt;&lt; stream.<span class="built_in">rdbuf</span>(); <span class="comment">// strStream流对象中的流重定向到字符串输出流strStream</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为node对象</span></span><br><span class="line">YAML::Node data = YAML::<span class="built_in">Load</span>(strStream.<span class="built_in">str</span>());</span><br><span class="line"><span class="keyword">if</span> (!data[<span class="string">&quot;Scene&quot;</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string sceneName = data[<span class="string">&quot;Scene&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;();</span><br><span class="line"><span class="built_in">HE_CORE_TRACE</span>(<span class="string">&quot;Deserializing scene &#x27;&#123;0&#125;&#x27;&quot;</span>, sceneName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> entities = data[<span class="string">&quot;Entities&quot;</span>];</span><br><span class="line"><span class="keyword">if</span> (entities) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> entity : entities) &#123;</span><br><span class="line">        <span class="type">uint64_t</span> uuid = entity[<span class="string">&quot;Entity&quot;</span>].<span class="built_in">as</span>&lt;<span class="type">uint64_t</span>&gt;();</span><br><span class="line"></span><br><span class="line">        std::string name;</span><br><span class="line">        <span class="keyword">auto</span> tagComponent = entity[<span class="string">&quot;TagComponent&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (tagComponent) &#123;</span><br><span class="line">            name = tagComponent[<span class="string">&quot;Tag&quot;</span>].<span class="built_in">as</span>&lt;std::string&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">HE_CORE_TRACE</span>(<span class="string">&quot;Deserialized entity with ID = &#123;0&#125;, name = &#123;1&#125;&quot;</span>, uuid, name);</span><br><span class="line"></span><br><span class="line">        Entity deserializedEntity = m_Scene-&gt;<span class="built_in">CreateEntity</span>(name);;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> transformComponent = entity[<span class="string">&quot;TransformComponent&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (transformComponent) &#123;</span><br><span class="line">            <span class="comment">// 添加实体，默认有transform组件</span></span><br><span class="line">            <span class="keyword">auto</span>&amp; tc = deserializedEntity.<span class="built_in">GetComponent</span>&lt;TransformComponent&gt;();</span><br><span class="line">            tc.Translation = transformComponent[<span class="string">&quot;Translation&quot;</span>].<span class="built_in">as</span>&lt;glm::vec3&gt;();</span><br><span class="line">            tc.Rotation = transformComponent[<span class="string">&quot;Rotation&quot;</span>].<span class="built_in">as</span>&lt;glm::vec3&gt;();</span><br><span class="line">            tc.Scale = transformComponent[<span class="string">&quot;Scale&quot;</span>].<span class="built_in">as</span>&lt;glm::vec3&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">            </span><br></pre></td></tr></table></figure></li><li><p>存储的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Scene: Untitled</span><br><span class="line">Entities:</span><br><span class="line">  - Entity: <span class="number">16816816816888</span></span><br><span class="line">    TagComponent:</span><br><span class="line">      Tag: Camera B</span><br><span class="line">  - Entity: <span class="number">16816816816888</span></span><br><span class="line">    TagComponent:</span><br><span class="line">      Tag: Camera A</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure></li></ul><h4 id="关于yaml的BeginSeq">关于yaml的BeginSeq</h4><p>开了&lt;&lt; YAML::BeginSeq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scene: Untitled</span><br><span class="line">Entities:</span><br><span class="line">  - Entity: <span class="number">16816816816888</span></span><br><span class="line">    TagComponent:</span><br><span class="line">      Tag: Camera B</span><br><span class="line">  - Entity: <span class="number">16816816816888</span></span><br><span class="line">    TagComponent:</span><br><span class="line">      Tag: Camera A</span><br></pre></td></tr></table></figure><p>没开&lt;&lt; YAML::BeginSeq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scene: Untitled</span><br><span class="line">Entities:</span><br><span class="line">  Entity: <span class="number">12837192831273</span></span><br><span class="line">  TagComponent:</span><br><span class="line">    Tag: Camera B</span><br><span class="line">? Entity: <span class="number">12837192831273</span></span><br><span class="line">  TagComponent:</span><br><span class="line">    Tag: Camera A</span><br></pre></td></tr></table></figure><p>可以看出，BeginSeq是在实体信息前加一个**“-”**，代表着是一个实例</p>]]></content>
    
    
    <summary type="html">记录HEngine每一次提交的重点内容以及遇到的问题和解决的步骤</summary>
    
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>游戏引擎开发补充知识点</title>
    <link href="https://donghuiw.github.io/posts/e0684db9"/>
    <id>https://donghuiw.github.io/posts/e0684db9</id>
    <published>2025-03-05T02:16:19.000Z</published>
    <updated>2025-03-18T08:36:22.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HEngine游戏引擎-01-30">HEngine游戏引擎(01-30)</h2><h4 id="1-观察者模式-Observe-Pattern">1. 观察者模式(Observe Pattern)</h4><p>这种模式常见于窗口系统的设计和游戏开发领域，举个例子，如下图所示，当主角移到周围的格子时，如何做出合适的反应：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5469552b8f1c31004f836d8656af37ab.png" alt="在这里插入图片描述"><br>我第一反应想的是，在主角的移动函数里做判断，大概是这么写:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Agent</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(agentMoved)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(targetType == <span class="string">&quot;袭击&quot;</span>) ...</span><br><span class="line"> <span class="keyword">if</span>(targetType == <span class="string">&quot;加血&quot;</span>) ...</span><br><span class="line"> <span class="keyword">if</span>(targetType == <span class="string">&quot;困住&quot;</span>) ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写的缺点有两个：</p><ul><li>角色类与加血、袭击和困住这些事件类的耦合太高</li><li>如果加一个新的事件，还要去修改Agent类的代码，这不适合拓展</li></ul><p>还有一种方法，就是加血这些事件类，每隔一段时间就判断主角是否在其范围内，这样会造成CPU消耗，也不好。<br>所以Observe Pattern能很好的解决这个问题，当角色触发这个事件时，能第一时间让所有可能响应的事件收到这个消息，就好像一个主播，给所有的订阅者发送推送一样。</p><p>为了降低主角类与事件类的耦合性，设置一个规定，所有主角这种类（或者说类似于主播这种会发送通知的类），需要创建一个存放所有订阅者的数据结构(ObserverList)，再规定几个统一的接口，用于添加订阅，取消订阅，发送订阅，就是以下内容：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a5b6c3ec85f75e22f0f7efc9956de8a0.png" alt="在这里插入图片描述"><br>而所有的observer类，需要定义一个接口，作为收到消息时的响应函数，这里就叫做Update函数好了，所以写出来两个接口代码是这样是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者</span></span><br><span class="line"><span class="keyword">public</span> interface Observer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被观察者</span></span><br><span class="line">abstract <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList = <span class="keyword">new</span> <span class="built_in">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">attachObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observerList.<span class="built_in">add</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">detachObserver</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line">        observerList.<span class="built_in">remove</span>(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer: observerList)&#123;</span><br><span class="line">            observer.<span class="built_in">update</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这些响应的类，只要确保实现了update函数就可以了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//陷阱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trap</span> implements Observer &#123;</span><br><span class="line">    @<span class="function">Override</span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">inRange</span>())&#123;</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">&quot;陷阱 困住主角！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> boolean <span class="title">inRange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断主角是否在自己的影响范围内，这里忽略细节，直接返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于主角类，只需要在移动的时候，调用notifyAllObservers就行了：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Hero</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    void move()&#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">&quot;主角向前移动&quot;</span>);</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而创建主播类与用户类之间连接的代码则是在运行程序里进行执行的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"><span class="comment">// 在游戏执行时建立这些连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化对象</span></span><br><span class="line">        Hero hero = <span class="keyword">new</span> <span class="built_in">Hero</span>();</span><br><span class="line">        Monster monster = <span class="keyword">new</span> <span class="built_in">Monster</span>();</span><br><span class="line">        Trap trap = <span class="keyword">new</span> <span class="built_in">Trap</span>();</span><br><span class="line">        Treasure treasure = <span class="keyword">new</span> <span class="built_in">Treasure</span>();</span><br><span class="line">        <span class="comment">//注册观察者</span></span><br><span class="line">        hero.<span class="built_in">attachObserver</span>(monster);</span><br><span class="line">        hero.<span class="built_in">attachObserver</span>(trap);</span><br><span class="line">        hero.<span class="built_in">attachObserver</span>(treasure);</span><br><span class="line">        <span class="comment">//移动事件</span></span><br><span class="line">        hero.<span class="built_in">move</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写代码又简洁，又容易拓展，对于设计Event系统来说非常好用.</p><hr><h4 id="2-Vsync（垂直同步）">2. <strong>Vsync（垂直同步）</strong></h4><p><strong>Vsync（Vertical Synchronization，垂直同步）</strong> 是一种限制帧率的技术，它让 GPU 的帧渲染与显示器的刷新率同步，防止<strong>屏幕撕裂（Screen Tearing）</strong>。</p><p><strong>工作原理</strong></p><ul><li>显示器每秒刷新固定次数，比如 <strong>60Hz</strong> 意味着每秒刷新 60 次。</li><li>如果 GPU 渲染的帧率比显示器刷新率 <strong>高</strong>，屏幕可能会在一次刷新周期内接收两帧画面，导致撕裂。</li><li>Vsync <strong>强制</strong> GPU 在屏幕刷新完成后再提交新帧，从而减少撕裂，但可能导致<strong>输入延迟</strong>和<strong>帧率下降</strong>。</li></ul><p><strong>Vsync 在 OpenGL 中的实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 GLFW</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">glfwInit</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = <span class="built_in">glfwCreateWindow</span>(<span class="number">800</span>, <span class="number">600</span>, <span class="string">&quot;Vsync Example&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!window) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwMakeContextCurrent</span>(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用 Vsync（1 = 开启，0 = 关闭）</span></span><br><span class="line">    <span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">glfwWindowShouldClose</span>(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 渲染逻辑 ...</span></span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(window);</span><br><span class="line">        <span class="built_in">glfwPollEvents</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwTerminate</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关闭 Vsync</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><hr><h4 id="3-回调函数-Callback-Function">3. <strong>回调函数(Callback Function)</strong></h4><p><strong>回调函数</strong> 是一种<strong>间接调用</strong>的方式，允许将函数作为参数传递，从而在某些<strong>特定条件下</strong>执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyCallback</span><span class="params">(<span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Callback called with value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ExecuteCallback</span><span class="params">(<span class="type">void</span> (*callback)(<span class="type">int</span>), <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">callback</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ExecuteCallback</span>(MyCallback, <span class="number">42</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-std-function和std-bind">4.  <strong>std::function和std::bind</strong></h4><p><code>std::bind</code> 和 <code>std::function</code> 是 C++ 中处理<strong>回调、函数指针、事件系统</strong>的重要工具，它们可以让函数更加灵活地传递、存储和调用。</p><p><code>std::function</code> 是 C++ 标准库中的一个函数包装器，它可以存储、拷贝和调用任何可调用对象（如普通函数、lambda 表达式、函数指针、成员函数等）。</p><p><strong>（1）存储普通函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; func = Hello; <span class="comment">// std::function 绑定普通函数</span></span><br><span class="line">    <span class="built_in">func</span>(); <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）存储 Lambda 表达式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure><p><strong>（3）存储类的成员函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello from MyClass!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    std::function&lt;<span class="type">void</span>(MyClass&amp;)&gt; func = &amp;MyClass::Print; <span class="comment">// 绑定成员函数</span></span><br><span class="line">    <span class="built_in">func</span>(obj); <span class="comment">// 通过 std::function 调用成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::bind</code> 用于<strong>绑定函数及其参数</strong>，返回一个新的可调用对象，常用于回调、事件系统等。</p><p><strong>（1）绑定普通函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> boundFunc = std::<span class="built_in">bind</span>(Print, <span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 绑定参数 10, 20</span></span><br><span class="line">    <span class="built_in">boundFunc</span>(); <span class="comment">// 输出: a: 10, b: 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）绑定部分参数</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auto</span> boundFunc = std::bind(Print, <span class="number">10</span>, std::placeholders::_1); </span><br><span class="line"><span class="attribute">boundFunc</span>(<span class="number">99</span>); // 绑定 a=<span class="number">10</span>，b 由调用者提供，输出: a: <span class="number">10</span>, b: <span class="number">99</span></span><br></pre></td></tr></table></figure><p><strong>（3）绑定成员函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">auto</span> boundFunc = std::<span class="built_in">bind</span>(&amp;MyClass::Print, &amp;obj, std::placeholders::_1);</span><br><span class="line">    <span class="built_in">boundFunc</span>(<span class="number">42</span>); <span class="comment">// 输出: Value: 42</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="5-enum-和-enum-class">5. <strong><code>enum</code> 和 <code>enum class</code></strong></h4><p><strong>普通 <code>enum</code></strong></p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Red,    <span class="comment">// 0</span></span><br><span class="line">    Green,  <span class="comment">// 1</span></span><br><span class="line">    Blue    <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>enum</code> 会把枚举值提升到全局作用域，所以 <code>Red</code>、<code>Green</code>、<code>Blue</code> 可以直接使用。</li><li><code>enum</code> 的底层类型默认是 <code>int</code>，但可以隐式转换成整数类型：</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int colorValue <span class="operator">=</span> Green<span class="comment">; // 1</span></span><br></pre></td></tr></table></figure><p><strong><code>enum class</code>（强类型枚举）</strong></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="symbol">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    Red,    <span class="comment">// 0</span></span><br><span class="line">    Green,  <span class="comment">// 1</span></span><br><span class="line">    Blue    <span class="comment">// 2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>enum class</code> 不能隐式转换为 <code>int</code>，避免了命名冲突：</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> colorValue = <span class="title class_">Color</span>::<span class="variable constant_">Green</span>; <span class="comment">// ❌ 错误，需要显式转换</span></span><br><span class="line"><span class="keyword">int</span> colorValue = static_cast&lt;<span class="keyword">int</span>&gt;(<span class="title class_">Color</span>::<span class="variable constant_">Green</span>); <span class="comment">// ✅ 正确</span></span><br></pre></td></tr></table></figure><ul><li><code>enum class</code> 作用域限定，避免与其他 <code>enum</code> 或全局变量冲突：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="symbol">Color</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="symbol">TrafficLight</span> &#123; Red, Yellow, Green &#125;;</span><br><span class="line"></span><br><span class="line">Color myColor = Color::Red;            <span class="comment">// ✅ 正确</span></span><br><span class="line">TrafficLight light = TrafficLight::Red; <span class="comment">// ✅ 正确</span></span><br></pre></td></tr></table></figure><ul><li>你可以指定底层类型：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="symbol">Color</span> : <span class="symbol">uint8_t</span></span><br><span class="line">&#123;</span><br><span class="line">    Red = <span class="number">1</span>,</span><br><span class="line">    Green = <span class="number">2</span>,</span><br><span class="line">    Blue = <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="6-C-宏中的-和">6. <strong>C++ 宏中的 <code>#</code> 和 <code>##</code></strong></h4><p>在 C++ 宏定义中：</p><ul><li><code>#</code> 用于将宏参数转换为字符串。</li><li><code>##</code> 用于连接（拼接）两个标识符。</li></ul><p><strong><code>#</code> 操作符（字符串化）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRINGIFY(x) #x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">STRINGIFY</span>(Hello World) &lt;&lt; std::endl; <span class="comment">// 输出: &quot;Hello World&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>#x</code> 把 <code>x</code> 变成字符串。</li></ul><p><strong><code>##</code> 操作符（标识符拼接）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONCAT(a, b) a##b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> xy = <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">CONCAT</span>(x, y) &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>##</code> 将 <code>x</code> 和 <code>y</code> 连接成 <code>xy</code>，所以 <code>CONCAT(x, y)</code> 实际上变成了 <code>xy</code>。</li></ul><hr><h4 id="7-override-关键字和虚函数">7. <strong><code>override</code> 关键字和虚函数</strong></h4><p>在 C++11 之前，虚函数的覆盖是隐式的，容易出错。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base speaking!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// ❌ 这个不会覆盖 Base::Speak()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived speaking!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>Derived::Speak(int x)</code> 由于参数不同，并没有真正覆盖 <code>Base::Speak()</code>，但编译器不会报错。这可能会导致意外的行为。</p><p><strong>使用 <code>override</code> 关键字</strong></p><p>C++11 引入了 <code>override</code> 关键字，可以显式指定一个函数是覆盖基类的虚函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="keyword">override</span> <span class="comment">// ✅ 现在编译器会检查是否正确覆盖</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived speaking!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 <code>Base::Speak()</code> 发生变更（比如改名或修改参数），编译器会报错，防止潜在的错误。</p><p><strong>结合 <code>final</code> 关键字</strong></p><ul><li><code>override</code> 只是确保函数正确覆盖了基类的虚函数。</li><li><code>final</code> 关键字可以防止子类继续重写：</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    virtual <span class="built_in">void</span> Speak() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">Derived</span> : <span class="symbol">public</span> <span class="symbol">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">void</span> Speak() <span class="keyword">override</span> <span class="keyword">final</span> &#123;&#125; <span class="comment">// ✅ 允许 Derived 重新定义，但禁止再被派生类覆盖</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="symbol">MoreDerived</span> : <span class="symbol">public</span> <span class="symbol">Derived</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// void Speak() override &#123;&#125; // ❌ 错误，无法覆盖 final 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>抽象类和纯虚函数</strong></p><p>如果一个类有<strong>纯虚函数</strong>，那么它就成为<strong>抽象类</strong>，不能实例化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Woof!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Animal a; // ❌ 错误，不能实例化抽象类</span></span><br><span class="line">    Dog d;</span><br><span class="line">    d.<span class="built_in">Speak</span>(); <span class="comment">// 输出 &quot;Woof!&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-关于-debugbreak">8.关于__debugbreak</h4><p>方便使用引擎来判断数据类型是否为null，创建了一个Assert类型的宏，为了创建这个宏，需要知道两个宏的操作，一个是Variadic Arguments(可变的参数)，这个之前也用到过了，对应宏的参数是<code>__VA_ARGS__</code>，第二个就是一个新的宏，叫做<code>__debugbreak</code></p><p>相当于C#里调试的Debug.break()，调试的时候如果执行到这里会自动打断点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HE_ENABLE_ASSERTS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HENGINE_ASSERT(x, ...) <span class="keyword">if</span>(!x) &#123;LOG_ERROR(<span class="string">&quot;Assertion Failed At: &#123;0&#125;&quot;</span>, __VA_ARGS__);\</span></span><br><span class="line"><span class="meta">__debugbreak();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HENGINE_CORE_ASSERT(x, ...) <span class="keyword">if</span>(!x) &#123;CORE_LOG_ERROR(<span class="string">&quot;Assertion Failed At: &#123;0&#125;&quot;</span>, __VA_ARGS__);\</span></span><br><span class="line"><span class="meta">__debugbreak();&#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HENGINE_ASSERT(x, ...) <span class="comment">// 非Debug状态下这行代码毫无作用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HENGINES_CORE_ASSERT(x, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="9-C-Lambda-表达式">9.<strong>C++ Lambda 表达式</strong></h4><p>Lambda 表达式（Lambda Expression）是 C++11 引入的一种 <strong>匿名函数</strong>，可以用来创建临时的、可传递的 <strong>函数对象</strong>，特别适用于 <strong>回调函数、STL 算法</strong> 等场景。<br>它的语法结构如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表] <span class="function"><span class="params">(参数列表)</span> -&gt;</span> 返回类型 &#123; 函数体 &#125;</span><br></pre></td></tr></table></figure><p><strong>1. Lambda 的基本语法</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto <span class="built_in">lambda</span> = []() &#123; std::cout &lt;&lt; <span class="string">&quot;Hello, Lambda!&quot;</span> &lt;&lt; std::endl; &#125;;</span><br><span class="line"><span class="built_in">lambda</span>(); <span class="regexp">//</span> 调用 <span class="built_in">lambda</span>，输出 <span class="string">&quot;Hello, Lambda!&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>[]</code> 是 <strong>捕获列表</strong>，这里为空，表示不捕获任何变量。</li><li><code>()</code> 是 <strong>参数列表</strong>，这里为空，表示没有参数。</li><li><code>&#123;&#125;</code> 内是 <strong>函数体</strong>。</li></ul><hr><p><strong>2. 捕获列表（Capture List）</strong></p><p>Lambda 可以 <strong>捕获外部变量</strong>，有几种方式：</p><p><strong>（1）值捕获（Copy Capture）</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">10</span>;</span><br><span class="line">auto <span class="built_in">lambda</span> = [a]() &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;</span><br><span class="line"><span class="built_in">lambda</span>(); <span class="regexp">//</span> 输出 <span class="number">10</span></span><br></pre></td></tr></table></figure><ul><li><code>a</code> 以 <strong>值（拷贝）</strong> 方式传递到 Lambda 里，不会影响外部的 <code>a</code>。</li><li><strong>Lambda 内修改 <code>a</code> 不会影响外部 <code>a</code></strong>（因为是拷贝）。</li></ul><p><strong>（2）引用捕获（Reference Capture）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [&amp;a]() &#123; a = <span class="number">20</span>; &#125;;</span><br><span class="line"><span class="built_in">lambda</span>();</span><br><span class="line">std::cout &lt;&lt; a &lt;&lt; std::endl; <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure><ul><li><code>&amp;a</code> 以 <strong>引用方式</strong> 捕获 <code>a</code>，Lambda 里修改 <code>a</code> 会影响外部 <code>a</code>。</li></ul><p><strong>（3）默认捕获（= 和 &amp;）</strong></p><ul><li><strong><code>[=]</code>（默认值捕获）：所有变量都按 *<em>值*</em> 方式捕获</strong></li><li><strong><code>[&amp;]</code>（默认引用捕获）：所有变量都按 *<em>引用*</em> 方式捕获</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda1 = [=]() &#123; std::cout &lt;&lt; x + y &lt;&lt; std::endl; &#125;; <span class="comment">// 捕获 x, y 但不可修改</span></span><br><span class="line"><span class="keyword">auto</span> lambda2 = [&amp;]() &#123; x = <span class="number">20</span>; y = <span class="number">30</span>; &#125;; <span class="comment">// 捕获 x, y 并且可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">lambda1</span>(); <span class="comment">// 输出 15</span></span><br><span class="line"><span class="built_in">lambda2</span>();</span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 输出 20, 30</span></span><br></pre></td></tr></table></figure><ul><li><code>[=]</code> 让 <code>x, y</code> <strong>以值传递</strong> 方式进入 Lambda，无法修改它们。</li><li><code>[&amp;]</code> 让 <code>x, y</code> <strong>以引用</strong> 方式进入 Lambda，可以修改它们。</li></ul><p><strong>（4）混合捕获</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [=, &amp;b]() &#123; b = <span class="number">30</span>; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line"><span class="built_in">lambda</span>();</span><br><span class="line">std::cout &lt;&lt; b &lt;&lt; std::endl; <span class="comment">// 输出 30</span></span><br></pre></td></tr></table></figure><ul><li><code>[=, &amp;b]</code> 让 <code>a</code> <strong>按值</strong> 捕获，而 <code>b</code> <strong>按引用</strong> 捕获。</li><li><strong>Lambda 里修改 <code>b</code> 会影响外部，但 <code>a</code> 不会变</strong>。</li></ul><hr><p><strong>3. Lambda 的参数</strong></p><p>Lambda 可以带参数，就像普通函数一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>) &lt;&lt; std::endl; <span class="comment">// 输出 8</span></span><br></pre></td></tr></table></figure><hr><p><strong>4. Lambda 的返回类型</strong></p><ul><li>如果 <strong>返回值能自动推导</strong>，可以省略 <code>-&gt; 返回类型</code>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> multiply = [](<span class="type">double</span> x, <span class="type">double</span> y) &#123; <span class="keyword">return</span> x * y; &#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">multiply</span>(<span class="number">2.5</span>, <span class="number">4.0</span>) &lt;&lt; std::endl; <span class="comment">// 输出 10.0</span></span><br></pre></td></tr></table></figure><ul><li>如果返回值 <strong>不能自动推导（如 return 类型不同）</strong>，要手动指定：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> divide = [](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">double</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)a / b;</span><br><span class="line">&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">divide</span>(<span class="number">5</span>, <span class="number">2</span>) &lt;&lt; std::endl; <span class="comment">// 输出 2.5</span></span><br></pre></td></tr></table></figure><hr><p><strong>5. Lambda 作为函数参数</strong></p><p>Lambda 在 <strong>STL 算法</strong> 里很常见：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> n) &#123; std::cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="comment">// 输出 1 2 3 4 5</span></span><br></pre></td></tr></table></figure><ul><li><code>std::for_each</code> 遍历 <code>nums</code>，每个元素都调用 Lambda 进行处理。</li></ul><hr><p><strong>6. Lambda 作为回调函数</strong></p><p>Lambda 适用于 <strong>事件回调</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_ invoke__">Process</span>(std::<span class="variable constant_">function</span>&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; callback) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="title function_ invoke__">callback</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="title function_ invoke__">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">Process</span>([](<span class="keyword">int</span> i) &#123; std::<span class="variable constant_">cout</span> &lt;&lt; <span class="string">&quot;Processing: &quot;</span> &lt;&lt; i &lt;&lt; std::<span class="variable constant_">endl</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Process</code> 接受一个 <code>std::function&lt;void(int)&gt;</code> 作为回调。</li><li><code>Process</code> 在循环里调用 Lambda，并传入 <code>i</code>。</li></ul><hr><p><strong>7. Lambda 的 <code>mutable</code></strong></p><p>普通 Lambda <strong>默认不能修改捕获的值</strong>：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x <span class="operator">=</span> <span class="number">10</span><span class="comment">;</span></span><br><span class="line">auto lambda <span class="operator">=</span> [x]() &#123; x <span class="operator">=</span> <span class="number">20</span><span class="comment">; &#125;; // ❌ 错误，x 是 const 不能修改</span></span><br></pre></td></tr></table></figure><p>可以用 <code>mutable</code> 让 Lambda 里的 <code>x</code> 变为 <strong>可修改副本</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> lambda = [x]() <span class="keyword">mutable</span> &#123; x = <span class="number">20</span>; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;;</span><br><span class="line"><span class="built_in">lambda</span>(); <span class="comment">// 输出 20</span></span><br><span class="line">std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出 10（原来的 x 没变）</span></span><br></pre></td></tr></table></figure><ul><li><code>mutable</code> 让 <code>x</code> <strong>在 Lambda 内可变</strong>，但不会影响外部 <code>x</code>。</li></ul><hr><h2 id="HEngine游戏引擎-31-60">HEngine游戏引擎(31-60)</h2><h4 id="1-遍历二维数组需要注意的问题">1.遍历二维数组需要注意的问题</h4><p>参考：<a href="https://stackoverflow.com/questions/33722520/why-is-iterating-2d-array-row-major-faster-than-column-major">https://stackoverflow.com/questions/33722520/why-is-iterating-2d-array-row-major-faster-than-column-major</a></p><p>使用C++的目的就是性能，操作时要注意内存的细节，如二维数组应该按照行进行遍历，因为C++里数组是按行进行存储的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        sum += array[i][j]; <span class="comment">// ✅ 按行访问，内存访问是连续的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="HEngine游戏引擎-61-90">HEngine游戏引擎(61-90)</h2><h4 id="1-C-std-filesystem">1. C++ <code>std::filesystem</code></h4><p><code>std::filesystem</code> 是 C++17 引入的文件系统库，提供了一组强大的 API 用于操作文件和目录，包括路径处理、文件查询、文件操作等。该库位于 <code>&lt;filesystem&gt;</code> 头文件中，属于 <code>std::filesystem</code> 命名空间。</p><hr><ol><li><strong>基本概念</strong></li></ol><p><strong>（1）主要组成部分</strong></p><ul><li><strong><code>std::filesystem::path</code></strong> —— 表示文件或目录路径</li><li><strong><code>std::filesystem::directory_entry</code></strong> —— 代表目录中的一个条目</li><li><strong><code>std::filesystem::directory_iterator</code></strong> —— 用于遍历目录中的条目</li><li><strong><code>std::filesystem::recursive_directory_iterator</code></strong> —— 递归遍历目录</li><li><strong><code>std::filesystem::file_status</code></strong> —— 存储文件的属性信息</li></ul><hr><ol start="2"><li><strong>常见用法</strong></li></ol><p><strong>（1）路径操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::filesystem::path p = <span class="string">&quot;C:/Users/Example/file.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Path: &quot;</span> &lt;&lt; p &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Filename: &quot;</span> &lt;&lt; p.<span class="built_in">filename</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Extension: &quot;</span> &lt;&lt; p.<span class="built_in">extension</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Parent Path: &quot;</span> &lt;&lt; p.<span class="built_in">parent_path</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Is absolute: &quot;</span> &lt;&lt; p.<span class="built_in">is_absolute</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Path</span><span class="operator">:</span> <span class="built_in">C</span><span class="operator">:/</span><span class="variable">Users</span><span class="operator">/</span><span class="variable">Example</span><span class="operator">/</span><span class="variable">file</span><span class="operator">.</span><span class="variable">txt</span></span><br><span class="line"><span class="variable">Filename</span><span class="operator">:</span> <span class="variable">file</span><span class="operator">.</span><span class="variable">txt</span></span><br><span class="line"><span class="built_in">Extension</span><span class="operator">:</span> <span class="operator">.</span><span class="variable">txt</span></span><br><span class="line"><span class="variable">Parent</span> <span class="built_in">Path</span><span class="operator">:</span> <span class="built_in">C</span><span class="operator">:/</span><span class="variable">Users</span><span class="operator">/</span><span class="variable">Example</span></span><br><span class="line"><span class="variable">Is</span> <span class="variable">absolute</span><span class="operator">:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><p><strong>（2）文件和目录操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fs::path dir = <span class="string">&quot;test_directory&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建目录</span></span><br><span class="line">    <span class="keyword">if</span> (!fs::<span class="built_in">exists</span>(dir)) &#123;</span><br><span class="line">        fs::<span class="built_in">create_directory</span>(dir);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Directory created: &quot;</span> &lt;&lt; dir &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件</span></span><br><span class="line">    fs::path file = dir / <span class="string">&quot;example.txt&quot;</span>;</span><br><span class="line">    std::<span class="built_in">ofstream</span>(file) &lt;&lt; <span class="string">&quot;Hello, Filesystem!&quot;</span>;  <span class="comment">// 创建并写入内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断文件是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (fs::<span class="built_in">exists</span>(file)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File exists: &quot;</span> &lt;&lt; file &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除文件</span></span><br><span class="line">    fs::<span class="built_in">remove</span>(file);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;File deleted: &quot;</span> &lt;&lt; file &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除目录</span></span><br><span class="line">    fs::<span class="built_in">remove</span>(dir);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Directory deleted: &quot;</span> &lt;&lt; dir &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>（3）遍历目录</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fs::path dir = <span class="string">&quot;.&quot;</span>;  <span class="comment">// 当前目录</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Contents of directory: &quot;</span> &lt;&lt; fs::<span class="built_in">absolute</span>(dir) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : fs::<span class="built_in">directory_iterator</span>(dir)) &#123;</span><br><span class="line">        std::cout &lt;&lt; (entry.<span class="built_in">is_directory</span>() ? <span class="string">&quot;[DIR]  &quot;</span> : <span class="string">&quot;[FILE] &quot;</span>) &lt;&lt; entry.<span class="built_in">path</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>（4）获取文件信息</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;filesystem&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fs::path file = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fs::<span class="built_in">exists</span>(file)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Size: &quot;</span> &lt;&lt; fs::<span class="built_in">file_size</span>(file) &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Last write time: &quot;</span> &lt;&lt; fs::<span class="built_in">last_write_time</span>(file).<span class="built_in">time_since_epoch</span>().<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File does not exist.\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ol start="3"><li><strong>总结</strong></li></ol><ul><li><code>std::filesystem</code> 提供了高效、跨平台的文件操作能力。</li><li><code>std::filesystem::path</code> 用于管理路径信息。</li><li><code>std::filesystem::directory_iterator</code> 和 <code>std::filesystem::recursive_directory_iterator</code> 用于遍历目录。</li><li><code>std::filesystem</code> 还可以进行文件创建、删除、拷贝、移动等操作。</li></ul><hr><h2 id="HEngine游戏引擎-91-120">HEngine游戏引擎(91-120)</h2><hr>]]></content>
    
    
    <summary type="html">记录制作游戏引擎遇到的新知识点，包括c++知识和模式设计思路等</summary>
    
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>HEngine游戏引擎(01-30)</title>
    <link href="https://donghuiw.github.io/posts/81e1b394"/>
    <id>https://donghuiw.github.io/posts/81e1b394</id>
    <published>2025-03-02T02:27:10.000Z</published>
    <updated>2025-03-13T14:07:08.599Z</updated>
    
    <content type="html"><![CDATA[<p>1-15是些基础工作、如项目构建、添加子模块、使引擎具有日志系统、事件系统，可视化窗口等基础功能</p><p>16开始是游戏引擎最核心的部分-Rendering，使引擎能够真正绘制出图形，如果想直接看这部分点此<a href="#16">链接</a>跳转</p><h2 id="一、-项目设置">一、  项目设置</h2><p>新建HEngine和Sandbox项目，HEngine项目生成为dll，Sandbox项目生成为exe，运行此exe通过动态链接HEngine的dll，可以调用dll定义的函数并输出信息。</p><p><strong>1.调整输出目录和中间的目录</strong></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(SolutionDir)\bin\$(Configuration)-$(Platform)\$(ProjectName)\ </span><br><span class="line">$(SolutionDir)\bin-<span class="keyword">int</span>\$(Configuration)-$(Platform)\$(ProjectName)\</span><br></pre></td></tr></table></figure><p>生成的文件在bin目录下，生成的intermediate文件在bin-int目录下，大概是这么个目录结构</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin<span class="regexp">/Debug-x64/</span>ProjectName/</span><br><span class="line">bin-<span class="keyword">int</span><span class="regexp">/Debug-64x/</span>ProjectName/</span><br></pre></td></tr></table></figure><p>中间目录:存储一些obj、二进制文件，生成好dll、exe后可以删除此文件夹</p><p><strong>2.Sandbox项目引用HEngine项目</strong></p><p>C++：静态链接与动态链接<br>阅读的博客，讲的很通俗易懂：<a href="https://blog.csdn.net/kang___xi/article/details/80210717">https://blog.csdn.net/kang___xi/article/details/80210717</a></p><ul><li><p>静态链接</p><ul><li><p>说明</p><ul><li>使用静态库方式链接，编译后链接时会将使用的库函数对应所包含库函数定义的.o目标文件都包含在exe文件中。</li></ul></li><li><p>优点</p><ul><li>执行速度快：因为可执行文件程序内部包含了所有需要执行的东西</li></ul></li><li><p>缺点</p><ul><li><p>浪费空间：因为多个可执行程序对同所需要的目标文件都有一份副本</p></li><li><p>更新慢：如果有一个.o目标文件发生改变，那么对应的使用这个.o目标文件的多个可执行程序需要重新来一遍链接过程，即链接多个.o目标文件来实现生成可执行文件。</p></li></ul></li></ul></li><li><p>动态链接</p><ul><li><p>说明</p><ul><li>使用动态库方式链接，编译后因为推迟链接不会将使用的库函数对应的dll文件都包含在exe文件中，而是在exe运行的时候将dll加载到内存CPU中再链接。</li></ul></li><li><p>优点</p><ul><li><p>节省空间：多个可执行程序对同所需要的库函数共享一份副本</p></li><li><p>更新快：一个源文件发生改变，只需更新编译成dll文件，不用每个可执行程序需要重新来一遍链接过程，因为多个可执行程序在运行时时链接，且共享一份副本</p></li></ul></li><li><p>缺点</p><ul><li>启动速度慢：因为每次执行程序都需要链接</li></ul></li></ul></li></ul><hr><h2 id="二、-程序入口">二、  程序入口</h2><h4 id="代码文件">代码文件</h4><ul><li><p>HEngine项目</p><ul><li><p>Application类</p><p>引擎内部功能实现</p></li><li><p>Core.h</p><p>来根据不同项目的条件编译，而写dll导入还是导出的宏定义</p></li><li><p>EntryPoint.h</p><p>入口点，main函数</p></li><li><p>HEngine.h</p><p>引入其它头文件，控制给Sandbox项目提供哪些引擎内部功能</p></li></ul></li><li><p>Sandbox项目</p><ul><li><p>SanboxApp.cpp</p><p>应用层实现</p></li></ul></li></ul><h4 id="关键代码">关键代码</h4><ul><li><p>在HEngine项目的Application.h中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Application&#123;</span><br><span class="line">....</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// To be defined in CLIENT</span></span><br><span class="line"><span class="function">Application* <span class="title">CreateApplication</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在HEngine命名空间内声明了CreateApplication函数</p></li><li><p>在Sandbox项目的SandboxApp.cpp中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HEngine::Application* <span class="title">HEngine::CreateApplication</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sandbox</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了CreateApplication函数</p></li><li><p>在EntryPoint.h中调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> HEngine::Application* <span class="title">HEngine::CreateApplication</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> app = HEngine::<span class="built_in">CreateApplication</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将CreateApplication函数声明为<strong>extern</strong>，表示此函数会在外部定义，接下来使用的这函数时将使用在外部定义的CreateApplication</p></li></ul><p><strong>包含头文件+条件编译和宏定义实现Dll导入与导出</strong></p><p><strong>前提操作</strong></p><ul><li>HEngine项目</li></ul><p>​右键项目Proterties(所有配置)  =&gt;   C/C++  =&gt;    Preprocessor(预处理器)  =&gt;    Definitions(预处理器定义)</p><p>​输入:     HE_PLATFORM_WINDOWS;    HE_BUILD_DLL</p><ul><li><p>Sandbox项目</p><ul><li><p>同上</p><p>输入:     HE_PLATFORM_WINDOWS;</p></li><li><p>右键属性(所有配置)  =&gt;  C/C++   =&gt;   General(常规)   =&gt;   附加包含目录</p><p>输入:     $(SolutionDir)HEngine\src</p><p>为了Sandbox项目能引入HEngine项目的文件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;HEngine.h&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在Core.h中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HE_PLATFORM_WINDOWS</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HE_BUILD_DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEngine_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEngine_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> HEngine only supports Windows!</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>根据条件编译定义<strong>HEngine_API</strong>是dll导入还是导出，HEngine项目将是__declspec(dllexport)，Sandbox项目是__declspec(dllimport)</p></li></ul><h4 id="程序运行流程">程序运行流程</h4><ul><li><p>EntryPoint.h<strong>定义了main函数</strong>，即写了入口点，所以程序会在这运行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HE_PLATFORM_WINDOWS</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> HEngine::Application* <span class="title">HEngine::CreateApplication</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> app = HEngine::<span class="built_in">CreateApplication</span>();</span><br><span class="line">app-&gt;<span class="built_in">Run</span>();</span><br><span class="line"><span class="keyword">delete</span> app;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main函数中执行CreateApplication函数，将调用<strong>定义在SandboxApp.cpp</strong>中的CreateApplication函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HEngine::Application* <span class="title">HEngine::CreateApplication</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sandbox</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这函数返回的指针是HEngine项目中的<strong>Application父类指针</strong>，所以auto app的类型是Application*。</p></li><li><p>当执行app-&gt;Run()函数时，由于Run()函数<strong>没有</strong>声明为虚函数，所以会调用Application.cpp中的<strong>Run()函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line">Application::<span class="built_in">Application</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">Application::~<span class="built_in">Application</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="三、-日志系统-Premake">三、  日志系统 + Premake</h2><p>主要是以下几个任务</p><ol><li>创建Log类，然后有s_CoreLogger和s_ClientLogger，分别处理引擎的log和client的log</li><li>使用spdlog，具体主要是怎么利用git submodule使用该库</li><li>使用宏来封装对应的log函数，使用宏可以更好的方便不同平台的应用</li><li>用lua脚本配置项目属性，使用premake运行程序<strong>一键生成</strong>VS项目及属性</li></ol><p>游戏引擎少不了LogStystem，这里使用了别人做好的日志系统，叫做spdlog, 原作者是https://github.com/gabime/spdlog.git，因为我要在内部加入Premake5文件，所以fork到我自己的仓库再添加子模块，就变成了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https:<span class="regexp">//gi</span>thub.com<span class="regexp">/donghuiw/</span>spdlog.git HEngine<span class="regexp">/vendor/</span>spdlog</span><br></pre></td></tr></table></figure><p>对于这个LogSystem，底层使用的是spdlog，上层封装一层HEngine的Log类，以下是核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">std::shared_ptr&lt;spdlog::logger&gt; Log::s_CoreLogger;</span><br><span class="line">std::shared_ptr&lt;spdlog::logger&gt; Log::s_ClientLogger;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Log::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">spdlog::<span class="built_in">set_pattern</span>(<span class="string">&quot;%^[%T] %n: %v%$&quot;</span>);</span><br><span class="line"></span><br><span class="line">s_CoreLogger = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;HEngine&quot;</span>);</span><br><span class="line">s_CoreLogger-&gt;<span class="built_in">set_level</span>(spdlog::level::trace);</span><br><span class="line">s_ClientLogger = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;APP&quot;</span>);</span><br><span class="line">s_ClientLogger-&gt;<span class="built_in">set_level</span>(spdlog::level::trace);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外的宏操作，这里的宏的写法可以实现函数的宏，代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> std::shared_ptr&lt;spdlog::logger&gt;&amp; <span class="title">GetCoreLogger</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_CoreLogger; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> std::shared_ptr&lt;spdlog::logger&gt;&amp; <span class="title">GetClientLogger</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_ClientLogger; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//core log macros</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_CORE_TRACE(...) ::HEngine::Log::GetCoreLogger()-&gt;trace(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_CORE_INFO(...) ::HEngine::Log::GetCoreLogger()-&gt;info(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_CORE_WARN(...) ::HEngine::Log::GetCoreLogger()-&gt;warn(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><h4 id="Git删除子模块">Git删除子模块</h4><p>因添加子模块时候，写错代码，导致子模块添加路径错误，需要删除子模块并重新添加。而删除子模块是个稍微麻烦的事，网上查阅后，在此记录一下</p><p><strong>1. 删除submodule缓存</strong></p><p><strong>需要先暂存 .gitmodules 文件</strong>, 否则会报错: fatal: please stage your changes to .gitmodules or stash them to proceed</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .gitmodules</span><br><span class="line">git rm --cached submodule_name </span><br></pre></td></tr></table></figure><p>若报什么index已经存在的错误，说明没有执行git rm --cached 命令。</p><p>若报什么please stage your changes to .gitmodules or stash them to proceed，说明没有执行git add .gitmodules命令</p><p><strong>2. 修改.gitmodules</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移除对应的submodule信息, 只有<span class="number">1</span>个submodule信息的时候也可以删除该文件.</span><br></pre></td></tr></table></figure><p><strong>3. .git/modules</strong></p><p>移除对应的submodule目录, 进入.git\modules\HEngine\vendor,删除对应的子模块文件夹</p><p><strong>4. .git/config</strong></p><p>移除config文件内对应的submodule目录</p><h4 id="Premake5使用及问题汇总"><a href="https://donghuiw.github.io/posts/a1665e0e">Premake5使用及问题汇总</a></h4><p><strong>Premake生成项目的部分单独写了一个blog，关于使用第三方库文件的一般会单独写一个详细的，也方便查阅</strong></p><hr><h2 id="四、-事件系统">四、  事件系统</h2><p><a id="4"></a></p><p>思路是由Application创建自己的窗口window，对应的window类不应该知道任何Application的信息，所以Application在创建自己的window时，还要同时创建一个callback，在这之前，需要知道以下内容：</p><ul><li>std::function的用法</li><li>C++中的enum和enum class</li><li><code>#</code>和<code>##</code>在C++宏里的用法</li><li>C++虚函数的<code>override</code>关键字和相关用法</li></ul><p>我把这种补充知识点放到<a href="https://winterdev.cn/posts/e0684db9"><strong>游戏引擎开发补充知识点</strong></a>,方便查看</p><p>现在可以正式开始<code>Event</code>的设计了，首先需要定义的就是<code>Event</code>和<code>EventType</code>类，这里把<code>Event</code>作为基类，<code>EventType</code>是enum class，包含了基本的外设事件，如下所示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EventType</span></span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved,</span><br><span class="line">    AppTick, AppUpdate, AppRender,</span><br><span class="line">    KeyPressed, KeyReleased,</span><br><span class="line">    MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于<code>Event</code>类型，作为基类，那么最基本的两个接口应该为：</p><ul><li>获取该事件的类型</li><li>获取该事件的名字</li></ul><p>作为基类，这都是最基本的API，再者，为了方便使用，仿照C#的方式，C#语言里所有的Object都有一个ToString函数，方便我们打印一些消息，所以这个API我们也把它加入到<code>Event</code>基类里，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前就是这样，然后我们还需要一个<code>EventCategory</code>枚举，以后用flag来快速筛选特定的<code>Event</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT(x) (1 &lt;&lt; x)</span></span><br><span class="line"><span class="comment">// events filter</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EventCategory</span></span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    EventCategoryApplication    = <span class="built_in">BIT</span>(<span class="number">0</span>),</span><br><span class="line">    EventCategoryInput          = <span class="built_in">BIT</span>(<span class="number">1</span>),</span><br><span class="line">    EventCategoryKeyboard       = <span class="built_in">BIT</span>(<span class="number">2</span>),</span><br><span class="line">    EventCategoryMouse          = <span class="built_in">BIT</span>(<span class="number">3</span>),</span><br><span class="line">    EventCategoryMouseButton    = <span class="built_in">BIT</span>(<span class="number">4</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义Event这个基类，就可以着手创建对应的子类的，拿鼠标事件举例，一共有<code>MouseMoved</code>、<code>MouseButtonPressed</code>、<code>MouseButtonReleased</code>、<code>MouseButtonScrolled</code>四种，那么我就建立四个子类，全放在<code>MouseEvent.h</code>文件下，拿<code>MouseMoved</code>举例，其类型为之前枚举定义的<code>MouseMovedEvent</code>，其ToString应该是打印出鼠标移动的offset值，由于该类的所有<code>Event</code>类型都是一样的，所以我们可以用一个static变量去存储该类型就够了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MouseMovedEvent</span> : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> EventType <span class="title">GetStaticType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> EventType::MouseMoved; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetStaticType</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MouseMoved&quot;</span>; &#125;</span><br><span class="line"><span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::stringstream a;</span><br><span class="line">        a &lt;&lt; <span class="string">&quot;MouseMovedEvent: xOffset = &quot;</span> &lt;&lt; <span class="built_in">GetXOffset</span>() &lt;&lt; <span class="string">&quot;, yOffset = &quot;</span> &lt;&lt; <span class="built_in">GetYOffset</span>();</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetXOffset</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_xOffset; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetYOffset</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_yOffset; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> m_xOffset, m_yOffset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>OK，写完了这个类，就可以继续写类似的鼠标事件的类了，但是我发现有一些代码都是非常类似的，写起来很麻烦，也很影响阅读：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MouseMovedEvent</span> : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> EventType <span class="title">GetStaticType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> EventType::MouseMoved; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetStaticType</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MouseMoved&quot;</span>; &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouseButtonPressedEvent</span>: <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> EventType <span class="title">GetStaticType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> EventType::MouseButtonPressed; &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetStaticType</span>(); &#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MouseButtonPressed&quot;</span>; &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我学到了一个方法，用宏去代替我们编写这么长的语句，这个宏名就叫做<code>EVENT_CLASS_TYPE(typename)</code>，来为我们生成对应的函数，通过<code>#</code>和<code>##</code>符号，可以达到这种效果，一个<code>#</code>是转换成字符串，两个<code>#</code>是原语句替换，所以就是这么简化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于简化代码, 因为很多类都有着相同的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_CLASS_TYPE(type) \</span></span><br><span class="line"><span class="meta">static EventType GetStaticType() &#123; return EventType::##type; &#125;\</span></span><br><span class="line"><span class="meta">const EventType GetEventType() const override &#123; return GetStaticType(); &#125;\</span></span><br><span class="line"><span class="meta">const char* GetName() const override &#123; return #type; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouseMovedEvent</span> : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">EVENT_CLASS_TYPE</span>(MouseMoved)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像这样，我们可以把所有鼠标事件的类定义好，接下来还需要的定义的输入类就是Window Event、ApplicationEvent和KeyEvent，先说前两种Event，最后着重提一下KeyEvent，键盘事件的输入处理并不像点击鼠标那么简单，通常（简单的事件系统里）我们是没有长按鼠标的操作的，但是却有长按键盘的操作，当我们按键盘时，会先打印一个字母，然后停顿一下，如果这个时候还按着按钮，就继续打印剩余的字母。</p><p>所以说，按键的时候，第一次会立马打印第一个字母，然后需要记录我按的次数（或者记录按的时间），当记录的值达到一定阈值（或时间）时，才会继续不停打印接下来的字母，这里我们不用时间记录，而是用一个int值，记录按相同键的次数。</p><p>设计KeyEvent类的时候，可以发现，<code>KeyPressedEvent</code>会比<code>KeyReleasedEvent</code>的数据多一个，前者会额外记录按下Key时，key走过的Loop的总数，所以这个时候可以设计一个基类叫做KeyEvent，这里放通用的数据，就是Key的keycode，用于存放Key类型共有的内容，设计思路如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> KeyEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetKeycode</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> keycode;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryKeyboard | EventCategoryInput)</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">// 构造函数设为Protected，意味着只有其派生类能够调用此函数</span></span><br><span class="line"><span class="built_in">KeyEvent</span>(<span class="type">int</span> keycode): <span class="built_in">keycode</span>(code)&#123;&#125; </span><br><span class="line"><span class="type">int</span> keycode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后再写对应的子类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> KeyPressedEvent : <span class="keyword">public</span> KeyEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">KeyPressedEvent</span>(<span class="type">int</span> keycode, <span class="type">int</span> repeatCount)</span><br><span class="line">: <span class="built_in">KeyEvent</span>(keycode), <span class="built_in">m_RepeatCount</span>(repeatCount) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetRepeatCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_RepeatCount; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; <span class="string">&quot;KeyPressedEvent: &quot;</span> &lt;&lt; m_KeyCode &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; m_RepeatCount &lt;&lt; <span class="string">&quot; repeats)&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">EVENT_CLASS_TYPE</span>(KeyPressed)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_RepeatCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="五、-预编译头文件">五、  预编译头文件</h2><p>为了避免头文件被反复编译，需要加上pch文件，可以加快编译速度，主要有以下几点</p><ul><li>需要在VS工程里添加hepch.h和hepch.cpp文件，前者放所有常用的库的头文件，对于后者，一般的pch是不需要cpp文件的，但是VS工程里需要这个东西，所以得加上，然后让他引用hepch.h</li><li>然后在premake5.lua文件里进行修改，添加两个参数，pchheader “…” 和 pchsource “…” ,后者一般只是VS工程需要，其他平台会忽略这个，再次Build工程后，项目属性配置里会显示，使用pch</li><li>最后再把所有用到基本库的cpp（或者说所有cpp）里，都加上<code>#include &quot;hepch.h&quot;</code></li></ul><p>有两个重点注意:</p><p><strong>第一个是</strong>在premake5.lua中添加pchheader可以不顾当前路径随便写，但是pchsource得明确指定路径，需要改成：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pchheader <span class="string">&quot;hepch.h&quot;</span></span><br><span class="line">pchsource <span class="string">&quot;hepch.cpp&quot;</span>  ×</span><br><span class="line">pchsource <span class="string">&quot;%&#123;prj.name&#125;/Src/hepch.cpp&quot;</span> <span class="comment">-- 根目录基于premake5.lua文件</span></span><br></pre></td></tr></table></figure><p><strong>第二个</strong>是，如果勾选了使用pch文件，项目内的所有.cpp文件都要添加include “pch.h”，而且一定要在第一行</p><hr><h2 id="六、-GlFW窗口">六、  GlFW窗口</h2><p>总体思路是:  Application类调用创建窗口函数，而Window类使用glfw库创建<strong>真正的</strong>窗口。Window类<strong>检测</strong>glfw窗口的事件，并<strong>回调</strong>给Application的处理事件函数。</p><p>在做这个事情之前,下面这些概念都得熟悉：Vsync、Observe Pattern、回调函数、函数指针,都放在<a href="https://winterdev.cn/posts/e0684db9"><strong>游戏引擎开发补充知识点</strong></a>,方便查看</p><p><strong>步骤</strong></p><ul><li><p>添加glfw子模块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add submodule https:<span class="comment">//github.com/glfw/glfw HEngine/vendor/GLFW</span></span><br></pre></td></tr></table></figure></li><li><p>修改premake</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">IncludeDir = &#123;&#125;</span><br><span class="line">IncludeDir[<span class="string">&quot;GLFW&quot;</span>] = <span class="string">&quot;Hengine/vendor/GLFW/include&quot;</span></span><br><span class="line"><span class="comment">-- 这个include，相当于把glfw下的premake5.lua内容拷贝到这里</span></span><br><span class="line">include <span class="string">&quot;Hengine/vendor/GLFW&quot;</span></span><br><span class="line"></span><br><span class="line">project <span class="string">&quot;HEngine&quot;</span></span><br><span class="line">location <span class="string">&quot;Hengine&quot;</span></span><br><span class="line">kind <span class="string">&quot;SharedLib&quot;</span></span><br><span class="line"></span><br><span class="line">includedirs&#123;</span><br><span class="line"><span class="string">&quot;%&#123;prj.name&#125;/src&quot;</span>,</span><br><span class="line"><span class="string">&quot;%&#123;prj.name&#125;/vendor/spdlog/include&quot;</span>,</span><br><span class="line"><span class="string">&quot;%&#123;IncludeDir.GLFW&#125;&quot;</span><span class="comment">-- 包含GLFW目录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">links </span><br><span class="line">&#123; </span><br><span class="line"><span class="string">&quot;GLFW&quot;</span>,<span class="comment">-- HEngine链接glfw项目</span></span><br><span class="line"><span class="string">&quot;opengl32.lib&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Window类"><strong>Window类</strong></h4><p>Window类作为接口类，需要包含通用的窗口内容：</p><ul><li><p>一个Update函数，用于在loop里每帧循环</p></li><li><p>窗口的长和宽，以及相应的Get函数</p></li><li><p>设置窗口的Vsync和Get窗口的Vsync函数</p></li><li><p>窗口的回调函数，当窗口接受事件输入时，会调用这个回调函数</p></li><li><p><strong>代码</strong></p><p>window.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WindowProps</span></span><br><span class="line">    &#123;<span class="comment">// 窗口初始化设置的内容</span></span><br><span class="line">std::string Title;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Width;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Height;</span><br><span class="line"><span class="built_in">WindowProps</span>(<span class="type">const</span> std::string&amp; title = <span class="string">&quot;HEngine Engine&quot;</span>,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> width = <span class="number">1280</span>,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> height = <span class="number">720</span>)</span><br><span class="line">: <span class="built_in">Title</span>(title), <span class="built_in">Width</span>(width), <span class="built_in">Height</span>(height)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Window</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> EventCallbackFn = std::function&lt;<span class="built_in">void</span>(Event&amp;)&gt;;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Window</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Window attributes</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetEventCallback</span><span class="params">(<span class="type">const</span> EventCallbackFn&amp; callback)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsVSync</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 在Window父类声明创建函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> Window* <span class="title">Create</span><span class="params">(<span class="type">const</span> WindowProps&amp; props = WindowProps())</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowsWindow.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsWindow</span> : <span class="keyword">public</span> Window</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">WindowsWindow</span>(<span class="type">const</span> WindowProps&amp; props);</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">WindowsWindow</span>();</span><br><span class="line">Window函数重载...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">GLFWwindow* m_Window;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">WindowData</span>&#123;</span><br><span class="line">std::string Title;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> Width, Height;</span><br><span class="line"><span class="type">bool</span> VSync;</span><br><span class="line">EventCallbackFn EventCallback;</span><br><span class="line">&#125;;</span><br><span class="line">WindowData m_Data;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowsWindow.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> s_GLFWInitialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 在WindowsWindow子类定义在Window父类声明的函数</span></span><br><span class="line"><span class="function">Window* <span class="title">Window::Create</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsWindow</span>(props);</span><br><span class="line">&#125;</span><br><span class="line">WindowsWindow::<span class="built_in">WindowsWindow</span>(<span class="type">const</span> WindowProps&amp; props)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">Init</span>(props);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WindowsWindow::Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">m_Data.Title = props.Title;</span><br><span class="line">m_Data.Width = props.Width;</span><br><span class="line">m_Data.Height = props.Height;</span><br><span class="line"><span class="built_in">HE_CORE_INFO</span>(<span class="string">&quot;Creating window &#123;0&#125; (&#123;1&#125;, &#123;2&#125;)&quot;</span>, props.Title, props.Width, props.Height);</span><br><span class="line"><span class="keyword">if</span> (!s_GLFWInitialized)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> glfwTerminate on system shutdown</span></span><br><span class="line"><span class="type">int</span> success = <span class="built_in">glfwInit</span>();</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(success, <span class="string">&quot;Could not intialize GLFW!&quot;</span>);</span><br><span class="line">s_GLFWInitialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建窗口</span></span><br><span class="line">m_Window = <span class="built_in">glfwCreateWindow</span>((<span class="type">int</span>)props.Width, (<span class="type">int</span>)props.Height, m_Data.Title.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">// 设置glfw当前的上下文</span></span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(m_Window);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置窗口关联的用户数据指针。这里GLFW仅做存储，不做任何的特殊处理和应用。</span></span><br><span class="line"><span class="comment">window表示操作的窗口句柄。</span></span><br><span class="line"><span class="comment">pointer表示用户数据指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">glfwSetWindowUserPointer</span>(m_Window, &amp;m_Data);</span><br><span class="line"><span class="built_in">SetVSync</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WindowsWindow::OnUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="built_in">glfwPollEvents</span>();<span class="comment">// 轮询事件</span></span><br><span class="line"><span class="built_in">glfwSwapBuffers</span>(m_Window);<span class="comment">// 交换缓冲</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WindowsWindow::SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (enabled)</span><br><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">glfwSwapInterval</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">m_Data.VSync = enabled;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="其它修改"><strong>其它修改</strong></h4><ul><li><p>Application</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line">Application::<span class="built_in">Application</span>()</span><br><span class="line">    &#123;</span><br><span class="line">m_Window = std::<span class="built_in">unique_ptr</span>&lt;Window&gt;(Window::<span class="built_in">Create</span>()); <span class="comment">// 创建窗口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (m_Running)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">glClearColor</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">m_Window-&gt;<span class="built_in">OnUpdate</span>();<span class="comment">// 更新glfw</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="七、-GLFW事件">七、  GLFW事件</h2><p>使用GLFW函数设置（拦截）真正窗口事件的回调函数，在回调函数中<strong>转换</strong>为我们自定义的事件，再<strong>回调</strong>给Application的OnEvent，OnEvent拦截对应的事件</p><p><strong>WindowsWindow.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLFWErrorCallback</span><span class="params">(<span class="type">int</span> error, <span class="type">const</span> <span class="type">char</span>* description)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_CORE_ERROR</span>(<span class="string">&quot;GLFW Error (&#123;0&#125;): &#123;1&#125;&quot;</span>, error, description);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WindowsWindow::Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s_GLFWInitialized)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwSetErrorCallback</span>(GLFWErrorCallback); <span class="comment">//从glfw里设置自己的回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置glfw事件回调=接收glfw窗口事件</span></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(m_Window, [](GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span><br><span class="line">    &#123;</span><br><span class="line">        WindowData&amp; data = *(WindowData*)<span class="built_in">glfwGetWindowUserPointer</span>(window);</span><br><span class="line">        data.Width = width;</span><br><span class="line">        data.Height = height;</span><br><span class="line"></span><br><span class="line">        WindowResizeEvent <span class="built_in">event</span>(width, height);</span><br><span class="line">        data.<span class="built_in">EventCallback</span>(event);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowCloseCallback</span>(m_Window, [](GLFWwindow* window)</span><br><span class="line">    &#123;</span><br><span class="line">        WindowData&amp; data = *(WindowData*)<span class="built_in">glfwGetWindowUserPointer</span>(window);</span><br><span class="line">        WindowCloseEvent event;</span><br><span class="line">        data.<span class="built_in">EventCallback</span>(event);</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><strong>Application.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIND_EVENT_FN(x) std::bind(&amp;Application::x, this, std::placeholders::_1)</span></span><br><span class="line"></span><br><span class="line">Application::<span class="built_in">Application</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_Window = std::<span class="built_in">unique_ptr</span>&lt;Window&gt;(Window::<span class="built_in">Create</span>());</span><br><span class="line">m_Window-&gt;<span class="built_in">SetEventCallback</span>(std::<span class="built_in">bind</span>(&amp;Application::OnEvent, <span class="keyword">this</span>, std::placeholders::_1));<span class="comment">// 设置window的callback为此对象的OnEvent函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">EventDispatcher <span class="title">dispatcher</span><span class="params">(e)</span></span>;</span><br><span class="line">dispatcher.<span class="built_in">Dispatch</span>&lt;WindowCloseEvent&gt;(<span class="built_in">BIND_EVENT_FN</span>(OnWindowClose));</span><br><span class="line"></span><br><span class="line"><span class="built_in">HE_CORE_TRACE</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Application::OnWindowClose</span><span class="params">(WindowCloseEvent &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Running = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>EventDispatcher</code>用于根据事件类型的不同，调用不同的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当收到Event时，创建对应的EventDispatcher</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> EventDispatcher </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> EventHandler = std::function&lt;<span class="built_in">bool</span>(T&amp;)&gt;;<span class="comment">//存储了一个输入为任意类型，返回值为bool的函数指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">EventDispatcher</span>(Event&amp; event):</span><br><span class="line"><span class="built_in">m_Event</span>(event)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T指的是事件类型, 如果输入的类型没有GetStaticType会报错</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dispatch</span><span class="params">(EventHandler&lt;T&gt; handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Event.m_Handled)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_Event.<span class="built_in">GetEventType</span>() == T::<span class="built_in">GetStaticType</span>()) </span><br><span class="line">&#123;</span><br><span class="line">m_Event.m_Handled = <span class="built_in">handler</span>(*(T*)&amp;m_Event); <span class="comment">//使用(T*)把m_Event转换成输入事件的指针类型</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Event&amp; m_Event;<span class="comment">//必须是引用，不可以是Event的实例，因为Event带有纯虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>遇到的问题:</strong></p><p>编译时报错显示error C2338: Cannot format argument,初步判定是跟spdlog有关，经过排查发现问题出在这里</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Application::<span class="built_in">OnEvent</span>(Event&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"> EventDispatcher <span class="built_in">dispatcher</span>(e);</span><br><span class="line"> dispatcher<span class="selector-class">.Dispatch</span>&lt;WindowCloseEvent&gt;(BIND_EVENT_FN(OnWindowClose));</span><br><span class="line"></span><br><span class="line"> <span class="built_in">HE_CORE_TRACE</span>(&quot;&#123;<span class="number">0</span>&#125;&quot;, e); ××××××</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是spdlog无法识别Event这个类型，需要我们自定义一个关于Event的模版,在Log.h最上方加入以下代码即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> FMT_VERSION &gt;= 90000</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Events/Event.h&quot;</span></span></span><br><span class="line"> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">fmt</span>::formatter&lt;HEngine::Event&gt; : ostream_formatter &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="八、-设计游戏的层级框架">八、  设计游戏的层级框架</h2><p>设计完Window和Event之后，需要创建Layer类</p><ul><li><p>Layer的理解</p><p>想象同Ps中一张图有多个层级，每个层级都可以绘制不同的画面，最后合在一起展现出图片最终的样子</p></li><li><p>Layer的设计</p><ul><li><p>数据结构：vector</p></li><li><p>渲染顺序</p><p><strong>从前往后</strong>渲染各个层的图像，这样后面渲染的会覆盖前面渲染的图像，在屏幕的最顶层。</p></li><li><p>处理事件顺序</p><p><strong>从后往前</strong>依次处理事件，当一个事件被一个层处理完不会传递给前一个层，结合渲染顺序，这样在屏幕最顶层的（也就是在vector最后的layer）图像<strong>最先</strong>处理事件。</p></li><li><p>例子解释</p><p>比如常见的3D游戏有UI。</p><p>渲染顺序：将3D图形先渲染，再渲染2DUI，这样屏幕上2DUI永远在3D图形上方，显示正确；</p><p>事件顺序：点击屏幕的图形，应该是2DUI最先处理，如果是相应UI事件，处理完后<strong>不传递</strong>给前一个3D层，若不是自己的UI事件，<strong>才传递</strong>给前一个3D层。</p></li></ul></li></ul><p><strong>项目相关</strong>：</p><p>Layer接口设计如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Layer</span>(<span class="type">const</span> std::string&amp; name = <span class="string">&quot;Layer&quot;</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Layer</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnAttach</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 应用添加此层执行</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDetach</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 应用分离此层执行</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 每层更新</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnEvent</span><span class="params">(Event&amp; event)</span> </span>&#123;&#125;<span class="comment">// 每层处理事件</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_DebugName; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_DebugName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>LayerStack.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> LayerStack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LayerStack</span>();</span><br><span class="line">~<span class="built_in">LayerStack</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PushLayer</span><span class="params">(Layer* layer)</span></span>;<span class="comment">// vector在头部添加一个层</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PushOverlay</span><span class="params">(Layer* overlay)</span></span>;<span class="comment">// 在vector末尾添加一个覆盖层，在屏幕的最上方的层</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PopLayer</span><span class="params">(Layer* layer)</span></span>;<span class="comment">// vector弹出指定层</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PopOverlay</span><span class="params">(Layer* overlay)</span></span>;<span class="comment">// vector弹出覆盖层</span></span><br><span class="line">std::vector&lt;Layer*&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    std::vector&lt;Layer*&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">end</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::vector&lt;Layer*&gt;stack;</span><br><span class="line">std::vector&lt;Layer*&gt;::iterator curStackItr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Application.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::PushLayer</span><span class="params">(Layer* layer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> m_LayerStack.<span class="built_in">PushLayer</span>(layer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::PushOverlay</span><span class="params">(Layer* layer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> m_LayerStack.<span class="built_in">PushOverlay</span>(layer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 从后往前顺序处理事件</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">auto</span> it = m_LayerStack.<span class="built_in">end</span>(); it != m_LayerStack.<span class="built_in">begin</span>();)</span><br><span class="line">     &#123;</span><br><span class="line">       (*--it)-&gt;<span class="built_in">OnEvent</span>(e);</span><br><span class="line">       <span class="keyword">if</span> (e.Handled)<span class="comment">// 截取后发现是此层的事件，就不传入前一个层</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">glClearColor</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从前往后顺序更新层</span></span><br><span class="line">   <span class="keyword">for</span> (Layer* layer : m_LayerStack)</span><br><span class="line">     layer-&gt;<span class="built_in">OnUpdate</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SandboxApp.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleLayer</span> : <span class="keyword">public</span> HEngine::Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ExampleLayer</span>()</span><br><span class="line">: <span class="built_in">Layer</span>(<span class="string">&quot;Example&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">HE_INFO</span>(<span class="string">&quot;ExampleLayer::Update&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnEvent</span><span class="params">(HEngine::Event&amp; event)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">HE_TRACE</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, event);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sandbox</span> : <span class="keyword">public</span> HEngine::Application</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Sandbox</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">PushLayer</span>(<span class="keyword">new</span> <span class="built_in">ExampleLayer</span>());</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="九、-添加GLAD">九、  添加GLAD</h2><p>为了使用OpenGL，而OpenGL的函数定义在显卡中，大多数函数的定义位置都无法在编译时确定下来，所以需要在运行时查询，需要使用GLAD库在运行时获取OpenGL函数地址并将其保存在函数指针中供程序运行时使用。</p><p>可以使用glew，也可以使用glad库，二者的在效率上好像没啥区别，不过glad的库要更新一些，所以这里用glad库，具体步骤：</p><ul><li><p>上网站https://glad.dav1d.de/上下载对应版本的header和src文件，放在vendor文件夹下</p></li><li><p>网站上下载的glad库没有premake5文件，所以按照glfw库的方式为其写一个，与glfw库相同，这里的glad库也是作为lib文件使用</p></li><li><p>把glad库的premake5文件相关内容整合到整个工程的premake5文件里</p></li></ul><hr><h2 id="十、-ImGui层">十、  ImGui层</h2><p>Dear ImGui主要用于程序员的图形Debug工具(类似于Unity的ImGUI)，如果没有ImGUI，要调整好一个参数，要反复在代码里面修改数值，然后编译运行项目查看效果，这样很麻烦，而通过ImGui，就可以实现直接在图形界面调试参数的功能。</p><h4 id="怎么使用ImGui的代码">怎么使用ImGui的代码</h4><p>ImGui的网址https://github.com/ocornut/imgui, 需要添加Premake，所以Fork到我的仓库再添加子模块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add submodule https:<span class="comment">//github.com/donghuiw/imgui HEngine/vendor/imgui</span></span><br></pre></td></tr></table></figure><p>ImGui的代码仓库里给了两种代码：</p><ul><li>一种是源代码，HEngine需要引用这部分代码，作为库文件，类似于引用GLFW和Glad库文件项目一样</li><li>一种是使用ImGui的源代码的examples代码，就是教你怎么调用的</li></ul><p>对于第一种代码，为其生成一个premake5.lua文件，然后为其生成一个Project即可</p><p>具体怎么在HEngine里用，就需要参考ImGui的例子代码了，由于我们用的是glfw库加上OpenGL3的版本，所以要参考的两个cpp文件为：<code>imgui_impl_opengl3.cpp</code>和<code>imgui_impl_glfw.cpp</code></p><p>接下来在Platform文件夹下，创建OpenGL文件夹：</p><ul><li>把<code>imgui_impl_opengl3</code>的头文件和源文件放进去，更名为<code>ImGuiOpenGLRenderer</code>，用来存放ImGui调用OpenGL的代码。</li><li>而原本用到的<code>imgui_impl_glfw</code>相关内容，就直接Copy和Paste到ImGuiLayer里。</li></ul><h4 id="创建ImGUILayer">创建ImGUILayer</h4><p>ImGui可以帮助程序员进行Debug，基于上述的Layer系统，把ImGui也作为一个Layer，为其创建对应的<code>ImGuiLayer.cpp</code>和相关头文件。</p><p>ImGuiLayer.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">HENGINE_API</span> ImGuiLayer : <span class="keyword">public</span> Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ImGuiLayer</span>();</span><br><span class="line">~<span class="built_in">ImGuiLayer</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnAttach</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//当layer添加到layer stack的时候会调用此函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnDettach</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//当layer从layer stack移除的时候会调用此函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnEvent</span><span class="params">(Event&amp;)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImGuiLayer.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Platform/OpenGL//ImGuiOpenGLRenderer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">ImGuiLayer::<span class="built_in">ImGuiLayer</span>()</span><br><span class="line">:<span class="built_in">Layer</span>(<span class="string">&quot;ImGuiLayer&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ImGuiLayer::~<span class="built_in">ImGuiLayer</span>()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnAttach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="comment">//这部分直接复制example_glfw_opengl3的文件里的main函数</span></span><br><span class="line">ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"></span><br><span class="line">ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;</span><br><span class="line">io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;</span><br><span class="line"></span><br><span class="line">io.KeyMap[ImGuiKey_Tab] = GLFW_KEY_TAB;</span><br><span class="line">io.KeyMap[ImGuiKey_LeftArrow] = GLFW_KEY_LEFT;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">ImGui_ImplOpenGL3_Init</span>(<span class="string">&quot;#version 410&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnDetach</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnEvent</span><span class="params">(Event &amp;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里也是参照ImGui给的Example写Update的函数，主要做了以下功能</span></span><br><span class="line">        <span class="comment">// 1. 创建Frame然后进行Render</span></span><br><span class="line">        <span class="comment">// 2. 根据窗口大小，动态给ImGui设置窗口展示大小</span></span><br><span class="line">        <span class="comment">// 3. 设置DeltaTime</span></span><br><span class="line">        ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">        Application&amp; app = Application::<span class="built_in">Get</span>();</span><br><span class="line">        io.DisplaySize = <span class="built_in">ImVec2</span>(app.<span class="built_in">GetWindow</span>().<span class="built_in">GetWindowWidth</span>(), app.<span class="built_in">GetWindow</span>().<span class="built_in">GetWindowHeight</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> time = (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>();</span><br><span class="line">        io.DeltaTime = m_Time &gt; <span class="number">0.0f</span> ? (time - m_Time) : (<span class="number">1.0f</span> / <span class="number">60.0f</span>);</span><br><span class="line">        m_Time = time;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">        ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="type">bool</span> show = <span class="literal">true</span>;</span><br><span class="line">        ImGui::<span class="built_in">ShowDemoWindow</span>(&amp;show);</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">Render</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在SandboxApp.cpp添加这一层就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SandBox</span> : <span class="keyword">public</span> HEngine::Application</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">SandBox</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">PushLayer</span>(<span class="keyword">new</span> <span class="built_in">ExampleLayer</span>());</span><br><span class="line"><span class="built_in">PushOverlay</span>(<span class="keyword">new</span> HEngine::<span class="built_in">ImGuiLayer</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="十一、-给ImGui添加事件">十一、 给ImGui添加事件</h2><ul><li><p>此节目的</p><p>为了让显示在屏幕上ImGui的UI能接收GLFW窗口事件。</p></li></ul><h4 id="如何写ImGui的事件">如何写ImGui的事件</h4><ul><li><p>搞清楚原理</p><p>ImGui的事件是来自GLFW窗口的事件</p><p>（GLFW<strong>提供</strong>了函数来捕捉窗口事件，并回调自定义的函数-&gt;我们已经实现在回调自定义函数中传递给Application再传给Layer层，在Layer层中进行捕获和处理事件）</p></li><li><p>参考ImGui的imgui_impl_glfw.cpp</p><p>这个cpp里写了imgui实现处理glfw事件的<strong>回调处理事件函数</strong></p><p>所以参考imgui_impl_glfw.cpp对应的<strong>回调处理事件函数</strong>重写为ImGuiLayer层自己的回调处理函数函数</p></li></ul><h4 id="项目相关">项目相关</h4><p><strong>代码</strong></p><ul><li><p>Event增加接收字符事件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> KeyTypedEvent : <span class="keyword">public</span> KeyEvent<span class="comment">// 增加接收字符事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KeyTypedEvent</span>(<span class="type">int</span> keycode)</span><br><span class="line">        : <span class="built_in">KeyEvent</span>(keycode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;KeyTypedEvent: &quot;</span> &lt;&lt; m_KeyCode; <span class="comment">// 输出在窗口</span></span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EVENT_CLASS_TYPE</span>(KeyTyped)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>WindowsWindow.cpp增加接收字符窗口事件并回调给Application</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入字符事件</span></span><br><span class="line"><span class="built_in">glfwSetCharCallback</span>(m_Window, [](GLFWwindow* window, <span class="type">unsigned</span> <span class="type">int</span> keycode)&#123;</span><br><span class="line">    WindowData&amp; data = *(WindowData*)<span class="built_in">glfwGetWindowUserPointer</span>(window);</span><br><span class="line"></span><br><span class="line">    KeyTypedEvent <span class="built_in">event</span>(keycode);</span><br><span class="line">    data.<span class="built_in">EventCallback</span>(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Application把事件传给ImGuiLayer层</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 从Application的Event传递过来的事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnEvent</span><span class="params">(Event&amp; event)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 参考imgui_impl_glfw.cpp对应的回调处理事件函数重写为ImGuiLayer层自己的回调处理函数函数</span></span><br><span class="line">    <span class="comment">// 和之前不同的一点是：ImGui拦截了事件并处理后，不标记为处理过了，而是return false标记为没处理，将其传递给前一个层</span></span><br><span class="line">        <span class="function">EventDispatcher <span class="title">dispatcher</span><span class="params">(event)</span></span>;</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;MouseButtonPressedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnMouseButtonPressedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;MouseButtonReleasedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnMouseButtonReleasedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;MouseMovedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnMouseMovedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;MouseScrolledEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnMouseScrolledEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;KeyPressedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnKeyPressedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;KeyReleasedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnKeyReleasedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;KeyTypedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnKeyTypedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;WindowResizeEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnWindowResizeEvent));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ImGuiLayer::OnMouseButtonPressedEvent</span><span class="params">(MouseButtonPressedEvent&amp; e)</span></span>&#123;</span><br><span class="line">        ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">        io.MouseDown[e.<span class="built_in">GetMouseButton</span>()] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 不标记为处理过了，而是没处理，将其传递给前一个层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ImGuiLayer::OnKeyReleasedEvent</span><span class="params">(KeyReleasedEvent&amp; e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">        io.KeysDown[e.<span class="built_in">GetKeyCode</span>()] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ImGuiLayer::OnKeyPressedEvent</span><span class="params">(KeyPressedEvent&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">io.KeysDown[e.<span class="built_in">GetKeyCode</span>()] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">io.KeyCtrl = io.KeysDown[GLFW_KEY_LEFT_CONTROL] || io.KeysDown[GLFW_KEY_RIGHT_CONTROL];</span><br><span class="line">io.KeyShift = io.KeysDown[GLFW_KEY_LEFT_SHIFT] || io.KeysDown[GLFW_KEY_RIGHT_SHIFT];</span><br><span class="line">io.KeyAlt = io.KeysDown[GLFW_KEY_LEFT_ALT] || io.KeysDown[GLFW_KEY_RIGHT_ALT];</span><br><span class="line">io.KeySuper = io.KeysDown[GLFW_KEY_LEFT_SUPER] || io.KeysDown[GLFW_KEY_RIGHT_SUPER];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="十二、-输入事件轮询">十二、 输入事件轮询</h2><p><strong>Input接口类设计</strong><br>现在要为引擎添加新的功能，我们的应用需要能够知道键盘的输入状态，比如Unity里按住W和鼠标右键就可以实现摄像机的推进，所以引擎需要能够知道键盘的W键是否被按下</p><p>思路是通过GLFW<strong>已经提供的输入事件检测函数</strong>来检测输入事件，创建一个Input接口类，这个类根据不同平台生成对应的的Input子类，比如Windows平台下有<code>class WindowsInput : public Input</code>，Input类的接口需要判断某个键的状态、鼠标点击状态等</p><p>由于一个系统不会存在两个同样的键，也不会有两个鼠标，所以把这些函数都设计为Static函数，用单例模式，单例暴露的接口是static函数，而实现的具体方法是单例的虚函数</p><h4 id="代码">代码</h4><ul><li><p>Input.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Input&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">bool</span> <span class="title">IsKeyPressed</span><span class="params">(<span class="type">int</span> keycode)</span> </span>&#123; <span class="keyword">return</span> s_Instance-&gt;<span class="built_in">IsKeyPressedImpl</span>(keycode); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">bool</span> <span class="title">IsMouseButtonPressed</span><span class="params">(<span class="type">int</span> button)</span> </span>&#123; <span class="keyword">return</span> s_Instance-&gt;<span class="built_in">IsMouseButtonPressedImpl</span>(button); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> std::pair&lt;<span class="type">float</span>, <span class="type">float</span>&gt; <span class="title">GetMousePosition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_Instance-&gt;<span class="built_in">GetMousePositionImpl</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">float</span> <span class="title">GetMouseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_Instance-&gt;<span class="built_in">GetMouseXImpl</span>(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">float</span> <span class="title">GetMouseY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_Instance-&gt;<span class="built_in">GetMouseYImpl</span>(); &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsKeyPressedImpl</span><span class="params">(<span class="type">int</span> keycode)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsMouseButtonPressedImpl</span><span class="params">(<span class="type">int</span> button)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::pair&lt;<span class="type">float</span>, <span class="type">float</span>&gt; <span class="title">GetMousePositionImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetMouseXImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetMouseYImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> Input* s_Instance;<span class="comment">// 声明静态单例全局对象</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WindowsInput</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsInput</span> : <span class="keyword">public</span> Input&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsKeyPressedImpl</span><span class="params">(<span class="type">int</span> keycode)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsMouseButtonPressedImpl</span><span class="params">(<span class="type">int</span> button)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> std::pair&lt;<span class="type">float</span>, <span class="type">float</span>&gt; <span class="title">GetMousePositionImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetMouseXImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetMouseYImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line">Input* Input::s_Instance = <span class="keyword">new</span> <span class="built_in">WindowsInput</span>();<span class="comment">// 定义静态单例全局对象</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WindowsInput::IsKeyPressedImpl</span><span class="params">(<span class="type">int</span> keycode)</span></span>&#123;</span><br><span class="line"><span class="comment">// 获取GLFW原生窗口void*，转为GLFWwindow*</span></span><br><span class="line"><span class="keyword">auto</span> window = <span class="built_in">static_cast</span>&lt;GLFWwindow*&gt;(Application::<span class="built_in">Get</span>().<span class="built_in">GetWindow</span>().<span class="built_in">GetNativeWindow</span>());</span><br><span class="line"><span class="comment">// 通过GLFW函数来获取按键状态</span></span><br><span class="line"><span class="keyword">auto</span> state = <span class="built_in">glfwGetKey</span>(window, keycode);</span><br><span class="line"><span class="keyword">return</span> state == GLFW_PRESS || state == GLFW_REPEAT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WindowsInput::IsMouseButtonPressedImpl</span><span class="params">(<span class="type">int</span> button)</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> window = <span class="built_in">static_cast</span>&lt;GLFWwindow*&gt;(Application::<span class="built_in">Get</span>().<span class="built_in">GetWindow</span>().<span class="built_in">GetNativeWindow</span>());</span><br><span class="line"><span class="keyword">auto</span> state = <span class="built_in">glfwGetMouseButton</span>(window, button);</span><br><span class="line"><span class="keyword">return</span> state == GLFW_PRESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::pair&lt;<span class="type">float</span>, <span class="type">float</span>&gt; <span class="title">WindowsInput::GetMousePositionImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> window = <span class="built_in">static_cast</span>&lt;GLFWwindow*&gt;(Application::<span class="built_in">Get</span>().<span class="built_in">GetWindow</span>().<span class="built_in">GetNativeWindow</span>());</span><br><span class="line"><span class="type">double</span> xpos, ypos;</span><br><span class="line"><span class="built_in">glfwGetCursorPos</span>(window, &amp;xpos, &amp;ypos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123; (<span class="type">float</span>)xpos, (<span class="type">float</span>)ypos &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">WindowsInput::GetMouseXImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// C++17写法</span></span><br><span class="line"><span class="keyword">auto</span> [x, y] = <span class="built_in">GetMousePositionImpl</span>();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line"><span class="comment">// C++14以下</span></span><br><span class="line"><span class="comment">//auto x = GetMousePositionImpl();</span></span><br><span class="line"><span class="comment">//return std::get&lt;0&gt;(x);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">WindowsInput::GetMouseYImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> [x, y] = <span class="built_in">GetMousePositionImpl</span>();</span><br><span class="line"><span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="测试">测试</h4><ul><li><p>Application</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m_Running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = Input::<span class="built_in">GetMousePosition</span>();</span><br><span class="line"><span class="built_in">HE_CORE_TRACE</span>(<span class="string">&quot;&#123;0&#125;, &#123;1&#125;&quot;</span>, x, y);</span><br><span class="line">        m_Window-&gt;<span class="built_in">OnUpdate</span>();<span class="comment">// 更新glfw</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="十三、-添加Math库">十三、 添加Math库</h2><p>游戏引擎里自然少不了Vector3、Matrix以及相关的计算，如果自己写Math库，也可以允许，但是运行效率会不尽如人意，因为好的Math库能够尽可能快的完成数学运算(比如通过一次CPU指令完成矩阵的运算)，这(好像)也叫做smid，如下图所示：</p><p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/1.webp" alt="1"></p><p>为了保证效率和跨平台的能力，这里使用glm库作为引擎的数学库，glm不只是OpenGL的数学库，也可以单独抽出来使用。老样子添加到子模块，然后修改prmake，就不重复阐述了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https:<span class="comment">//github.com/g-truc/glm HEngine/vendor/glm</span></span><br></pre></td></tr></table></figure><hr><h2 id="十四、-ImGui停靠功能">十四、 ImGui停靠功能</h2><p>游戏引擎，比如Unity、UE5里的窗口都是可以拖拽和停靠(Docking)的，这是编辑器最基本的功能，可以直接用ImGui来完成，之前使用submodule的时候，都是引用该Project，然后把该submodule的源文件放进来，然而这里由于imgui里的源文件很多是我们不需要的，所以这里把其中的重要文件放到了ImGuiBuild.cpp里，直接当作头文件include进来，源码就不加在project的source列表里了</p><p>所以需要做以下事情：</p><ul><li>清除之前在ImGuiLayer.cpp里粘贴的ImGuiOpengl3Renderer和ImGuiGlfw3的相关内容，然后建立一个ImGuiBuild.cpp，把相关文件include进来(类似UnityBuild的做法)</li></ul><p><strong>设计思路</strong><br>之前的ImGuiLayer是在SandboxApp.cpp里加入的，而实际上ImGui应该是游戏引擎自带的东西，不应该是由用户定义添加到LayerStack里，所以需要为Application提供固有的ImGuiLayer成员，可以用宏括起来，Release游戏的时候，就不用这个东西，设计思路如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Application</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">           <span class="function"><span class="type">bool</span> <span class="title">OnWindowClose</span><span class="params">(WindowCloseEvent&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line">           std::unique_ptr&lt;Window&gt; m_Window;</span><br><span class="line">           ImGuiLayer* m_ImGuiLayer;<span class="comment">//添加ImGuiLayer</span></span><br><span class="line">           <span class="type">bool</span> m_Running = <span class="literal">true</span>;</span><br><span class="line">           LayerStack m_LayerStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了让每一个Layer都有一个ImGuiLayer，让每一个Layer都继承一个接口，用于绘制ImGui的内容，同时让ImGuiLayer成为HEngine内在的部分，需要在Application里面加上对应的LayerStack，与其内部的Layer一一对应，设计思路如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Layer</span> (<span class="type">const</span> std::string&amp; name = <span class="string">&quot;Layer&quot;</span>);</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Layer</span> ();</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnAttach</span><span class="params">()</span> </span>&#123;&#125;; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDettach</span><span class="params">()</span> </span>&#123;&#125;; </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnEvent</span><span class="params">(Event&amp;)</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> </span>&#123;&#125;;<span class="comment">//新增函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在Application里，先调用Layer的正常函数，再调用其ImGuiRender函数，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (m_Running)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (Layer* layer : m_LayerStack)</span><br><span class="line">&#123;</span><br><span class="line">layer-&gt;<span class="built_in">OnUpdate</span>();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">****</span><br><span class="line">m_ImGuiLayer-&gt;<span class="built_in">Begin</span>();</span><br><span class="line"><span class="keyword">for</span> (Layer* layer : m_LayerStack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 每一个Layer都在调用ImGuiRender函数</span></span><br><span class="line">layer-&gt;<span class="built_in">OnImGuiRender</span>();</span><br><span class="line">&#125;</span><br><span class="line">m_ImGuiLayer-&gt;<span class="built_in">End</span>();</span><br><span class="line">****</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遇到的问题">遇到的问题</h4><p>在完成上述功能后，就可以把ImGui对应的窗口任意拖拽了，但为了在SandboxApp展示的窗口，也就是原始的Windows的粉色窗口上绘制对应的内容，需要在ExampleLayer里的OnImGuiRender里进行绘制，代码如下所示：</p><p><strong>Sandbox.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;imgui.h&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而运行后，会报错，如下所示：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SandboxApp.obj : <span class="built_in">error</span> LNK2019: unresolved <span class="keyword">external</span> symbol </span><br></pre></td></tr></table></figure><p>大概意思就是，Linker找不到Begin、Text和End函数的定义，这是为什么呢？</p><p>这是因为HEngine引擎做成了dll，从外部可以调用的类和函数都是用HENGINE_API定义的，而ImGUI的内容是作为lib文件链接到HEngine.dll里的，ImGUI的相关API并没有声明为dllexport，到了Sandbox这里当然是找不到的</p><p>所以需要对IMGUI进行处理，使IMGUI的工程里是dllexport，直接修改他的premake5.lua文件</p><p>定义IMGUI_API这个宏为__declspec(dllimport)，就可以了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defines </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;IMGUI_API=__declspec(dllexport)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="十五、-HEngine改为静态库">十五、 HEngine改为静态库</h2><ul><li><p>dll</p><ul><li>优点<ul><li>热更新，更改引擎代码后只需重新编译dll，让多个测试项目不用重新编译能使用最新引擎代码</li><li>让客户端的链接更容易</li></ul></li><li>缺点<ul><li>dll很多警告</li><li>exe动态链接dll启动速度慢</li></ul></li></ul></li><li><p>lib</p><p>所有链接都构建到exe文件中</p></li></ul><p>需要考虑dll的优点在使用引擎的角度，引擎代码已经完成了就不需要热更新了，dll的热更新优点没有了</p><h4 id="如何将引擎从dll改为lib">如何将引擎从dll改为lib</h4><p>这里是用premake构建的工程，直接在premake5.lua文件里进行修改HEngine工程的类型就可以了。</p><p>原来的HEngine的premake部分内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project <span class="string">&quot;HEngine&quot;</span></span><br><span class="line">    location <span class="string">&quot;%&#123;prj.name&#125;&quot;</span> <span class="comment">-- 这里的location是生成的vcproj的位置</span></span><br><span class="line">    kind <span class="string">&quot;SharedLib&quot;</span><span class="comment">-- 类型为dll</span></span><br><span class="line">    staticruntime <span class="string">&quot;on&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>修改之后变为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project <span class="string">&quot;HEngine&quot;</span></span><br><span class="line">    location <span class="string">&quot;%&#123;prj.name&#125;&quot;</span> <span class="comment">-- 这里的location是生成的vcproj的位置</span></span><br><span class="line">    kind <span class="string">&quot;StaticLib&quot;</span><span class="comment">-- 类型为.lib</span></span><br><span class="line">    staticruntime <span class="string">&quot;off&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>同时，把之前的dllexport和dllimport的宏注释掉就行了，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> HE_DYNAMIC_LINK</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HE_BUILD_DLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HENGINE_API __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HENGINE_API __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HENGINE_API <span class="comment">//现在为空</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><a id="16"></a></p><hr><h2 id="十六、-渲染前准备工作">十六、 渲染前准备工作</h2><p>这里开始我们就要开始激动人心的渲染部分啦，我们选择使用OpenGL来开始工作，因为它是较为简单和容易的图形库。我们用抽象类封装渲染图形API的Context，后面可以根据不同渲染API，设置不同渲染的上下文。</p><h4 id="代码-2">代码</h4><ul><li><p>GraphicsContext.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicsContext</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SwapBuffers</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>OpenGLContext.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HEngine/Renderer/GraphicsContext.h&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GLFWwindow</span>;</span><br><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenGLContext</span> : <span class="keyword">public</span> GraphicsContext&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">OpenGLContext</span>(GLFWwindow* windowHandle);</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SwapBuffers</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">GLFWwindow* m_WindowHandle;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>OpenGLContext.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OpenGLContext.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">OpenGLContext::<span class="built_in">OpenGLContext</span>(GLFWwindow* windowHandle)</span><br><span class="line">: <span class="built_in">m_WindowHandle</span>(windowHandle)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(windowHandle, <span class="string">&quot;Window handle is numm!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLContext::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="built_in">glfwMakeContextCurrent</span>(m_WindowHandle);<span class="comment">// 设置当前线程的主上下文</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取显卡OpenGL函数定义的地址</span></span><br><span class="line">        <span class="type">int</span> status = <span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress);</span><br><span class="line">        <span class="built_in">HE_CORE_ASSERT</span>(status, <span class="string">&quot;Failed to initialize Glad!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OpenGLContext::SwapBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(m_WindowHandle);<span class="comment">// 交换缓冲</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>WindowsWindow.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsWindow</span> : <span class="keyword">public</span> Window&#123;</span><br><span class="line">    .....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">GLFWwindow* m_Window;</span><br><span class="line">GraphicsContext* m_Context;</span><br><span class="line">    .....</span><br></pre></td></tr></table></figure></li><li><p>WindowsWindow.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WindowsWindow::Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    m_Window = <span class="built_in">glfwCreateWindow</span>((<span class="type">int</span>)props.Width, (<span class="type">int</span>)props.Height, m_Data.Title.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    m_Context = <span class="keyword">new</span> <span class="built_in">OpenGLContext</span>(m_Window); <span class="comment">// 创建渲染上下文对象</span></span><br><span class="line">    m_Context-&gt;<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowUserPointer</span>(m_Window, &amp;m_Data);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="十七、-渲染第一个三角形">十七、 渲染第一个三角形!</h2><ul><li><p>此节介绍</p><p>在屏幕上用OpenGL的函数成功显示一个三角形，以及显示显卡信息。</p></li><li><p>此次渲染三角形，是直接调用OpenGL图形API，并没有抽象类来封装这些API，先了解有哪些API，后面再慢慢封装成一个个抽象类，关于OpenGL学习，视频我看的是YouTube上<a href="https://www.youtube.com/watch?v=W3gAzLwfIP0&amp;list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2">Cherno</a>的，访问不了外网的话网站推荐<a href="https://learnopengl-cn.github.io/">OpenGL中文网</a>，建议学习过之后再看以下代码</p></li></ul><h4 id="代码-3">代码</h4><ul><li><p>Application</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line">....</span><br><span class="line">Application::<span class="built_in">Application</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 顶点数据</span></span><br><span class="line">    <span class="type">float</span> vertices[<span class="number">3</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> indices[<span class="number">3</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">// 索引数据</span></span><br><span class="line">    <span class="comment">// 0.生成顶点数组对象VAO、顶点缓冲对象VBO、索引缓冲对象EBO</span></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_VertexArray);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_VertexBuffer);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_IndexBuffer);</span><br><span class="line">    <span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br><span class="line">    <span class="comment">// 2. 把我们的CPU的顶点数据复制到GPU顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_VertexBuffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 复制我们的CPU的索引数据到GPU索引缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_IndexBuffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 4. 设定顶点属性指针，来解释顶点缓冲中的顶点属性布局</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);<span class="comment">// 开启glsl的layout = 0输入</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (m_Running)&#123;</span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.绑定顶点数组对象，并开始绘制，默认使用一个白色的着色器</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br><span class="line">        <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></li></ul><h4 id="效果">效果</h4><p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/4.webp" alt="4"></p><p><strong>OpenGLContext</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLContext::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打印当前exe使用的显卡信息</span></span><br><span class="line">    <span class="built_in">HE_CORE_INFO</span>(<span class="string">&quot;OpenGL Info:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HE_CORE_INFO</span>(<span class="string">&quot;  Vendor: &#123;0&#125;&quot;</span>, (<span class="type">const</span> <span class="type">char</span>*)<span class="built_in">glGetString</span>(GL_VENDOR));</span><br><span class="line">    <span class="built_in">HE_CORE_INFO</span>(<span class="string">&quot;  Renderer: &#123;0&#125;&quot;</span>, (<span class="type">const</span> <span class="type">char</span>*)<span class="built_in">glGetString</span>(GL_RENDERER));</span><br><span class="line">    <span class="built_in">HE_CORE_INFO</span>(<span class="string">&quot;  Version: &#123;0&#125;&quot;</span>, (<span class="type">const</span> <span class="type">char</span>*)<span class="built_in">glGetString</span>(GL_VERSION));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Renderging负责在屏幕上的绘制工作，同时接受与外部Input的交互，为了表现更好的画面效果，需要使用Graphics Processing Unit（GPU），GPU的主要优点是：能并行处理、能很快的进行数学运算</p><p>对于一些电脑，可能这里不会默认使用独显，比如N卡可以在NVDIA ControlPanel里选择这个exe使用高性能的GPU处理器，如下图所示</p><p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/3.webp" alt="3"></p><hr><h2 id="十八、-添加着色器">十八、 添加着色器</h2><ul><li><p>此节目的</p><p>使用shader，让渲染的三角形有颜色，并且将关于shader的代码抽象到Shader类中</p></li><li><p>关于Shader</p><ul><li>告诉GPU如何处理我们从CPU发送到GPU的顶点数据</li><li>着色器(Shader)是运行在GPU上的小程序，分别对应渲染管理不同阶段。</li><li>着色器是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</li></ul></li><li><p>官网介绍https://www.khronos.org/opengl/wiki/Shader_Compilation</p></li></ul><h4 id="代码-4">代码</h4><ul><li><p>增加Shader类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc);</span><br><span class="line">~<span class="built_in">Shader</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">uint32_t</span> m_RendererID;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shader.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line">Shader::<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 1.1 创建顶点着色器对象</span></span><br><span class="line">GLuint vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line"><span class="comment">// 1.2 附加顶点着色器源码到顶点着色器对象中</span></span><br><span class="line"><span class="type">const</span> GLchar* source = vertexSrc.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;source, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(vertexShader);<span class="comment">// 1.3 编译顶点着色器对象</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">// 1.4 检查是否编译成功</span></span><br><span class="line">GLint isCompiled = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;isCompiled);</span><br><span class="line"><span class="keyword">if</span> (isCompiled == GL_FALSE)</span><br><span class="line">&#123;</span><br><span class="line">GLint maxLength = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(vertexShader, GL_INFO_LOG_LENGTH, &amp;maxLength);</span><br><span class="line"><span class="comment">// The maxLength includes the NULL character</span></span><br><span class="line"><span class="function">std::vector&lt;GLchar&gt; <span class="title">infoLog</span><span class="params">(maxLength)</span></span>;</span><br><span class="line"><span class="built_in">glGetShaderInfoLog</span>(vertexShader, maxLength, &amp;maxLength, &amp;infoLog[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// We don&#x27;t need the shader anymore.</span></span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="comment">// Use the infoLog as you see fit.</span></span><br><span class="line"><span class="built_in">HE_CORE_ERROR</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, infoLog.<span class="built_in">data</span>());</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Vertex shader compilation failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 片段着色器大部分和上面一样</span></span><br><span class="line">GLuint fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">source = fragmentSrc.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;source, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line"><span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;isCompiled);</span><br><span class="line"><span class="comment">//判断是否编译成功和上面一样，换个参数的事，就不写上来了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1创建着色器程序对象</span></span><br><span class="line">m_RendererID = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">GLuint program = m_RendererID;</span><br><span class="line"><span class="comment">// 3.2附加着色器对象给着色器程序对象</span></span><br><span class="line"><span class="built_in">glAttachShader</span>(program, vertexShader);</span><br><span class="line"><span class="built_in">glAttachShader</span>(program, fragmentShader);</span><br><span class="line"><span class="comment">// 3.3链接着色器程序对象</span></span><br><span class="line"><span class="built_in">glLinkProgram</span>(program);</span><br><span class="line"><span class="comment">// 3.4可以检查链接是否成功</span></span><br><span class="line">GLint isLinked = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGetProgramiv</span>(program, GL_LINK_STATUS, (<span class="type">int</span>*)&amp;isLinked);</span><br><span class="line"><span class="keyword">if</span> (isLinked == GL_FALSE)</span><br><span class="line">&#123;</span><br><span class="line">GLint maxLength = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">glGetProgramiv</span>(program, GL_INFO_LOG_LENGTH, &amp;maxLength);</span><br><span class="line"><span class="function">std::vector&lt;GLchar&gt; <span class="title">infoLog</span><span class="params">(maxLength)</span></span>;</span><br><span class="line"><span class="built_in">glGetProgramInfoLog</span>(program, maxLength, &amp;maxLength, &amp;infoLog[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">glDeleteProgram</span>(program);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line"><span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line"><span class="built_in">HE_CORE_ERROR</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, infoLog.<span class="built_in">data</span>());</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Shader compilation failure!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.删除着色器对象</span></span><br><span class="line"><span class="built_in">glDetachShader</span>(program, vertexShader);</span><br><span class="line"><span class="built_in">glDetachShader</span>(program, fragmentShader);</span><br><span class="line">&#125;</span><br><span class="line">Shader::~<span class="built_in">Shader</span>()&#123;</span><br><span class="line"><span class="built_in">glDeleteProgram</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Bind</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"><span class="built_in">glUseProgram</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::Unbind</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line"><span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Application.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Application::<span class="built_in">Application</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 着色器代码</span></span><br><span class="line">    std::string vertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string">out vec3 v_Position;</span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">v_Position = a_Position;</span></span><br><span class="line"><span class="string">gl_Position = vec4(a_Position, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">    std::string fragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string">in vec3 v_Position;</span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">color = vec4(v_Position * 0.5 + 0.5, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">    m_Shader.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Shader</span>(vertexSrc, fragmentSrc));</span><br><span class="line"><span class="comment">// 在头文件的std::unique_ptr&lt;Shader&gt; m_Shader;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m_Running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 绑定着色器</span></span><br><span class="line">        m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        <span class="comment">// 绑定顶点数组对象，并绘制</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br><span class="line">        <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>解释</p><ul><li><p>片段着色器</p><p>color = vec4(v_Position * 0.5 + 0.5, 1.0);</p><p>三个顶点颜色被确定，其围成的区域片段的颜色将会根据三个顶点颜色线性插值</p></li><li><p>着色器源码字符串书写方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的-不美观</span></span><br><span class="line">string s = <span class="string">&quot;#version 450 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;asf\n&quot;</span></span><br><span class="line"><span class="string">&quot;adf\n&quot;</span></span><br><span class="line"><span class="comment">// 用R&quot;()&quot;包围</span></span><br><span class="line">string s = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 450 core</span></span><br><span class="line"><span class="string">....</span></span><br><span class="line"><span class="string">)&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="效果-2">效果</h4><p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/5.webp" alt="5"></p><hr><h2 id="十九、-封装Buffer类">十九、 封装Buffer类</h2><ul><li><p>此节目的</p><p>对于OpenGL的生成<strong>顶点缓冲</strong>、<strong>索引缓冲</strong>这种原始代码抽象成类。</p></li><li><p>如何设计类</p><p>从想使用的API形式出发，先想像我要使用的API接口是什么样，写出调用，然后再去根据这个去写接口</p></li><li><p>渲染接口的设计</p><p>由于可以有多个渲染图形API：OpenGL、DX，若引擎支持两种渲染图形API，需要设计选择哪一个</p><ul><li><p>如果是在<strong>编译时</strong>确定选择</p><p>缺点：如果更改渲染对象，需要重新编译引擎、且运行时不能切换</p></li><li><p>如果是在<strong>运行时</strong>确定选择</p><p>缺点：编译时两个渲染相关obj都要编译</p><p>优点：能动态切换</p><p>如何实现：采用C++的动态特性，基类指针指向子类对象实现<strong>动态多态</strong></p></li></ul><p>如：VertexBuffer有静态Create函数，返回VertexBuffer*，根据选择<strong>不同渲染图形API</strong>调用return new OpenGLVertexBuffer还是DirectxVertexBuffer</p></li></ul><h4 id="代码修改">代码修改</h4><ul><li><p>Renderer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">RendererAPI</span></span><br><span class="line">&#123;</span><br><span class="line">None = <span class="number">0</span>, OpenGL = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> RendererAPI <span class="title">GetAPI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_RendererAPI; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> RendererAPI s_RendererAPI;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Renderer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hepch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">RendererAPI Renderer::s_RendererAPI = RendererAPI::OpenGL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>增加VertexBuffer与IndexBuffer类同放在Buffer文件中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexBuffer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">VertexBuffer</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> VertexBuffer* <span class="title">Create</span><span class="params">(<span class="type">float</span>* vertices, <span class="type">uint32_t</span> size)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IndexBuffer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">IndexBuffer</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">uint32_t</span> <span class="title">GetCount</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> IndexBuffer* <span class="title">Create</span><span class="params">(<span class="type">uint32_t</span>* indices, <span class="type">uint32_t</span> size)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Buffer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">VertexBuffer* <span class="title">VertexBuffer::Create</span><span class="params">(<span class="type">float</span>* vertices, <span class="type">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> RendererAPI::None: <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI::None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">case</span> RendererAPI::OpenGL: <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenGLVertexBuffer</span>(vertices, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown RendererAPI!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IndexBuffer* <span class="title">IndexBuffer::Create</span><span class="params">(<span class="type">uint32_t</span>* indices, <span class="type">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> RendererAPI::None:<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI::None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">case</span> RendererAPI::OpenGL:<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenGLIndexBuffer</span>(indices, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown RendererAPI!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>OpenGLBuffer.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenGLVertexBuffer</span> : <span class="keyword">public</span> VertexBuffer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">OpenGLVertexBuffer</span>(<span class="type">float</span>* vertices, <span class="type">uint32_t</span> size);</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">OpenGLVertexBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">uint32_t</span> m_RendererID;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenGLIndexBuffer</span> : <span class="keyword">public</span> IndexBuffer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">OpenGLIndexBuffer</span>(<span class="type">uint32_t</span>* indices, <span class="type">uint32_t</span> size);</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">OpenGLIndexBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">uint32_t</span> <span class="title">GetCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Count;  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">uint32_t</span> m_RendererID;</span><br><span class="line"><span class="type">uint32_t</span> m_Count;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OpenGLBuffer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line"><span class="comment">// VertexBuffer /</span></span><br><span class="line">OpenGLVertexBuffer::<span class="built_in">OpenGLVertexBuffer</span>(<span class="type">float</span>* vertices, <span class="type">uint32_t</span> size)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 1.创建顶点缓冲对象</span></span><br><span class="line"><span class="built_in">glCreateBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line"><span class="comment">// 2.绑定顶点缓冲对象</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line"><span class="comment">// 3. 把我们的CPU的顶点数据复制到GPU顶点缓冲中，供OpenGL使用</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, size, vertices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line">OpenGLVertexBuffer::~<span class="built_in">OpenGLVertexBuffer</span>()</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLVertexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLVertexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IndexBuffer //</span></span><br><span class="line">OpenGLIndexBuffer::<span class="built_in">OpenGLIndexBuffer</span>(<span class="type">uint32_t</span>* indices, <span class="type">uint32_t</span> count)</span><br><span class="line">: <span class="built_in">m_Count</span>(count)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 1.创建顶点缓冲对象</span></span><br><span class="line"><span class="built_in">glCreateBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line"><span class="comment">// 2.绑定顶点缓冲对象</span></span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID);</span><br><span class="line"><span class="comment">// 3. 复制我们的CPU的索引数据到GPU索引缓冲中，供OpenGL使用</span></span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, count * <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>), indices, GL_STATIC_DRAW);</span><br><span class="line">&#125;</span><br><span class="line">OpenGLIndexBuffer::~<span class="built_in">OpenGLIndexBuffer</span>()</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLIndexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLIndexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Application.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_VertexArray;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;VertexBuffer&gt; m_VertexBuffer;</span><br><span class="line">std::unique_ptr&lt;IndexBuffer&gt; m_IndexBuffer;</span><br></pre></td></tr></table></figure><p>Application.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="type">float</span> vertices[<span class="number">3</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">  <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[<span class="number">3</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;; </span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_VertexArray);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br><span class="line"><span class="comment">/* 删除</span></span><br><span class="line"><span class="comment">glGenBuffers(1, &amp;m_VertexBuffer);</span></span><br><span class="line"><span class="comment">glBindBuffer(GL_ARRAY_BUFFER, m_VertexBuffer);</span></span><br><span class="line"><span class="comment">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">m_VertexBuffer.<span class="built_in">reset</span>(VertexBuffer::<span class="built_in">Create</span>(vertices, <span class="built_in">sizeof</span>(vertices)));<span class="comment">//换成</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="literal">nullptr</span>);</span><br><span class="line">.....</span><br><span class="line">m_IndexBuffer.<span class="built_in">reset</span>(IndexBuffer::<span class="built_in">Create</span>(indices, <span class="built_in">sizeof</span>(indices) <span class="comment">//换成</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="二十、-设计顶点缓冲区布局">二十、 设计顶点缓冲区布局</h2><p>此节目的，抽象<strong>顶点缓冲布局</strong>类：给出对应顶点着色器输入一样的格式，使能够<strong>自动</strong>计算每个属性的偏移量、分量大小，总大小，而不用手动计算</p><h4 id="代码-5">代码</h4><p>Buffer.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shdader数据类型</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderDataType</span>&#123;</span><br><span class="line">    None = <span class="number">0</span>, Float, Float2, Float3, Float4, Mat3, Mat4, Int, Int2, Int3, Int4, Bool</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 获取Shader数据类型的大小</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title">ShaderDataTypeSize</span><span class="params">(ShaderDataType type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Float:    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Float2:   <span class="keyword">return</span> <span class="number">4</span> * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Float3:   <span class="keyword">return</span> <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Float4:   <span class="keyword">return</span> <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Mat3:     <span class="keyword">return</span> <span class="number">4</span> * <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Mat4:     <span class="keyword">return</span> <span class="number">4</span> * <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Int:      <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Int2:     <span class="keyword">return</span> <span class="number">4</span> * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Int3:     <span class="keyword">return</span> <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Int4:     <span class="keyword">return</span> <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Bool:     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown ShaderDataType!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Shader属性类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BufferElement</span>&#123; </span><br><span class="line">    std::string Name;</span><br><span class="line">    ShaderDataType Type;</span><br><span class="line">    <span class="type">uint32_t</span> Size;</span><br><span class="line">    <span class="type">uint32_t</span> Offset;</span><br><span class="line">    <span class="type">bool</span> Normalized;</span><br><span class="line">    <span class="built_in">BufferElement</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">BufferElement</span>(ShaderDataType type, <span class="type">const</span> std::string&amp; name, <span class="type">bool</span> normalized = <span class="literal">false</span>)</span><br><span class="line">        : <span class="built_in">Name</span>(name), <span class="built_in">Type</span>(type), <span class="built_in">Size</span>(<span class="built_in">ShaderDataTypeSize</span>(type)), <span class="built_in">Offset</span>(<span class="number">0</span>), <span class="built_in">Normalized</span>(normalized)</span><br><span class="line">        &#123; &#125;</span><br><span class="line">    <span class="comment">// 获取此属性有几个分量</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetComponentCount</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (Type) &#123;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Float:   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Float2:  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Float3:  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Float4:  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Mat3:    <span class="keyword">return</span> <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Mat4:    <span class="keyword">return</span> <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Int:     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Int2:    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Int3:    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Int4:    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Bool:    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown ShaderDataType!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 顶点缓冲布局抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferLayout</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferLayout</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 用初始化列表构造BufferLayout对象</span></span><br><span class="line">    <span class="built_in">BufferLayout</span>(<span class="type">const</span> std::initializer_list&lt;BufferElement&gt;&amp; elements)</span><br><span class="line">        : <span class="built_in">m_Elements</span>(elements)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CalculateOffsetsAndStride</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">GetStride</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Stride; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> std::vector&lt;BufferElement&gt;&amp; <span class="title">GetElements</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Elements; &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;BufferElement&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Elements.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    std::vector&lt;BufferElement&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Elements.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    std::vector&lt;BufferElement&gt;::<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Elements.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    std::vector&lt;BufferElement&gt;::<span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Elements.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 计算属性列表各个属性的偏移量,跨步长</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CalculateOffsetsAndStride</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> offset = <span class="number">0</span>;</span><br><span class="line">        m_Stride = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : m_Elements)&#123;</span><br><span class="line">            element.Offset = offset;</span><br><span class="line">            offset += element.Size;</span><br><span class="line">            m_Stride += element.Size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;BufferElement&gt; m_Elements;</span><br><span class="line">    <span class="type">uint32_t</span> m_Stride = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>OpenGLBuffer.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> BufferLayout&amp; <span class="title">GetLayout</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Layout;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetLayout</span><span class="params">(<span class="type">const</span> BufferLayout&amp; layout)</span> <span class="keyword">override</span> </span>&#123; m_Layout = layout; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">BufferLayout m_Layout;</span><br></pre></td></tr></table></figure><p>Application.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> GLenum <span class="title">ShaderDataTypeToOpenGLBaseType</span><span class="params">(ShaderDataType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Float:<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Float2:<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Float3:<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Float4:<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Mat3:<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Mat4:<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Int:    <span class="keyword">return</span> GL_INT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Int2:<span class="keyword">return</span> GL_INT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Int3:<span class="keyword">return</span> GL_INT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Int4:<span class="keyword">return</span> GL_INT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Bool:<span class="keyword">return</span> GL_BOOL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknow ShaderDataType!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*删除</span></span><br><span class="line"><span class="comment">float vertices[3 * 3] = &#123;</span></span><br><span class="line"><span class="comment">    -0.5f, -0.5f, 0.0f,</span></span><br><span class="line"><span class="comment">     0.5f, -0.5f, 0.0f,</span></span><br><span class="line"><span class="comment">     0.0f,  0.5f, 0.0f</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">float</span> vertices[<span class="number">3</span> * <span class="number">7</span>] = &#123;<span class="comment">//加上颜色数据</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">/*删除</span></span><br><span class="line"><span class="comment">glEnableVertexAttribArray(0);</span></span><br><span class="line"><span class="comment">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), nullptr);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#123;</span><br><span class="line">    BufferLayout layout = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123; ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;,</span><br><span class="line">        &#123; ShaderDataType::Float4, <span class="string">&quot;a_Color&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    m_VertexBuffer-&gt;<span class="built_in">SetLayout</span>(layout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; layout = m_VertexBuffer-&gt;<span class="built_in">GetLayout</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : layout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(index);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(index,</span><br><span class="line">        element.<span class="built_in">GetComponentCount</span>(),</span><br><span class="line">        <span class="built_in">ShaderDataTypeToOpenGLBaseType</span>(element.Type),</span><br><span class="line">        element.Normalized ? GL_TRUE : GL_FALSE,</span><br><span class="line">        layout.<span class="built_in">GetStride</span>(),</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span>*)element.Offset);</span><br><span class="line"></span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">std::string vertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string">    layout(location = 1) in vec4 a_Color;</span></span><br><span class="line"><span class="string">    out vec3 v_Position;</span></span><br><span class="line"><span class="string">    out vec4 v_Color;</span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        v_Position = a_Position;</span></span><br><span class="line"><span class="string">        v_Color = a_Color;</span></span><br><span class="line"><span class="string">        gl_Position = vec4(a_Position, 1.0);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">std::string fragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 450 core</span></span><br><span class="line"><span class="string">    layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string">    in vec3 v_Position;</span></span><br><span class="line"><span class="string">    in vec4 v_Color;</span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        color = vec4(v_Position * 0.5 + 0.5, 1.0);</span></span><br><span class="line"><span class="string">        color = v_Color;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>效果:</strong></p><p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/6.webp" alt="6"></p><hr><h2 id="二十一、添加顶点数组">二十一、添加顶点数组</h2><p>OpenGL里的VAO，其实本身不包含任何Buffer的数据，它只是记录了Vertex Buffer和IndexBuffer的引用，并且使用<code>glVertexAttribPointer</code>函数来决定VAO通过哪种方式来挖取 VBO中的数据。</p><p>这节目的是创建Vertex Array类，由于OpenGL有VAO这个东西，而DX里完全没有这个概念，但是前期的HEngine引擎是极大程度依赖OpenGL的，所以目前是先创建VertexArray类</p><p>Application.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建VertexArray，这一段还没抽象化</span></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_VertexArray);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一段已经成功抽象化了</span></span><br><span class="line">&#123;</span><br><span class="line">BufferLayout layout = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123; ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;,</span><br><span class="line">        &#123; ShaderDataType::Float4, <span class="string">&quot;a_Color&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    vertexBuffer-&gt;<span class="built_in">SetLayout</span>(layout);</span><br><span class="line">    m_VertexArray-&gt;<span class="built_in">AddVertexBuffer</span>(vertexBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BufferLayout layout = m_VertexBuffer-&gt;<span class="built_in">GetBufferLayout</span>();</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2. 指定VAO挖数据的方法，这一段也没抽象化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> BufferElement&amp; element : layout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(index);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(index,</span><br><span class="line"><span class="built_in">GetShaderTypeDataCount</span>(element.<span class="built_in">GetType</span>()),</span><br><span class="line"><span class="built_in">GetShaderDataTypeToOpenGL</span>(element.<span class="built_in">GetType</span>()), </span><br><span class="line">element.<span class="built_in">IsNormalized</span>()? GL_TRUE : GL_FALSE,</span><br><span class="line">layout.<span class="built_in">GetStride</span>(),</span><br><span class="line">(<span class="type">const</span> <span class="type">void</span>*)(element.<span class="built_in">GetOffset</span>()));</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是正式开始写代码了。</p><p>前面两句代码要把它抽象化，也就是把它变成跟平台无关的东西，跟之前创建的VertexBuffer和IndexBuffer都差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_VertexArray);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br></pre></td></tr></table></figure><p>这里单独建一个<code>VertexArray</code>的cpp和h文件，之所以单独建立cpp和h文件，是因为还不确定相关的VertexArray的内容以后还会不会会保留，毕竟DX里是没有这个概念的</p><p>VertexArray.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接复制VertexBuffer的相关内容就行：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 这些都是跟VertexBuffer和IndexBuffer的接口一样的</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">VertexArray</span>() &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;<span class="comment">//Unbind函数一般用于debuging purposes</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> VertexArray* <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于一个VAO可以挖取多个VBO的数据，所以需要添加记录相关VBO引用的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddVertexBuffer</span><span class="params">(<span class="type">const</span> std::shared_ptr &lt; VertexBuffer&gt;&amp; vertexBuffer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetIndexBuffer</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;IndexBuffer&gt;&amp; indexBuffer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">const</span> std::vector&lt;std::shared_ptr&lt;VertexBuffer&gt;&gt;&amp; <span class="built_in">GetVertexBuffers</span>() <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::shared_ptr&lt;IndexBuffer&gt;&amp; <span class="title">GetIndexBuffer</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>VertexArray.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">VertexArray* <span class="title">VertexArray::Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> RendererAPI::None:  <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI::None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">case</span> RendererAPI::OpenGL: <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenGLVertexArray</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknow RendererAPI!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是创建OpenGLVertexArray的头文件和cpp文件了，放到Platform的文件夹里，实现过程跟OpenGLVertexBuffer差不多</p><p>OpenGLVertexArray.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLVertexArray::AddVertexBuffer</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexBuffer&gt;&amp; vertexBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(vertexBuffer-&gt;<span class="built_in">GetLayout</span>().<span class="built_in">GetElements</span>().<span class="built_in">size</span>(), <span class="string">&quot;Vertex Buffer has no layout!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glBindVertexArray</span>(m_RendererID);</span><br><span class="line">vertexBuffer-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; layout = vertexBuffer-&gt;<span class="built_in">GetLayout</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : layout)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(index);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(index,</span><br><span class="line">element.<span class="built_in">GetComponentCount</span>(),</span><br><span class="line"><span class="built_in">ShaderDataTypeToOpenGLBaseType</span>(element.Type),</span><br><span class="line">element.Normalized ? GL_TRUE : GL_FALSE,</span><br><span class="line">layout.<span class="built_in">GetStride</span>(),</span><br><span class="line">(<span class="type">const</span> <span class="type">void</span>*)element.Offset);</span><br><span class="line"></span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">m_VertexBuffers.<span class="built_in">push_back</span>(vertexBuffer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLVertexArray::SetIndexBuffer</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;IndexBuffer&gt;&amp; indexBuffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(m_RendererID);</span><br><span class="line">indexBuffer-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">m_IndexBuffer = indexBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="多个VBO来验证">多个VBO来验证</h4><p>做到这里其实就差不多了，但是为了验证之前做的是正确的，创建了一个应用场景，就是通过使用两个Shader，一个VAO，两个VBO，一个EBO来绘制出来</p><p><strong>创建第二个VertexArray</strong><br>前面画了个三角形，下面再画一个Quad，在Application类里创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;VertexArray&gt; m_QuadVertexArray;</span><br></pre></td></tr></table></figure><p>然后按照同样的方式，创建VAO、VBO和顶点数据，再创建一个Shader，这里做一个只输出蓝色的Shader，就可以了，最后在Loop里分别绑定VBO和Shader就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> squareVertices[<span class="number">3</span> * <span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="number">-0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.75f</span>,  <span class="number">0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.75f</span>,  <span class="number">0.75f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;VertexBuffer&gt; squareVB;</span><br><span class="line">squareVB.<span class="built_in">reset</span>(VertexBuffer::<span class="built_in">Create</span>(squareVertices, <span class="built_in">sizeof</span>(squareVertices)));</span><br><span class="line">squareVB-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">    &#123; ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">m_SquareVA-&gt;<span class="built_in">AddVertexBuffer</span>(squareVB);</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> squareIndices[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span> &#125;;</span><br><span class="line">std::shared_ptr&lt;IndexBuffer&gt; squareIB;</span><br><span class="line">squareIB.<span class="built_in">reset</span>(IndexBuffer::<span class="built_in">Create</span>(squareIndices, <span class="built_in">sizeof</span>(squareIndices) / <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line">m_SquareVA-&gt;<span class="built_in">SetIndexBuffer</span>(squareIB);</span><br><span class="line"></span><br><span class="line">std::string blueShaderVertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out vec3 v_Position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    v_Position = a_Position;</span></span><br><span class="line"><span class="string">    gl_Position = vec4(a_Position, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::string blueShaderFragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">in vec3 v_Position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    color = vec4(0.2, 0.3, 0.8, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">m_BlueShader.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Shader</span>(blueShaderVertexSrc, blueShaderFragmentSrc));</span><br><span class="line"></span><br><span class="line">m_BlueShader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">m_SquareVA-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, m_SquareVA-&gt;<span class="built_in">GetIndexBuffer</span>()-&gt;<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">m_VertexArray-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, m_VertexArray-&gt;<span class="built_in">GetIndexBuffer</span>()-&gt;<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/7.webp" alt="7"></p><hr><h2 id="二十二、设计渲染器架构">二十二、设计渲染器架构</h2><p>从无到有，绘制出了三角形，然后把相关的VerterBuffer、VertexArray、IndexBuffer进行了抽象化，也就是说目前Application里不会有具体的OpenGL这种平台相关的代码，只剩下里面的glDrawElements函数、glClear和glClearColor没有抽象化。</p><p>前面做的抽象化，比如VertexBuffer、VertexArray，这些都是渲染要用到的相关概念的类抽象，真正的跨平台 用于渲染的Renderer类还没有创建起来。</p><p>思考一下，<strong>一个Renderer需要干什么</strong> 它需要Render一个Geometry。Render一个Geometry需要以下内容：</p><ul><li>一个Vertex Array，包含了VertexBuffers和一个IndexBuffer</li><li>一个Shader</li><li>人物的视角，即Camera系统，本质上就是一个Projection和View矩阵</li><li>绘制物体的所在的世界坐标，前面的VertexBuffer里记录的是局部坐标，也就是Model(World)矩阵</li><li>Cube表面的材质属性，wooden或者plastic，金属度等相关属性，这个也可以属于Shader的范畴</li><li>环境信息：比如环境光照、比如Environment Map、Radiance Map</li></ul><p>这些信息可以分为两类：</p><ul><li>环境相关的信息：渲染不同的物体时，环境信息也一般是相同的，比如环境光照、人物的视角等</li><li>被渲染的物体相关的信息：不同物体的相关信息很多是不同的，比如VertexArray，也可能部分属性相同（比如材质），这些相同的内容可以在批处理里进行处理，从而优化性能</li></ul><p>总结得到，<strong>一个Renderer应该具有以下功能</strong>：</p><ul><li>设置环境相关的信息</li><li>接受被渲染的物体，传入它对应的数据，比如Vertex Array、引用的Material和Shader</li><li>渲染物体，调用DrawCall</li><li>批处理，为了优化性能，把相同材质的物体一起渲染等</li></ul><p>可以把Renderer每帧执行的任务分为四个步骤：</p><ul><li>BeginScene: 负责每帧渲染前的环境设置</li><li>Submit：收集场景数据，同时收集渲染命令，提交渲染命令到队列里</li><li>EndScene：对收集到的场景数据进行优化</li><li>Render：按照渲染队列，进行渲染</li></ul><p>具体步骤如下：<br><strong>1. BeginScene</strong><br>由于环境相关的信息是相同的，所以在Renderer开始渲染的阶段，需要先搭建相关环境，为此设计了一个Begin Scene函数。Begin Scene阶段，基本就是告诉Renderer，我要开始渲染一个场景，然后会设置其周围的环境（比如环境光照）、Camera。</p><p><strong>2. Submit</strong><br>这个阶段，就可以渲染每一个Mesh了，他们的Transform矩阵一般是不同的，依次传给Renderer就可以了，这里会把所有的渲染命令都commit到RenderCommandQueue里。</p><p><strong>3. End Scene</strong><br>应该是在这个阶段，在收集完场景数据后，做一些优化的操作，比如</p><ul><li>把使用相同的材质的物体合并到一起(Batch)</li><li>把在Frustum外部的物体Cull掉</li><li>根据位置进行排序</li></ul><p><strong>4. Render</strong><br>在把所有的东西都commit到RenderCommandQueue里后，所有的Scene相关的东西，现在Renderer都处理好了，也都拥有了该数据，就可以开始渲染了。</p><p>整体四个过程的代码大体如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Render Run里</span></span><br><span class="line"><span class="keyword">while</span> (m_Running)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这个ClearColor是游戏最底层的颜色，一般不会出现在用户界面里，可能用得比较少</span></span><br><span class="line">RenderCommand::<span class="built_in">SetClearColor</span>();<span class="comment">// 参数省略</span></span><br><span class="line">RenderCommand::<span class="built_in">Clear</span>();</span><br><span class="line">RenderCommand::<span class="built_in">DrawIndexed</span>();</span><br><span class="line"></span><br><span class="line">Renderer::<span class="built_in">BeginScene</span>();<span class="comment">// 用于设置Camera、Environment和lighting等</span></span><br><span class="line">Renderer::<span class="built_in">Submit</span>();<span class="comment">// 提交Mesh给Renderer</span></span><br><span class="line">    Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 在多线程渲染里，可能会在这个阶段用一个另外的线程执行Render::Flush操作，需要结合Render Command Queue</span></span><br><span class="line">Renderer::<span class="built_in">Flush</span>();</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="本节要做的实际内容">本节要做的实际内容</h4><p>上面虽然介绍完了渲染架构，大体上是统一处理物体，然后统一渲染，但是由于目前相关的架构还没搭起来，所以这仍然是Bind一个VAO，然后调用一次DrawCall，以后会改进的。</p><p>目前就剩glClear、glClearColor和DrawCall的代码需要抽象化了，也就是这三句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, m_QuadVertexArray-&gt;<span class="built_in">GetIndexBuffer</span>()-&gt;<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>这些代码，打算把它抽象为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个ClearColor是游戏最底层的颜色，一般不会出现在用户界面里，用洋红色这种offensive的颜色比较好</span></span><br><span class="line">RenderCommand::<span class="built_in">SetClearColor</span>(glm::<span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>));<span class="comment">// 直接用glm里的vec4好了</span></span><br><span class="line">RenderCommand::<span class="built_in">Clear</span>();</span><br><span class="line">RenderCommand::<span class="built_in">DrawIndexed</span>();</span><br></pre></td></tr></table></figure><p>然后对于原本的Renderer里的GetAPI函数，它应该由RendererAPI负责, 而不是Renderer负责，这里新建RendererAPI类，除了要有标识当前使用的API类型的函数外，还需要有很多与平台无关的渲染的API，比如清空Buffer、根据Vertex Array进行调用DrawCall等函数</p><p>RendererAPI.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RendererAPI</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">API</span></span><br><span class="line">&#123;</span><br><span class="line">None = <span class="number">0</span>, OpenGL = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetClearColor</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawIndexed</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> API <span class="title">GetAPI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_API; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> API s_API;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在RendererAPI的cpp文件里进行初始化：</span></span><br><span class="line">RendererAPI::API RendererAPI::s_API = RendererAPI::API::OpenGL;</span><br></pre></td></tr></table></figure><p>RendererAPI是一个接口类，与平台无关，现在就可以实现OpenGL平台的OpenGLRendererAPI了，Platform文件夹下创建对应的cpp和h文件，跟之前的做法类似，不多说。</p><p>OpenGLRendererAPI.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::SetClearColor</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glClearColor</span>(color.r, color.g, color.b, color.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::Clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::DrawIndexed</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, vertexArray-&gt;<span class="built_in">GetIndexBuffer</span>()-&gt;<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是<strong>实现Renderer类</strong>了，目前这个类只实现了一个GetAPIType函数，类的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 未来会接受Scene场景的相关参数，比如Camera、lighting, 保证shaders能够得到正确的环境相关的uniforms</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BeginScene</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">EndScene</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 会把VAO通过RenderCommand下的指令，传递给RenderCommandQueue</span></span><br><span class="line"><span class="comment">// 目前偷个懒，直接调用RenderCommand::DrawIndexed()函数</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> RendererAPI::API <span class="title">GetAPIType</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> RendererAPI::<span class="built_in">GetAPIType</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后面会再去实现成员函数，现在先把类都声明好，还剩一个<strong>RenderCommand类</strong>了，同样创建一个RenderCommand.h头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RenderCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 注意RenderCommand里的函数都应该是单一功能的函数，不应该有其他耦合的任何功能</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">DrawIndexed</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 比如这里不可以调用vertexArray-&gt;Bind()函数</span></span><br><span class="line">s_RenderAPI-&gt;<span class="built_in">DrawIndexed</span>(vertexArray);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同上，再实现Clear和ClearColor的static函数 </span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> RendererAPI* s_RenderAPI;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，RenderCommand类只是把RendererAPI的内容，做了一个静态的封装，这样做是为了以后把函数加入到RenderCommandQueue里做的架构设计，也是为了后面的多线程渲染做铺垫。</p><p>然后在Renderer的submit函数里实现下面的内容即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vertexArray-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(vertexArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此我们渲染框架就大致完成了，Application里已经没有OpenGL原生函数就可以完成绘制了</p><p>Application.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (m_Running)</span><br><span class="line">&#123;</span><br><span class="line">        ....</span><br><span class="line">Renderer::<span class="built_in">BeginScene</span>();</span><br><span class="line">        m_BlueShader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        Renderer::<span class="built_in">Submit</span>(m_QuadVertexArray);</span><br><span class="line"></span><br><span class="line">        m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        Renderer::<span class="built_in">Submit</span>(m_VertexArray);</span><br><span class="line"></span><br><span class="line">        Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二十三、正交摄像机实现">二十三、正交摄像机实现</h2><p>先介绍一些Camera的概念，相机系统的代码框架(architecture)很重要，它决定了游戏引擎能否将更多的时间花在渲染上，从而提高帧数。Camera除了与渲染相关，还与玩家有着交互， 比如User Input、比如玩家移动的时候，Camera往往也需要移动，所以说，Camera既受GamePlay影响，也会被Submit到Renderer做渲染工作</p><p>Camera本身是一个虚拟的概念，它的本质其实就是View和Projection矩阵的设置，其属性有：</p><ul><li>相机的位置</li><li>相机的相关属性，比如FOV，比如Aspect Ratio</li><li>还有MVP三个矩阵（以下个人理解不一定对），M是与模型密切相关的，但是不同模型在同一个相机下，V和P矩阵是相同的，所以说，<strong>VP矩阵属于相机的属性</strong>。举个简单的例子，在日常生活中你去拍照，你首先会取景，然后把你想拍的东西都摆放好，这一步叫做model transformation（模型变换）。接下来你肯定会挑选一个特定的角度摆放你的摄像机，这一步就叫做view transformation（视图变换）。然后按下快门后把图片拍下来，这一步就叫做projection transformation（投影变换）。</li></ul><p>实际渲染时，默认相机都是在世界坐标系原点，朝向-z方向看的，当调整相机属性时，其实没有Camera这个实物，实际上是整个世界的物体在靠近相机，即往Camera这边平移；当我们向左移动相机的时候，，实际上我们是把所有世界的物体向右移，所以，相机的transform变化矩阵与物体的transform变化矩阵正好是互逆的。也就是说，我们可以通过记录相机的transformation矩阵，然后取逆矩阵，就可以得到对应的View矩阵了，这里只需要Position和Rotation，因为相机是没有缩放的。</p><p>根据投影方式的不同，分为了透视投影的Camera和正交投影的Camera，这一节先实现更简单的正交投影的Camera。</p><h4 id="代码-6">代码</h4><ul><li><p>OrthographicCamera.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrthographicCamera</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrthographicCamera</span>(<span class="type">float</span> left, <span class="type">float</span> right, <span class="type">float</span> bottom, <span class="type">float</span> top);</span><br><span class="line">    <span class="function"><span class="type">const</span> glm::vec3&amp; <span class="title">GetPosition</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Position; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetPosition</span><span class="params">(<span class="type">const</span> glm::vec3&amp; position)</span> </span>&#123; m_Position = position; <span class="built_in">RecalculateViewMatrix</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetRotation</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Rotation; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetRotation</span><span class="params">(<span class="type">float</span> rotation)</span> </span>&#123; m_Rotation = rotation; <span class="built_in">RecalculateViewMatrix</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> glm::mat4&amp; <span class="title">GetProjectionMatrix</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_ProjectionMatrix; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> glm::mat4&amp; <span class="title">GetViewMatrix</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_ViewMatrix; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> glm::mat4&amp; <span class="title">GetViewProjectionMatrix</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_ViewProjectionMatrix; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecalculateViewMatrix</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    glm::mat4 m_ProjectionMatrix;</span><br><span class="line">    glm::mat4 m_ViewMatrix;</span><br><span class="line">    glm::mat4 m_ViewProjectionMatrix;</span><br><span class="line">    glm::vec3 m_Position = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;<span class="comment">// 位置</span></span><br><span class="line">    <span class="type">float</span> m_Rotation = <span class="number">0.0f</span>;<span class="comment">// 绕z轴的旋转角度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>OrthographicCamera.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化用glm计算正交投影矩阵</span></span><br><span class="line">OrthographicCamera::<span class="built_in">OrthographicCamera</span>(<span class="type">float</span> left, <span class="type">float</span> right, <span class="type">float</span> bottom, <span class="type">float</span> top)</span><br><span class="line">    : <span class="built_in">m_ProjectionMatrix</span>(glm::<span class="built_in">ortho</span>(left, right, bottom, top, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)), <span class="built_in">m_ViewMatrix</span>(<span class="number">1.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 投影观察矩阵计算</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OrthographicCamera::RecalculateViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 观察矩阵</span></span><br><span class="line">    glm::mat4 transform = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_Position) *</span><br><span class="line">        glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(m_Rotation), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    m_ViewMatrix = glm::<span class="built_in">inverse</span>(transform);</span><br><span class="line">    m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Renderer.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BeginScene</span><span class="params">(OrthographicCamera&amp; camera)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Shader&gt;&amp; shader, <span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SceneData</span> &#123;</span><br><span class="line">        glm::mat4 ViewProjectionMatrix;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> SceneData* m_SceneData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Renderer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Renderer::SceneData* Renderer::m_SceneData = <span class="keyword">new</span> Renderer::SceneData;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::BeginScene</span><span class="params">(OrthographicCamera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_SceneData-&gt;ViewProjectionMatrix = camera.<span class="built_in">GetViewProjectionMatrix</span>(); <span class="comment">// 保存计算的Projection * view矩阵</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Shader&gt;&amp; shader, <span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shader-&gt;<span class="built_in">Bind</span>();<span class="comment">// 着色器绑定</span></span><br><span class="line">    shader-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_ViewProjection&quot;</span>, m_SceneData-&gt;ViewProjectionMatrix);<span class="comment">// 上传投影观察矩阵</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Shader.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::UploadUniformMat4</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::mat4&amp; matrix)</span></span>&#123;</span><br><span class="line">    GLint location = <span class="built_in">glGetUniformLocation</span>(m_RendererID, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(location, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(matrix));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Application</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrthographiCamera m_Camera;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Application::<span class="built_in">Application</span>() : <span class="built_in">m_Camera</span>(<span class="number">-1.6f</span>, <span class="number">1.6f</span>, <span class="number">-0.9f</span>, <span class="number">0.9f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::string vertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string">layout(location = 1) in vec4 a_Color;</span></span><br><span class="line"><span class="string">uniform mat4 u_ViewProjection;//新增</span></span><br><span class="line"><span class="string">out vec3 v_Position;</span></span><br><span class="line"><span class="string">out vec4 v_Color;</span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">v_Position = a_Position;</span></span><br><span class="line"><span class="string">v_Color = a_Color;</span></span><br><span class="line"><span class="string">gl_Position = u_ViewProjection * vec4(a_Position, 1.0);//新增</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m_Running)&#123;</span><br><span class="line"></span><br><span class="line">        m_Camera.<span class="built_in">SetPosition</span>(&#123; <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span> &#125;);  <span class="comment">//新增</span></span><br><span class="line">        m_Camera.<span class="built_in">SetRotation</span>(<span class="number">45.0f</span>);<span class="comment">//新增</span></span><br><span class="line"></span><br><span class="line">        Renderer::<span class="built_in">BeginScene</span>(m_Camera);</span><br><span class="line"></span><br><span class="line">        Renderer::<span class="built_in">Submit</span>(m_BlueShader, m_SquareVA);</span><br><span class="line">        Renderer::<span class="built_in">Submit</span>(m_Shader, m_VertexArray);</span><br><span class="line"></span><br><span class="line">        Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="遇到的问题-2">遇到的问题</h4><ul><li><p>正方形变成长方形</p><p>窗口是1280 * 720，当glm::ortho(-1.0f,1.0f, -1.0f, 1.0f, -1.0f, 1.0f);时候，本来正方形的蓝色quad变为长方形</p></li><li><p>修复变回正方形</p><p>在1280*720下，left right需传入1280/720=1.7左右，将宽放大，从而<strong>左右视角变大</strong>，物体围成的宽范围<strong>缩小</strong>，从而变回正方形。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Application::<span class="built_in">Application</span>()</span><br><span class="line">    :<span class="built_in">m_Camera</span>(<span class="number">-1.6f</span>, <span class="number">1.6f</span>, <span class="number">-0.9f</span>, <span class="number">0.9f</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="GLM库函数相关">GLM库函数相关</h4><ul><li><p>glm::ortho（left,right, bottom, top, -1.0f, 1.0f）;</p><p>left = -1.0f；right = 1.0f；bottom = -1.0f；top = 1.0f</p><p>得到的矩阵是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span>  <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span>  <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span>  <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>glm::<strong>translate</strong>(glm::mat4(1.0f), m_Position);</p><p>m_Position= {0.5f, 0.5f, 0.5f};</p><p>glm::mat4(1.0f)，是4x4的单位矩阵</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>glm::translate(glm::mat4(1.0f), m_Position);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    glm::translate函数中</span></span><br><span class="line"><span class="comment">    mat&lt;4, 4, T, Q&gt; Result(m); </span></span><br><span class="line"><span class="comment">    Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];</span></span><br><span class="line"><span class="comment">    Result[3]是第4行，m[0]是第1行，m[1]是第2行，m[2]是第3行。。。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0.5</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0.5</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="二十四、添加Timestep系统">二十四、添加Timestep系统</h2><p>现在的HEngine游戏引擎里，一秒内调用多少次OnUpdate函数，完全是取决于CPU的(当开启VSync则取决于显示器的频率)。假如我设计一个用代码控制相机移动的功能</p><p>此时会出现一个问题：如果同时在不同的机器上执行这段代码，性能更好的CPU，1s内循环跑的此时越多，相机会移动的更快。不同的机器的执行效果不一样，这肯定是不行的，所以要设计<strong>TimeStep</strong>系统。</p><h4 id="三种不同的Timestep系统">三种不同的Timestep系统</h4><p>一般来说，有三种Timestep系统，它们都用来帮助解决不同机器上循环执行速度不同的问题：</p><ul><li>固定delta time的Timestep系统</li><li>灵活delta time的Timestep系统，delta time取决于此帧用时</li><li>半固定delta time的Timestep系统(Semi-fixed timestep)</li></ul><h4 id="HEngine引擎里的Timestep系统">HEngine引擎里的Timestep系统</h4><p>由于目前没有物理引擎部分，所以这里选择了上面说的第二种<strong>Timestep系统</strong>。</p><p>第二种<strong>Timestep</strong>系统的设计原理是：虽然不同机器执行一次Loop函数的用时不同，但只要把每一帧里的运动，跟该帧所经历的时间相乘，就能抵消因为帧率导致的数据不一致的问题。</p><ul><li><p>计算deltatime</p><p>HZ为60的，1/60 = 0.01666666</p><p>HZ为100的，1/100 = 0.01</p><p>由于 <code>deltaTime</code> 变小，高帧率时每帧移动距离会自动缩小，确保一致的运动。</p></li></ul><p>所以只需要记录每帧的DeltaTime，然后在Movement里乘以它即可，具体其实就是把之前在循环里调用的函数，比如<code>OnUpdate</code>函数，从无参函数变成带一个TimeStep参数的函数而已，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============== Timestep.cpp =============</span></span><br><span class="line"><span class="comment">// Timestep 实际就是一个float值的wrapper</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timestep</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Timestep</span>(<span class="type">float</span> time = <span class="number">0.0f</span>)</span><br><span class="line">: <span class="built_in">m_Time</span>(time)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Time; &#125;</span><br><span class="line"><span class="comment">// 给float添加wrapper是方便进行秒和毫秒的转换</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetSeconds</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Time; &#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetMilliseconds</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Time * <span class="number">1000.0f</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> m_Time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ============== Application.cpp =============</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(m_Running)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">float</span> time = (<span class="type">float</span>)<span class="built_in">GetTime</span>();</span><br><span class="line"></span><br><span class="line">Timestep timestep = time - m_LastFrameTIme;</span><br><span class="line">m_LastFrameTime = time; </span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">        layer-&gt;<span class="built_in">OnUpdate</span>(timestep);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//============== Sandbox.cpp =============</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(HEngine::Timestep ts)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HEngine::RenderCommand::<span class="built_in">SetClearColor</span>(&#123; <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1</span> &#125;);</span><br><span class="line">HEngine::RenderCommand::<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">m_Camera.<span class="built_in">SetPosition</span>(m_CameraPosition);</span><br><span class="line">m_Camera.<span class="built_in">SetRotation</span>(m_CameraRotation);</span><br><span class="line"></span><br><span class="line">HEngine::Renderer::<span class="built_in">BeginScene</span>(m_Camera);</span><br><span class="line"></span><br><span class="line">HEngine::Renderer::<span class="built_in">Submit</span>(m_BlueShader, m_SquareVA);</span><br><span class="line">HEngine::Renderer::<span class="built_in">Submit</span>(m_Shader, m_VertexArray);</span><br><span class="line"></span><br><span class="line">HEngine::Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把Application-cpp里的内容移到Sandbox对应的Project">把Application.cpp里的内容移到Sandbox对应的Project</h4><p><code>Application</code>类应该主要负责进行While循环，在里面调用各个Layer的Update函数，而<code>SandboxApp</code>类虽然继承于<code>Application</code>类，但是也只是个大致的空壳而已，它的存在是为了把new出来的ExampleLayer加入到继承来的<code>m_LayerStack</code>里，具体的绘制Quad和Triangle的的操作应该放到Sandbox对应Project的Layer里，大概是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleLayer</span> : <span class="keyword">public</span> HEngine::Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">ExampleLayer</span>()</span><br><span class="line">: <span class="built_in">Layer</span>(<span class="string">&quot;Example&quot;</span>)</span><br><span class="line">: <span class="built_in">Layer</span>(<span class="string">&quot;Example&quot;</span>), <span class="built_in">m_Camera</span>(<span class="number">-1.6f</span>, <span class="number">1.6f</span>, <span class="number">-0.9f</span>, <span class="number">0.9f</span>), <span class="built_in">m_CameraPosition</span>(<span class="number">0.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_VertexArray.<span class="built_in">reset</span>(HEngine::VertexArray::<span class="built_in">Create</span>());</span><br><span class="line"><span class="type">float</span> vertices[<span class="number">3</span> * <span class="number">7</span>] = &#123;</span><br><span class="line"><span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>,</span><br><span class="line"> <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>,</span><br><span class="line"> <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;HEngine::VertexBuffer&gt; vertexBuffer;</span><br><span class="line">vertexBuffer.<span class="built_in">reset</span>(HEngine::VertexBuffer::<span class="built_in">Create</span>(vertices, <span class="built_in">sizeof</span>(vertices)));</span><br><span class="line">HEngine::BufferLayout layout = &#123;</span><br><span class="line">&#123; HEngine::ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;,</span><br><span class="line">&#123; HEngine::ShaderDataType::Float4, <span class="string">&quot;a_Color&quot;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">vertexBuffer-&gt;<span class="built_in">SetLayout</span>(layout);</span><br><span class="line">m_VertexArray-&gt;<span class="built_in">AddVertexBuffer</span>(vertexBuffer);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[<span class="number">3</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">std::shared_ptr&lt;HEngine::IndexBuffer&gt; indexBuffer;</span><br><span class="line">indexBuffer.<span class="built_in">reset</span>(HEngine::IndexBuffer::<span class="built_in">Create</span>(indices, <span class="built_in">sizeof</span>(indices) / <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line">m_VertexArray-&gt;<span class="built_in">SetIndexBuffer</span>(indexBuffer);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">m_SquareVA.<span class="built_in">reset</span>(HEngine::VertexArray::<span class="built_in">Create</span>());</span><br><span class="line"><span class="type">float</span> squareVertices[<span class="number">3</span> * <span class="number">4</span>] = &#123;</span><br><span class="line"><span class="number">-0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line"> <span class="number">0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line"> <span class="number">0.75f</span>,  <span class="number">0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line"><span class="number">-0.75f</span>,  <span class="number">0.75f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;HEngine::VertexBuffer&gt; squareVB;</span><br><span class="line">squareVB.<span class="built_in">reset</span>(HEngine::VertexBuffer::<span class="built_in">Create</span>(squareVertices, <span class="built_in">sizeof</span>(squareVertices)));</span><br><span class="line">squareVB-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">&#123; HEngine::ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line">m_SquareVA-&gt;<span class="built_in">AddVertexBuffer</span>(squareVB);</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> squareIndices[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span> &#125;;</span><br><span class="line">std::shared_ptr&lt;HEngine::IndexBuffer&gt; squareIB;</span><br><span class="line">squareIB.<span class="built_in">reset</span>(HEngine::IndexBuffer::<span class="built_in">Create</span>(squareIndices, <span class="built_in">sizeof</span>(squareIndices) / <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line">m_SquareVA-&gt;<span class="built_in">SetIndexBuffer</span>(squareIB);</span><br><span class="line"></span><br><span class="line">std::string vertexSrc = ...;</span><br><span class="line">std::string fragmentSrc = ...;</span><br><span class="line">m_Shader.<span class="built_in">reset</span>(<span class="keyword">new</span> HEngine::<span class="built_in">Shader</span>(vertexSrc, fragmentSrc));</span><br><span class="line"></span><br><span class="line">std::string blueShaderVertexSrc = ...;</span><br><span class="line">std::string blueShaderFragmentSrc = ...;</span><br><span class="line">m_BlueShader.<span class="built_in">reset</span>(<span class="keyword">new</span> HEngine::<span class="built_in">Shader</span>(blueShaderVertexSrc, blueShaderFragmentSrc));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二十五、矩阵位置、旋转、缩放">二十五、矩阵位置、旋转、缩放</h2><p>目前的Transform都是World坐标系的Transform，没有层级父子关系，本质就是globalPosition，globalRotation和globalScale，可以组成一个矩阵来表示。这里做的很简单，甚至都没有单独创建一个Transform类，就是用矩阵代表Model矩阵，作为uniform传给Shader而已，很简单，这里重点修改的函数是<code>Submit</code>函数，原本的函数如下：</p><p>Renderer.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Shader&gt;&amp; shader, <span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; va)</span></span></span><br></pre></td></tr></table></figure><p>现在要修改成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在渲染Vertex Array的时候, 添加对应model的transform对应的矩阵信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Shader&gt;&amp; shader, <span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray, <span class="type">const</span> glm::mat4&amp; transform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">shader-&gt;<span class="built_in">Bind</span>();           </span><br><span class="line">shader-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_ViewProjection&quot;</span>, s_SceneData-&gt;ViewProjectionMatrix);</span><br><span class="line">shader-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_Transform&quot;</span>, transform);</span><br><span class="line"></span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Sandbox.cpp中修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(HEngine::Timestep ts)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_LEFT))</span><br><span class="line">        m_CameraPosition.x -= m_CameraMoveSpeed * ts;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_RIGHT))</span><br><span class="line">        m_CameraPosition.x += m_CameraMoveSpeed * ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_UP))</span><br><span class="line">        m_CameraPosition.y += m_CameraMoveSpeed * ts;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_DOWN))</span><br><span class="line">        m_CameraPosition.y -= m_CameraMoveSpeed * ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_A))</span><br><span class="line">        m_CameraRotation += m_CameraRotationSpeed * ts;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_D))</span><br><span class="line">        m_CameraRotation -= m_CameraRotationSpeed * ts;</span><br><span class="line"></span><br><span class="line">    m_Camera.<span class="built_in">SetPosition</span>(m_CameraPosition);</span><br><span class="line">    m_Camera.<span class="built_in">SetRotation</span>(m_CameraRotation);</span><br><span class="line"></span><br><span class="line">    HEngine::Renderer::<span class="built_in">BeginScene</span>(m_Camera);</span><br><span class="line"></span><br><span class="line">    glm::mat4 scale = glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.1f</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">20</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">glm::vec3 <span class="title">pos</span><span class="params">(x * <span class="number">0.11f</span>, y * <span class="number">0.11f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">            glm::mat4 transform = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), pos) * scale;</span><br><span class="line">            HEngine::Renderer::<span class="built_in">Submit</span>(m_BlueShader, m_SquareVA, transform);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HEngine::Renderer::<span class="built_in">Submit</span>(m_Shader, m_VertexArray);</span><br><span class="line">    HEngine::Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::string vertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">   #version 450 core</span></span><br><span class="line"><span class="string">   layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string">   layout(location = 1) in vec4 a_Color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   uniform mat4 u_ViewProjection;</span></span><br><span class="line"><span class="string">   uniform mat4 u_Transform;//新增</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   out vec3 v_Position;</span></span><br><span class="line"><span class="string">   out vec4 v_Color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   void main()</span></span><br><span class="line"><span class="string">   &#123;</span></span><br><span class="line"><span class="string">     v_Position = a_Position;</span></span><br><span class="line"><span class="string">     v_Color = a_Color;</span></span><br><span class="line"><span class="string">     gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0); //乘上Transform</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"> )&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="效果-3">效果</h4><p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/8.webp" alt="8"></p><hr><h2 id="二十六、着色器封装">二十六、着色器封装</h2><ul><li><p>此节目的</p><p>完成Shader的抽象，因为目前只有Shader类，应该像顶点数组、顶点缓冲一样完善Shader的抽象</p><p>同之前抽象的结构一样：Shader是一个抽象类，有一个静态的Create方法，返回Shader指针，在这个函数中根据不同的预定义，实例化OpenGLShader还是DxShader。</p></li></ul><h4 id="关键代码-2">关键代码</h4><ul><li><p>动态指针强转</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(m_FlatShader)-&gt;<span class="built_in">UploadUniformFloat3</span>(<span class="string">&quot;u_Color&quot;</span>, m_SquareColor);</span><br></pre></td></tr></table></figure><p>因为要执行OpenGLShader（子类）<strong>独有的函数</strong>UploadUniformFloat3，而Shader（父类）里没有这个函数UploadUniformFloat3，所以需要<strong>动态指针强转</strong>，转为派生类的指针类型。</p></li><li><p>由于上传的是vec3，所以fragment的代码uniform接受的是vec3，而color是vec4类型，所以要补充最后A通道</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::string blueShaderfragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">in vec3 v_Position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uniform vec3 u_Color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()&#123;</span></span><br><span class="line"><span class="string">color = vec4(u_Color, 1.0f);// 补充最后A通道</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用imgui对应效果图的<strong>颜色选择器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImgGuiRender</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Settings&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;Square Color&quot;</span>,glm::<span class="built_in">value_ptr</span>(m_SquareColor));</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="具体代码">具体代码</h4><ul><li><p>Shader父类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Shader* <span class="title">Create</span><span class="params">(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Shader* <span class="title">Shader::Create</span><span class="params">(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> RendererAPI::API::None: <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI:None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">case</span> RendererAPI::API::OpenGL: <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenGLShader</span>(vertexSrc, fragmentSrc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;UnKnown RendererAPI!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>OpenGlShader子类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OpenGLShader</span> : <span class="keyword">public</span> Shader</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">OpenGLShader</span>(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc);</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">OpenGLShader</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UploadUniformInt</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UploadUniformFloat</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UploadUniformFloat2</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::vec2&amp; value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UploadUniformFloat3</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::vec3&amp; value)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UploadUniformFloat4</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::vec4&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UploadUniformMat3</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::mat3&amp; matrix)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">UploadUniformMat4</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::mat4&amp; matrix)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">uint32_t</span> m_RendererID;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line">OpenGLShader::<span class="built_in">OpenGLShader</span>(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc)</span><br><span class="line">&#123;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br><span class="line">OpenGLShader::~<span class="built_in">OpenGLShader</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glDeleteProgram</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLShader::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glUseProgram</span>(m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLShader::UnBind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLShader::UploadUniformInt</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GLint location = <span class="built_in">glGetUniformLocation</span>(m_RendererID, name.<span class="built_in">c_str</span>());</span><br><span class="line"><span class="built_in">glUniform1i</span>(location, value);</span><br><span class="line">&#125;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Sandbox.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::string flatColorShaderFragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    in vec3 v_Position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    uniform vec3 u_Color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        color = vec4(u_Color, 1.0);//换成输入的动态color</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Settings&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;Square Color&quot;</span>, glm::<span class="built_in">value_ptr</span>(m_SquareColor));</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二十七、宏定义智能指针">二十七、宏定义智能指针</h2><p>此节只是将shared_ptr与unique_ptr给与<strong>别名</strong></p><h4 id="代码修改-2">代码修改</h4><ul><li><p>Core.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Scope = std::unique_ptr&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Ref = std::shared_ptr&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将项目中的shared_ptr变为Ref名字</p></li></ul><h4 id="应该为哪种指针">应该为哪种指针</h4><ul><li><p>前置C++知识</p><table><thead><tr><th>指针类型</th><th>释放策略</th><th>离开作用域时指针是否被释放</th></tr></thead><tbody><tr><td><code>shared_ptr</code></td><td>引用计数</td><td>是，当引用计数为0时</td></tr><tr><td><code>unique_ptr</code></td><td>独占所有权，不允许共享所有权</td><td>是</td></tr></tbody></table></li><li><p>思考ExampleLayer中的Shader指针为什么应该为unique_ptr，而不是shared_ptr</p><ul><li><p>目前运行机制是</p><p>C++程序上传数据给shader去渲染，这一段过程需要时间</p><p>而电脑屏幕显示的是<strong>上一帧</strong>，显卡现在在渲染<strong>当前帧</strong>。</p></li><li><p>假设这个类指针指向OpenGLShader，且这个指针是unique_ptr</p><ol><li>在Renderer中需要用到OpenGLShader上传数据给显卡上的Shader程序，这需要时间。</li><li>但是若当前Renderer的容器ExampleLayer<strong>关闭</strong>了，指针离开作用域，那么这个OpenGLShader指针指向的内存也会被<strong>释放</strong></li><li>而Renderer中并不知道，还在使用这个指针指向的内存，就会报错。</li></ol></li></ul></li><li><p>ExampleLayer中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;HEngine::Shader&gt; m_Shader;<span class="comment">// shader类 指针</span></span><br><span class="line"></span><br><span class="line">HEngine::Renderer::<span class="built_in">Submit</span>(m_Shader, m_VertexArray);<span class="comment">// 在Onupdate函数中</span></span><br></pre></td></tr></table></figure></li><li><p>Renderer的Submit函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Shader&gt;&amp; shader, <span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray, glm::mat4 transform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vertexArray-&gt;<span class="built_in">Bind</span>(); </span><br><span class="line">    shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(shader)-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_ViewProjection&quot;</span>, m_SceneData-&gt;ViewProjectionMatrix);</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(shader)-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_Transform&quot;</span>, transform);</span><br><span class="line"></span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(vertexArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见：Renderer的Submit函数中需要<strong>保持m_Shader存在</strong>才可不会报错</p></li><li><p>解释：OpenGLShader指针指向的内存不会被释放</p><ol><li>函数形参是shared_ptr引用</li><li>由于Submit的形参是引用，接受实参时，并不会增加计数，当离开作用域时候，形参也不会减少计数，所以m_Shader的内存还存在</li></ol></li></ul><hr><h2 id="二十八、添加纹理">二十八、添加纹理</h2><ul><li><p>此节目的: 为了给图形表面赋予纹理Texture</p></li><li><p>如何实现</p><ul><li><p>顶点属性中需要有这个顶点的<strong>UV</strong></p></li><li><p><strong>stb_img</strong>加载图片数据</p></li><li><p>片段着色器根据当前片段的UV<strong>采样</strong>图片，从而得到当前片段的纹理信息</p><p>当图形所有的片段着色器运行完，效果就是图形表面被覆上一张图片</p></li></ul></li><li><p>具体说明纹理</p><ul><li><p>是属于材质Material的一部分</p></li><li><p>纹理需要被</p><p>采样</p><ol><li>一组顶点位置包围了一个区域</li><li>需要为这个区域上色，这些颜色可以从纹理里来</li><li>而如何获得纹理的颜色，则需要使用采样方式</li></ol></li><li><p>纹理不止可以包含颜色，还可以包含<strong>高度</strong>什么的，可以不用法线与光源计算就可以得到更逼真一点的模型。</p></li></ul></li></ul><h4 id="项目引入stb">项目引入stb</h4><ol><li><p>从<a href="https://github.com/nothings/stb/blob/master/stb_image.h">stb_imgage</a>项目拷贝stb_image.h和cpp到vendor文件夹下</p></li><li><p>stb_image.cpp文件定义宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure></li></ol><h4 id="代码-7">代码:</h4><p>创建Texture类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Texture</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">uint32_t</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">uint32_t</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">uint32_t</span> slot = <span class="number">0</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Texture2D</span> : <span class="keyword">public</span> Texture</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Ref&lt;Texture2D&gt; <span class="title">Create</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cpp内的定义</span></span><br><span class="line"><span class="function">Ref&lt;HEngine::Texture2D&gt; <span class="title">Texture2D::Create</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> RendererAPI::API::None:<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI::None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">case</span> RendererAPI::API::OpenGL:<span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;OpenGLTexture2D&gt;(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown RendererAPI!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建子类OpenGLTexture</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">OpenGLTexture2D::<span class="built_in">OpenGLTexture2D</span>(<span class="type">const</span> std::string&amp; path)</span><br><span class="line">:<span class="built_in">m_Path</span>(path)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> width, height, channels;</span><br><span class="line">        <span class="comment">// 设置垂直翻转，由于OpenGL是从上往下渲染的，所以要把图片翻转过来</span></span><br><span class="line"><span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="number">1</span>);</span><br><span class="line">stbi_uc* data = <span class="built_in">stbi_load</span>(path.<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;channels, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(data, <span class="string">&quot;Failed to load image!&quot;</span>);</span><br><span class="line">m_Width = width;</span><br><span class="line">m_Height = height;</span><br><span class="line">            </span><br><span class="line"><span class="built_in">glCreateTextures</span>(GL_TEXTURE_2D, <span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line"><span class="built_in">glTextureStorage2D</span>(m_RendererID, <span class="number">1</span>, GL_RGB8, m_Width, m_Height);</span><br><span class="line"><span class="built_in">glTextureParameteri</span>(m_RendererID, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">        <span class="comment">//纹理放大时用周围颜色的平均值过滤，不然尺寸小的纹理被放到大矩阵上会很糊//</span></span><br><span class="line"><span class="built_in">glTextureParameteri</span>(m_RendererID, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line"><span class="built_in">glTextureSubImage2D</span>(m_RendererID, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m_Width, m_Height, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line"></span><br><span class="line"><span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">OpenGLTexture2D::~<span class="built_in">OpenGLTexture2D</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">glDeleteTextures</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLTexture2D::Bind</span><span class="params">(<span class="type">uint32_t</span> slot)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">glBindTextureUnit</span>(slot, m_RendererID);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sandbox.cpp添加图片纹理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> squareVertices[<span class="number">5</span> * <span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span><span class="comment">//添加了纹理坐标</span></span><br><span class="line">&#125;;</span><br><span class="line">squareVB-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">    &#123; HEngine::ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;,</span><br><span class="line">    &#123; HEngine::ShaderDataType::Float2 ,<span class="string">&quot;a_TexCoord&quot;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line">std::string textureShaderVertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string">    layout(location = 1) in vec2 a_TexCoord;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    uniform mat4 u_ViewProjection;</span></span><br><span class="line"><span class="string">    uniform mat4 u_Transform;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    out vec2 v_TexCoord;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        v_TexCoord = a_TexCoord;</span></span><br><span class="line"><span class="string">        gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">std::string textureShaderFragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    in vec2 v_TexCoord;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    uniform sampler2D u_Texture;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        color = texture(u_Texture, v_TexCoord);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"> m_TextureShader.<span class="built_in">reset</span>(HEngine::Shader::<span class="built_in">Create</span>(textureShaderVertexSrc, textureShaderFragmentSrc));</span><br><span class="line"></span><br><span class="line"> m_Texture = HEngine::Texture2D::<span class="built_in">Create</span>(<span class="string">&quot;assets/textures/Checkerboard.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"> std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(m_TextureShader)-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"> std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(m_TextureShader)-&gt;<span class="built_in">UploadUniformInt</span>(<span class="string">&quot;u_Texture&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h4 id="效果-4">效果:</h4><p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/9.webp" alt="9"></p><hr><h2 id="二十九、添加混合效果">二十九、添加混合效果</h2><ul><li><p>此节目的:</p><p>添加混合效果,使用OpenGL自带的函数即可</p></li><li><p>什么是混合</p><p>两张图片有一部分叠加在一起，需要得出这重叠的部分最终的颜色。</p></li><li><p>如何混合</p><p>根据两张图片的alpha通道，由公式推出来最终颜色。</p></li></ul><h4 id="代码-8">代码</h4><p>OpenGLRendererAPI.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line">    <span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的图片通道不一样，要先判断读取的图片几个通道的图片，不然会读取颜色出错,需要修改代码</p><p>OpenGLTexture.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GLenum internalFormat = <span class="number">0</span>, dataFormat = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (channels == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    internalFormat = GL_RGBA8;</span><br><span class="line">    dataFormat = GL_RGBA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    internalFormat = GL_RGB8;</span><br><span class="line">    dataFormat = GL_RGB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glTextureStorage2D</span>(m_RendererID, <span class="number">1</span>, internalFormat, m_Width, m_Height);</span><br><span class="line"><span class="built_in">glTextureSubImage2D</span>(m_RendererID, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m_Width, m_Height, dataFormat, </span><br></pre></td></tr></table></figure><hr><h2 id="三十、-优化着色器文件">三十、 优化着色器文件</h2><p>目前的Shader是在代码里写死的，这样写的代码会作为static常量存在内存里。但是游戏引擎里有一个常见的需求，就是<strong>对Shader的热更</strong>，比如说我更改一个Shader，我想立马在游戏里看到更改之后的Shader的效果。如果把Shader写在单独的文件里，就可以重新单独Reload和编译这个新文件。还有个问题，游戏引擎，比如Unity，里面支持在编辑器里写Shader，目前的这种写法不满足这种用户需求。</p><p>之前学习OpenGL时，一个ShaderProgram是有多个文件的，分别存放vert shader、fragment shader等，而DX是都放在一个文件里的。感觉都放一个文件里更科学一点，所以这边创建文件是下面这样的格式：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#type vertex<span class="comment">// 注意：这是自己定义的字符串里分隔Shader的方法，不是官方写法</span></span><br><span class="line"><span class="params">...</span><span class="comment">//写原本的vertex shader</span></span><br><span class="line"></span><br><span class="line">#type fragment</span><br><span class="line"><span class="params">...</span><span class="comment">//写原本的fragment shader</span></span><br></pre></td></tr></table></figure><p>然后利用<code>ifstream</code>来读取文件，得到string，再寻找上面的<code>#type ...</code>这种东西，把一个大的string，分为多个string，每个细分后的string对应一种shader。</p><h4 id="代码-9">代码</h4><p>OpenGLShader.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="type">static</span> GLenum <span class="title">ShaderTypeFromString</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&quot;vertex&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> GL_VERTEX_SHADER;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="string">&quot;fragment&quot;</span> || type == <span class="string">&quot;pixel&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> GL_FRAGMENT_SHADER;</span><br><span class="line"></span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown shader type!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">OpenGLShader::<span class="built_in">OpenGLShader</span>(<span class="type">const</span> std::string&amp; filepath)</span><br><span class="line">&#123;</span><br><span class="line">std::string source = <span class="built_in">ReadFile</span>(filepath);</span><br><span class="line"><span class="keyword">auto</span> shaderSources = <span class="built_in">PreProcess</span>(source);</span><br><span class="line"><span class="built_in">Complie</span>(shaderSources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">OpenGLShader::ReadFile</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::string result;</span><br><span class="line"><span class="function">std::ifstream <span class="title">in</span><span class="params">(filepath, std::ios::in, std::ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (in)</span><br><span class="line">&#123;</span><br><span class="line">in.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::end);</span><br><span class="line">result.<span class="built_in">resize</span>(in.<span class="built_in">tellg</span>());</span><br><span class="line">in.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg);</span><br><span class="line">in.<span class="built_in">read</span>(&amp;result[<span class="number">0</span>], result.<span class="built_in">size</span>());</span><br><span class="line">in.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">HE_CORE_ERROR</span>(<span class="string">&quot;Could not open file &#x27;&#123;0&#125;&#x27;&quot;</span>, filepath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unordered_map&lt;GLenum, std::string&gt; <span class="title">OpenGLShader::PreProcess</span><span class="params">(<span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::unordered_map&lt;GLenum, std::string&gt;shaderSources;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* typeToken = <span class="string">&quot;#type&quot;</span>;</span><br><span class="line"><span class="type">size_t</span> typeTokenLength = <span class="built_in">strlen</span>(typeToken);</span><br><span class="line"><span class="type">size_t</span> pos = source.<span class="built_in">find</span>(typeToken, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (pos != std::string::npos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> eol = source.<span class="built_in">find_first_of</span>(<span class="string">&quot;\r\n&quot;</span>, pos);</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(eol != std::string::npos, <span class="string">&quot;Syntax error&quot;</span>);</span><br><span class="line"><span class="type">size_t</span> begin = pos + typeTokenLength + <span class="number">1</span>;</span><br><span class="line">std::string type = source.<span class="built_in">substr</span>(begin, eol - begin);</span><br><span class="line"><span class="built_in">HE_CORE_ASSERT</span>(<span class="built_in">ShaderTypeFromString</span>(type), <span class="string">&quot;Invalid shader type specified&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> nextLinePos = source.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;\r\n&quot;</span>, eol);</span><br><span class="line">pos = source.<span class="built_in">find</span>(typeToken, nextLinePos);</span><br><span class="line">shaderSources[<span class="built_in">ShaderTypeFromString</span>(type)] = source.<span class="built_in">substr</span>(nextLinePos, pos - (nextLinePos == std::string::npos ? source.<span class="built_in">size</span>() - <span class="number">1</span> : nextLinePos));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> shaderSources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Shandr.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shader* <span class="title">Shader::Create</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> RendererAPI::API::None:    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI::None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">case</span> RendererAPI::API::OpenGL:  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenGLShader</span>(filepath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown RendererAPI!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把之前SandboxApp中shader的字符串移到一个文件里面,后缀为glsl</p><p>然后SandboxApp就只用这一句就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_TextureShader.<span class="built_in">reset</span>(HEngine::Shader::<span class="built_in">Create</span>(<span class="string">&quot;assets/shaders/Texture.glsl&quot;</span>));</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录HEngine每一次提交的重点内容以及遇到的问题和解决的步骤</summary>
    
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客搭建教程</title>
    <link href="https://donghuiw.github.io/posts/39541a22"/>
    <id>https://donghuiw.github.io/posts/39541a22</id>
    <published>2025-02-27T08:14:57.000Z</published>
    <updated>2025-03-13T14:06:06.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言">1.前言</h2><ol><li>博客搭建过程遇到任何问题，优先在本页面搜索，检查是否已经有该配置教程。</li><li>遇到问题可以优先在文章评论区留言，注意留言时请填写正确的邮箱以确保能收到站长的回复。</li><li>实在解决不了的问题可添加站长的微信进行交流，备注自己的个人信息。</li></ol><h2 id="2-环境与工具准备">2.环境与工具准备</h2><p><strong>本教程主要面对的是Windows用户</strong></p><ul><li>操作系统：Windows10</li><li>Node</li><li>Git</li><li>Hexo</li><li>文本编辑器(推荐VSCODE)</li><li>GitHub 帐号</li><li>一个域名</li><li>云服务器（可选）</li></ul><h2 id="3-Node的安装">3.Node的安装</h2><ol><li><p>打开Node官网，下载和自己系统相配的Node的安装程序，否则会出现安装问题。下载地址：<a href="https://nodejs.cn/download/%EF%BC%8C%E9%80%89%E6%8B%A9Windows%E5%AE%89%E8%A3%85%E5%8C%85(.msi),%E6%88%91%E4%B8%AA%E4%BA%BA%E7%9A%84%E7%89%88%E6%9C%AC%E6%98%AF">https://nodejs.cn/download/，选择Windows安装包(.msi),我个人的版本是</a> 22.14.0，建议和我的一样，否则后面会出现各种不兼容的问题！</p></li><li><p>下载后安装，安装的目录可以使用默认目录【C:/Program Files/nodejs/】，也可以自定义路径。<br>这个环境路径切换坑也很多，如果大家C盘空间足够可以直接装C盘，如果想切换其他盘或者把环境遍历切换到自定义路径也可以，具体教程百度(不过坑比较多就是了)!</p></li><li><p>安装完成后，检查是否安装成功。在键盘按下win + R键，输入CMD，然后回车，打开CMD窗口，执行node -v命令，看到版本信息，则说明安装成功。</p></li><li><p>修改npm源。npm下载各种模块，默认是从国处服务器下载，速度较慢，没有翻墙工具的建议配置成淘宝镜像。打开CMD窗口，运行如下命令:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https:<span class="comment">//registry.npm.taobao.org</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="4-Github注册与创建仓库">4.Github注册与创建仓库</h2><ol><li>进入官网 <a href="https://github.com/">https://github.com/</a></li><li>点击右上角的 Sign up(注册)</li><li>填写自己的邮箱、密码、用户名等信息，然后用邮箱验证即可完成。</li><li>注册完成后，点击右上角的<code>+</code>按钮，选择<code>New repository</code>，创建一个<code>&lt;用户名&gt;.github.io</code>的仓库。</li></ol><ul><li>仓库的格式必须为：<code>&lt;用户名&gt;.github.io</code> (注意：前缀必须为用户名，不要等后面404了再来为什么！！！)</li><li>Description：为描述仓库（选填）</li><li>勾选 Initialize this repository with a README 初始化一个 <a href="http://README.md">README.md</a> 文件</li><li>点击 Creat repository 进行创建</li></ul><h2 id="5-Git安装">5.Git安装</h2><ol><li>进入官网：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> ，由于官网下载太慢可以通过淘宝的开源镜像下载 网址：<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/v2.36.1.windows.1/">https://registry.npmmirror.com/binary.html?path=git-for-windows/v2.36.1.windows.1/</a> ，下载版本更具自己的需求选择即可。</li><li>下载后傻瓜式安装Git即可，安装的目录可以使用默认目录【C:/Program Files/Git】，也可以自定义路径。</li><li>点击电脑左下角开始即可看见<code>Git Bash</code>。</li></ol><ul><li><code>Git CMD</code> 是windows 命令行的指令风格</li><li><code>Git Bash</code> 是linux系统的指令风格（建议使用）</li><li><code>Git GUI</code>是图形化界面（新手学习不建议使用）</li></ul><ol><li><p>常用命令</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config -l  <span class="string">//</span>查看所有配置</span><br><span class="line">git config <span class="params">--system</span> <span class="params">--list</span> <span class="string">//</span>查看系统配置</span><br><span class="line">git config <span class="params">--global</span> <span class="params">--list</span> <span class="string">//</span>查看用户（全局）配置</span><br></pre></td></tr></table></figure></li><li><p>配置用户名和邮箱</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config <span class="attr">--global</span> user<span class="selector-class">.name</span> <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">git config <span class="attr">--global</span> user<span class="selector-class">.email</span> <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>通过<code>git config -l</code> 检查是否配置成功，至此git安装及配置全部完成。</p></li></ol><h2 id="6-连接至Github">6.连接至Github</h2><ol><li><p>执行以下命令生成ssh公钥，此公钥用于你的计算机连接Github</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>之后打开C盘下用户文件夹下的.ssh的文件夹，会看到 id_rsa.pub</p><p>用记事本打开上述图片中的公钥（id_rsa.pub），复制里面的内容，然后开始在github中配置ssh密钥。</p></li><li><p>将 SSH KEY 配置到 GitHub<br>进入github，点击右上角头像 选择<code>settings</code>，进入设置页后选择 <code>SSH and GPG keys</code>，名字随便起，公钥填到<code>Key</code>那一栏。</p></li><li><p>测试连接，输入以下命令</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh</span> -T git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure><p>出现连接到账户的信息，说明已经大功告成，至此完成了环境准备工作。</p></li></ol><h2 id="7-安装Hexo">7.安装Hexo</h2><ol><li><p>桌面右键，选择Open git Bash here, 在<code>Git BASH</code>输入如下命令安装</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure></li><li><p>安装完后输入hexo -v 验证是否安装成功。看到打印出一排排版本号就成功了</p></li></ol><h2 id="8-初始化-Hexo-项目">8.初始化 Hexo 项目</h2><ol><li><p>在目标路径（我这里选的路径为【C:/Hexo-Blog】）打开cmd命令窗口，执行<code>hexo init</code>初始化项目。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">init</span> (项目名)</span><br></pre></td></tr></table></figure></li><li><p>进入<code>blog</code> ，输入<code>npm i</code>安装相关依赖。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="params">(项目名)</span>  <span class="string">//</span>进入blog文件夹</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>初始化项目后，<code>blog-demo</code>有如下结构：</p></li></ol><p>【node_modules】：依赖包<br>【scaffolds】：生成文章的一些模板<br>【source】：用来存放你的文章<br>【themes】：主题<br>【.npmignore】：发布时忽略的文件（可忽略）<br>【_config.landscape.yml】：主题的配置文件<br>【config.yml】：博客的配置文件<br>【package.json】：项目名称、描述、版本、运行和开发等信息</p><ol><li>输入hexo server或者hexo s 启动项目</li><li>打开浏览器，输入地址：<a href="http://localhost:4000/">http://localhost:4000/</a> ，看到网页就说明成功了。</li></ol><h2 id="9-将静态博客挂载到-GitHub-Pages">9. 将静态博客挂载到 GitHub Pages</h2><ol><li><p>安装 hexo-deployer-git</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure></li><li><p>修改 _config.yml 文件<br>在blog-demo目录下的_config.yml，就是整个Hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的<a href="https://hexo.io/zh-cn/docs/configuration">配置描述</a>。<br>修改最后一行的配置，将repository修改为你自己的github项目地址即可，还有分支要改为<code>main</code>代表主分支（注意缩进）。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repository:</span> https:<span class="comment">//github.com/donghuiw/donghuiw.github.io.git</span></span><br><span class="line"><span class="symbol">  branch:</span> main</span><br></pre></td></tr></table></figure></li><li><p>修改好配置后，运行如下命令，将代码部署到 GitHub（Hexo三连）。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo <span class="keyword">generate</span> &amp;&amp; hexo deploy  <span class="comment">// Git BASH终端</span></span><br><span class="line">（缩写）hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">hexo clean; hexo <span class="keyword">generate</span>; hexo deploy  <span class="comment">// VSCODE终端</span></span><br></pre></td></tr></table></figure><ul><li><p>hexo clean：删除之前生成的文件，若未生成过静态文件，可忽略此命令。</p></li><li><p>hexo generate：生成静态文章，可以用<code>hexo g</code>缩写</p></li><li><p>hexo deploy：部署文章，可以用<code>hexo d</code>缩写</p><p>注意：deploy时可能要你输入 username 和 password。</p><p>如果出现<code>Deploy done</code>，则说明部署成功了。</p><p>稍等两分钟，打开浏览器访问：<a href="https://github.com/git%E8%B4%A6%E5%8F%B7%E5%90%8D/git%E8%B4%A6%E5%8F%B7%E5%90%8D.github.io">https://github.com/git账号名/git账号名.github.io</a> ，这时候我们就可以看到博客内容了。</p></li></ul></li></ol><h2 id="10-无法连接至Github的解决方案">10. 无法连接至Github的解决方案</h2><p>注意：当你在与Github进行ssh通信时候出现超时或者是连接被关闭的情况，可以尝试以下解决方案。</p><ol><li><p>挂代理和换网络（这个就不用多说了）</p></li><li><p><a href="https://blog.csdn.net/weixin_41287260/article/details/124368189">Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”</a></p><p>这是评论区的朋友提供的，可以解决SSH连接超时等问题</p></li><li><p>开源项目<a href="https://github.com/521xueweihan/GitHub520">Github520</a></p><p>通过修改Host文件的方法解决访问速度慢的问题</p></li></ol><p>连接有效性检验：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 任选其一即可</span></span><br><span class="line"><span class="built_in">ping</span> github.com</span><br><span class="line">ssh -T git<span class="symbol">@github</span>.com</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-前言&quot;&gt;1.前言&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;博客搭建过程遇到任何问题，优先在本页面搜索，检查是否已经有该配置教程。&lt;/li&gt;
&lt;li&gt;遇到问题可以优先在文章评论区留言，注意留言时请填写正确的邮箱以确保能收到站长的回复。&lt;/li&gt;
&lt;li&gt;实在解决不了的问题可</summary>
      
    
    
    
    <category term="演示" scheme="https://donghuiw.github.io/categories/%E6%BC%94%E7%A4%BA/"/>
    
    
    <category term="演示" scheme="https://donghuiw.github.io/tags/%E6%BC%94%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>Premake5使用及问题汇总</title>
    <link href="https://donghuiw.github.io/posts/a1665e0e"/>
    <id>https://donghuiw.github.io/posts/a1665e0e</id>
    <published>2024-10-03T08:40:04.000Z</published>
    <updated>2025-03-13T14:07:23.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Premake学习">Premake学习</h2><p>最近跟着YouTube大神<a href="https://www.youtube.com/TheChernoProject">TheCherno</a>学习制作游戏引擎，其中用到了Premake5，Premake是一个命令行工具，它读取软件项目的脚本定义，然后使用它来执行构建配置任务或为Visual Studio, Xcode和GNU Make等工具集生成项目文件。</p><p>先介绍一下Premake5, 官方给了个简单的模板：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- premake5.lua</span></span><br><span class="line">workspace <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">   configurations &#123; <span class="string">&quot;Debug&quot;</span>, <span class="string">&quot;Release&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">project <span class="string">&quot;HelloWorld&quot;</span></span><br><span class="line">   kind <span class="string">&quot;ConsoleApp&quot;</span></span><br><span class="line">   language <span class="string">&quot;C&quot;</span></span><br><span class="line">   targetdir <span class="string">&quot;bin/%&#123;cfg.buildcfg&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">   files &#123; <span class="string">&quot;**.h&quot;</span>, <span class="string">&quot;**.c&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">--这里面写附加库的头文件目录，对应的VS项目属性里的Additional Include Directories</span></span><br><span class="line">   include &#123;&#125;</span><br><span class="line">   <span class="comment">--filter后面一般加特定平台的Configurations，其范围会一直持续到碰到下一个filter或project</span></span><br><span class="line">   filter <span class="string">&quot;configurations:Debug&quot;</span></span><br><span class="line">      defines &#123; <span class="string">&quot;DEBUG&quot;</span> &#125;</span><br><span class="line">      symbols <span class="string">&quot;On&quot;</span></span><br><span class="line">   <span class="comment">--到这，碰到fitler，上面的filter对应Debug平台下的filter范围结束</span></span><br><span class="line">   filter <span class="string">&quot;configurations:Release&quot;</span></span><br><span class="line">      defines &#123; <span class="string">&quot;NDEBUG&quot;</span> &#125;</span><br><span class="line">      optimize <span class="string">&quot;On&quot;</span></span><br></pre></td></tr></table></figure><p>这里的filter一般限定了范围，比如说特定的Windows平台，如下所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--比如说windows平台下的filter</span></span><br><span class="line"><span class="keyword">filter</span> &quot;system:windows&quot;</span><br><span class="line">   cppdialect &quot;C++17&quot;</span><br><span class="line">   staticruntime &quot;On&quot;   <span class="comment">--表示会Link对应的dll</span></span><br><span class="line">   systemversion &quot;latest&quot; <span class="comment">--使用最新的windows sdk版本，否则会默认选择8.1的版本</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">filter</span> &quot;configurations:Release&quot;</span><br><span class="line">   defines &#123; &quot;NDEBUG&quot; &#125;</span><br><span class="line">   optimize &quot;On&quot;</span><br></pre></td></tr></table></figure><p>如上所示，filter相当于筛选器，上述写法，如果是安卓平台的Release模式，则下面的filter还是会执行，如果想限定两个，比如只生在windows的Release情况下的filter，则应该这么写</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">filter</span> &#123;&quot;system:windows&quot;, &quot;configurations:Release&quot;&#125;</span><br><span class="line">   cppdialect &quot;C++17&quot;</span><br><span class="line">   staticruntime &quot;On&quot;   <span class="comment">--表示会Link对应的dll</span></span><br><span class="line">   systemversion &quot;latest&quot; <span class="comment">--使用最新的windows sdk版本，否则会默认选择8.1的版本</span></span><br><span class="line">   defines &#123; &quot;NDEBUG&quot; &#125;</span><br><span class="line">   optimize &quot;On&quot;</span><br></pre></td></tr></table></figure><p>如果想取消对应filter的限定，则在后面加上这一行即可：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Reset the filter for other settings</span></span><br><span class="line"><span class="keyword">filter</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>学到了一个单词，叫做token，我原本以为叫做Macro，token表示一些代表符号，比如VS里的$(SolutionDir)，而Premake的宏大概是这么写：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%&#123;wks.name&#125;</span></span><br><span class="line"><span class="tag">%&#123;prj.location&#125;</span></span><br><span class="line"><span class="tag">%&#123;cfg.targetdir&#125;</span></span><br></pre></td></tr></table></figure><p>在Github上Premake的Wiki界面搜索Token可以找到对应的一些符号，如下所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">wks.name</span><br><span class="line">wks.<span class="keyword">location</span> <span class="comment">-- (location where the workspace/solution is written, not the premake-wks.lua file)</span></span><br><span class="line"></span><br><span class="line">prj.name</span><br><span class="line">prj.<span class="keyword">location</span> <span class="comment">-- (location where the project is written, not the premake-prj.lua file)</span></span><br><span class="line">prj.<span class="keyword">language</span></span><br><span class="line">prj.<span class="keyword">group</span></span><br><span class="line"></span><br><span class="line">cfg.longname</span><br><span class="line">cfg.shortname</span><br><span class="line">cfg.kind</span><br><span class="line">cfg.architecture</span><br><span class="line">cfg.platform</span><br><span class="line">cfg.<span class="keyword">system</span></span><br><span class="line">cfg.buildcfg</span><br><span class="line">cfg.buildtarget <span class="comment">-- (see [target], below)</span></span><br><span class="line">cfg.linktarget <span class="comment">-- (see [target], below)</span></span><br><span class="line">cfg.objdir</span><br><span class="line"></span><br><span class="line">file.path</span><br><span class="line">file.abspath</span><br><span class="line">file.relpath</span><br><span class="line">file.directory</span><br><span class="line">file.reldirectory</span><br><span class="line">file.name</span><br><span class="line">file.basename <span class="comment">-- (file part without extension)</span></span><br><span class="line">file.<span class="keyword">extension</span> <span class="comment">-- (including &#x27;.&#x27;; eg &quot;.cpp&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- These values are available on build and link targets</span></span><br><span class="line"><span class="comment">-- Replace [target] with one of &quot;cfg.buildtarget&quot; or &quot;cfg.linktarget&quot;</span></span><br><span class="line"><span class="comment">--   Eg: %&#123;cfg.buildtarget.abspath&#125;</span></span><br><span class="line">[target].abspath</span><br><span class="line">[target].relpath</span><br><span class="line">[target].directory</span><br><span class="line">[target].name</span><br><span class="line">[target].basename <span class="comment">-- (file part without extension)</span></span><br><span class="line">[target].<span class="keyword">extension</span> <span class="comment">-- (including &#x27;.&#x27;; eg &quot;.cpp&quot;)</span></span><br><span class="line">[target].bundlename</span><br><span class="line">[target].bundlepath</span><br><span class="line">[target].prefix</span><br><span class="line">[target].suffix</span><br></pre></td></tr></table></figure><p>还可以使用postbuildcommand来实现build完成之后的文件拷贝和复制工作，如下所示：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">postbuildcommand</span><br><span class="line">&#123;</span><br><span class="line">    -- <span class="string">%&#123;cfg.buildtarget.relpath&#125;</span>是生成文件，相较于当前premake5.lua文件的相对路径</span><br><span class="line">    &#123;<span class="string">&quot;COPY&quot;</span> <span class="string">%&#123;cfg.buildtarget.relpath&#125;</span> ../.. output../<span class="title class_">Sandbox</span><span class="string">&quot;&#125;-- ..是一种语法，output相当于之前声明的一个string变量</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>更多内容可前往官网查看https://premake.github.io/docs/，接下来开始我的配置</p><h3 id="解决方案的配置">解决方案的配置</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">workspace <span class="string">&quot;HEngine&quot;</span>//解决方案名</span><br><span class="line">architecture <span class="string">&quot;64&quot;</span>//设置解决方案平台为x64还是x32</span><br><span class="line"></span><br><span class="line">startproject <span class="string">&quot;Sandbox&quot;</span>//设置开始项目</span><br><span class="line"></span><br><span class="line">configurations//解决方案配置，默认配置是Debug，与顺序无关</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;Debug&quot;</span>,</span><br><span class="line"><span class="string">&quot;Release&quot;</span>,</span><br><span class="line"><span class="string">&quot;Dist&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">outputdir = <span class="string">&quot;%&#123;cfg.buildcfg&#125;-%&#123;cfg.system&#125;-%&#123;cfg.architecture&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">//cfg.buildcfg:解决方案配置名(Debug,Release等)</span><br><span class="line">//cfg.system:平台系统名(window,linux等)</span><br><span class="line">//cfg.architecture:解决方案平台名(x86,x86_x64)对应architecture <span class="string">&quot;x32&quot;</span>/<span class="string">&quot;x64&quot;</span></span><br><span class="line">//outputdir相当于全局变量，会在后面用到</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="项目的配置">项目的配置</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">project <span class="string">&quot;HEngine&quot;</span>//项目名</span><br><span class="line">location <span class="string">&quot;HEngine&quot;</span>//项目配置文件的生成路径</span><br><span class="line">kind <span class="string">&quot;SharedLib&quot;</span> //SharedLib生成(.dll) 改为 ConsoleApp则生成.exe</span><br><span class="line">language <span class="string">&quot;C++&quot;</span> //语言为c++</span><br><span class="line"></span><br><span class="line">targetdir (<span class="string">&quot;bin/&quot;</span> .. outputdir ..<span class="string">&quot;/%&#123;prj.name&#125;&quot;</span>) </span><br><span class="line">//prj.name为此项目名</span><br><span class="line">//最后等于<span class="string">&quot;bin\Debug-windows-x86\HEngine&quot;</span></span><br><span class="line"></span><br><span class="line">objdir (<span class="string">&quot;bin-int/&quot;</span> .. outputdir ..<span class="string">&quot;/%&#123;prj.name&#125;&quot;</span>)</span><br><span class="line">//指定中间目录，最后等于bin-int\Debug-windows-x86\HEngine</span><br><span class="line">//两边的..是lua语言字符串拼接的写法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Premake的本质就是生成Visual Studio等工具的项目文件，所以上面写的所有代码最后都会配置到项目中，运行完脚本后在VS右键项目打开Properties中查看设置的输出目录、中间目录、其他包含目录的路径是否正确</p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2024-10-03/1.webp" /><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">files//指定编译的文件类型</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;%&#123;prj.name&#125;/src/**.h&quot;</span>,</span><br><span class="line"><span class="string">&quot;%&#123;prj.name&#125;/src/**.cpp&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">includedirs//附加包含目录，自定义头文件的位置</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;%&#123;prj.name&#125;/vendor/spdlog/include&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter <span class="string">&quot;system:windows&quot;</span>//针对windows系统，进行如下配置</span><br><span class="line">cppdialect <span class="string">&quot;c++17&quot;</span>//c++语言标准</span><br><span class="line">staticruntime <span class="string">&quot;On&quot;</span>//</span><br><span class="line">systemversion <span class="string">&quot;10.0.26100.0&quot;</span>//根据你下的windows SDK版本设置</span><br><span class="line"></span><br><span class="line">defines//预处理器定义,也就是预定义宏</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;HE_PLATFORM_WINDOWS&quot;</span>,</span><br><span class="line"><span class="string">&quot;HENGINE_BUILD_DLL&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">postbuildcommands//对编译链接得到的二进制文件进行操作</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;&#123;COPYDIR&#125; %&#123;cfg.buildtarget.relpath&#125; \&quot;../bin/&quot;</span> .. outputdir ..  <span class="string">&quot;/SandBox/\&quot;&quot;</span> </span><br><span class="line"><span class="comment">--xcopy /Q /E /Y /I ..\bin\Debug-windows-x86_64\HEngine\HEngine.dll ..\bin\Debug-windows-x86_64\SandBox\</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter <span class="string">&quot;configurations:Debug&quot;</span></span><br><span class="line">defines <span class="string">&quot;HE_DEBUG&quot;</span></span><br><span class="line">symbols <span class="string">&quot;On&quot;</span>//将项目管理器属性中 运行库改为多线程(MT)</span><br><span class="line"></span><br><span class="line">filter <span class="string">&quot;configurations:Release&quot;</span></span><br><span class="line">defines <span class="string">&quot;HE_RELEASE&quot;</span></span><br><span class="line">optimize <span class="string">&quot;On&quot;</span>//开启优化</span><br><span class="line"></span><br><span class="line">filter <span class="string">&quot;configurations:Dist&quot;</span></span><br><span class="line">defines <span class="string">&quot;HE_DIST&quot;</span></span><br><span class="line">optimize <span class="string">&quot;On&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//来自Sandbox项目</span><br><span class="line">links</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;HEngine&quot;</span> //链接HEngine项目给Sandbox项目</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="遇到的问题">遇到的问题</h3><p>在Premake使用{COPY}命令时程序会卡死不动，或者显示找不到文件的报错</p><p>Cherno用的premake5是更老的版本，在那个版本{COPY}已经被弃用了,所以跟着写不行，官方推荐使用{COPYFILE}或者{COPYDIR}命令，但是官网的doc对介绍太粗略，只给了一个简单的例子</p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2024-10-03/2.webp" /><p>下面说一下解决思路，首先要知道我们在脚本写的{COPY}是会转换成实际Windows批处理命令的，在VS的properties(属性)&gt;生成事件(Build Events)&gt;生成后事件（post-Build Event）中可以找到脚本使用的实际命令是什么，根据这个来看问题出现在哪</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//报错代码的对应命令</span><br><span class="line">(<span class="string">&quot;&#123;COPY&#125; %&#123;cfg.buildtarget.relpath&#125; ../bin/&quot;</span> .. outputdir .. <span class="string">&quot;/Sandbox&quot;</span>)</span><br><span class="line"></span><br><span class="line">//IF EXIST ..\bin\Debug-windows-x86_64\HEngine\HEngine.dll\ (xcopy /Q /E /Y /I ..\bin\Debug-windows-x86_64\HEngine\HEngine.dll <span class="string">&quot;..\bin\Debug-windows-x86_64\Sandbox\&quot; &gt; nul) ELSE (xcopy /Q /Y /I ..\bin\Debug-windows-x86_64\HEngine\HEngine.dll &quot;</span>..\bin\Debug-windows-x86_64\Sandbox\<span class="string">&quot; &gt; nul)</span></span><br><span class="line"><span class="string">xcopy参数:   /Q：静默复制，不显示文件名。</span></span><br><span class="line"><span class="string">/E：复制所有子目录，包括空目录。</span></span><br><span class="line"><span class="string">/Y：自动覆盖目标位置的同名文件，无需确认。</span></span><br><span class="line"><span class="string">/I：如果目标不存在，假定为目录。</span></span><br><span class="line"><span class="string">&gt;nul 表示不需要打印输出</span></span><br><span class="line"><span class="string">根据分析后我们发现问题出在目标路径写的不对，应该是..\bin\Debug-windows-x86_64\Sandbox\，少了尾部的路径符号，找到问题后修改脚本即可</span></span><br><span class="line"><span class="string">(&quot;</span>&#123;COPY&#125; %&#123;cfg.buildtarget.relpath&#125; \<span class="string">&quot;../bin/&quot;</span> .. outputdir .. <span class="string">&quot;/Sandbox/\&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p>接下来我们使用官网推荐替换版本{COPYFILE}或者{COPYDIR}，但使用{COPYFILE}的话对应的批处理命令是copy不是xcopy,copy无法在目标目录为空时自动创建文件夹,所以我们使用{COPYDIR},这样问题就解决啦</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&#123;COPYDIR&#125; %&#123;cfg.buildtarget.relpath&#125; \&quot;../bin/&quot;</span> .. outputdir ..  <span class="string">&quot;/SandBox/\&quot;&quot;</span> </span><br><span class="line">//xcopy /Q /E /Y /I ..\bin\Debug-windows-x86_64\HEngine\HEngine.dll ..\bin\Debug-windows-x86_64\SandBox\</span><br></pre></td></tr></table></figure><hr><p>上面演示的是项目初期的配置，后期由于添加了很多的子模块(Submodules)，每个项目都有不同的设置，所以每个项目都会有一个Premake,然后通过include来添加，而不是全写在同一个Premake中，更好管理各个项目的配置</p><h3 id="最终项目">最终项目:</h3><p>首先是根目录下的Premake5.lua，也就是解决方案的配置文件，里面只Inclue各个项目的lua，并做好分组，看起来很干净</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;Dependencies.lua&quot;</span></span><br><span class="line"></span><br><span class="line">workspace <span class="string">&quot;HEngine&quot;</span></span><br><span class="line">    ...</span><br><span class="line">//上面介绍过的就不再写出来了</span><br><span class="line"></span><br><span class="line">group <span class="string">&quot;Dependencies&quot;</span></span><br><span class="line">include <span class="string">&quot;vendor/premake&quot;</span></span><br><span class="line">include <span class="string">&quot;HEngine/vendor/Glad&quot;</span></span><br><span class="line">include <span class="string">&quot;HEngine/vendor/msdf-atlas-gen&quot;</span></span><br><span class="line"></span><br><span class="line">//子模块是官网链接的我没权限添加Premake上去,意味着别人clone我的项目后是没有Premake文件的</span><br><span class="line">//为了让大家Clone后能使用，就把这类的单独放个文件夹里传上去</span><br><span class="line">include <span class="string">&quot;HEngine/vendor/premake/premake5_GLFW.lua&quot;</span></span><br><span class="line">include <span class="string">&quot;HEngine/vendor/premake/premake5_imgui.lua&quot;</span></span><br><span class="line">include <span class="string">&quot;HEngine/vendor/premake/premake5_yaml.lua&quot;</span></span><br><span class="line">include <span class="string">&quot;HEngine/vendor/premake/premake5_Box2D.lua&quot;</span></span><br><span class="line"></span><br><span class="line">group <span class="string">&quot;&quot;</span>//写一个空的group作用是结束当前的分组</span><br><span class="line"></span><br><span class="line">group <span class="string">&quot;Core&quot;</span></span><br><span class="line">include <span class="string">&quot;HEngine&quot;</span></span><br><span class="line">include <span class="string">&quot;HEngine-ScriptCore&quot;</span></span><br><span class="line">group <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">group <span class="string">&quot;Tools&quot;</span></span><br><span class="line">include <span class="string">&quot;HEngine-Editor&quot;</span></span><br><span class="line">group <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">group <span class="string">&quot;Misc&quot;</span></span><br><span class="line">include <span class="string">&quot;Sandbox&quot;</span></span><br><span class="line">group <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p><strong>Dependencies.lua</strong>  里面写好各个项目要Include的目录，后面项目就可以直接调用这个数组了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IncludeDir = &#123;&#125;</span><br><span class="line">IncludeDir[<span class="string">&quot;stb_image&quot;</span>] = <span class="string">&quot;%&#123;wks.location&#125;/HEngine/vendor/stb_image&quot;</span></span><br><span class="line">IncludeDir[<span class="string">&quot;yaml_cpp&quot;</span>] = <span class="string">&quot;%&#123;wks.location&#125;/HEngine/vendor/yaml-cpp/include&quot;</span></span><br><span class="line">IncludeDir[<span class="string">&quot;Box2D&quot;</span>] = <span class="string">&quot;%&#123;wks.location&#125;/HEngine/vendor/Box2D/include&quot;</span></span><br><span class="line">IncludeDir[<span class="string">&quot;GLFW&quot;</span>] = <span class="string">&quot;%&#123;wks.location&#125;/HEngine/vendor/GLFW/include&quot;</span></span><br><span class="line">IncludeDir[<span class="string">&quot;Glad&quot;</span>] = <span class="string">&quot;%&#123;wks.location&#125;/HEngine/vendor/Glad/include&quot;</span></span><br><span class="line">IncludeDir[<span class="string">&quot;ImGui&quot;</span>] = <span class="string">&quot;%&#123;wks.location&#125;/HEngine/vendor/ImGui&quot;</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>接下来是我们举两个项目的Premake例子</p><p><strong>HEngine.lua</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">project <span class="string">&quot;HEngine&quot;</span></span><br><span class="line">kind <span class="string">&quot;StaticLib&quot;</span></span><br><span class="line">language <span class="string">&quot;C++&quot;</span></span><br><span class="line">cppdialect <span class="string">&quot;C++17&quot;</span></span><br><span class="line">staticruntime <span class="string">&quot;off&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">targetdir</span> (<span class="string">&quot;%&#123;wks.location&#125;/bin/&quot;</span> .. outputdir .. <span class="string">&quot;/%&#123;prj.name&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">objdir</span> (<span class="string">&quot;%&#123;wks.location&#125;/bin-int/&quot;</span> .. outputdir .. <span class="string">&quot;/%&#123;prj.name&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">pchheader <span class="string">&quot;hepch.h&quot;</span><span class="comment">//Pch预编译文件，在HEngine学习笔记1-30有讲解到</span></span><br><span class="line">pchsource <span class="string">&quot;src/hepch.cpp&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下的上面单独介绍过了，就不重新介绍了</span></span><br><span class="line">files</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;src/**.h&quot;</span>,</span><br><span class="line"><span class="string">&quot;src/**.cpp&quot;</span>,</span><br><span class="line"><span class="string">&quot;vendor/stb_image/**.h&quot;</span>,</span><br><span class="line"><span class="string">&quot;vendor/stb_image/**.cpp&quot;</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">defines</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;_CRT_SECURE_NO_WARNINGS&quot;</span>,</span><br><span class="line"><span class="string">&quot;GLFW_INCLUDE_NONE&quot;</span>,</span><br><span class="line"><span class="string">&quot;YAML_CPP_STATIC_DEFINE&quot;</span>,</span><br><span class="line"><span class="string">&quot;IMGUI_DEFINE_MATH_OPERATORS&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">includedirs</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;src&quot;</span>,</span><br><span class="line"><span class="string">&quot;vendor/spdlog/include&quot;</span>,</span><br><span class="line"><span class="string">&quot;%&#123;IncludeDir.Box2D&#125;&quot;</span>,<span class="comment">//这里用上了之前Dependencies.lua的数组</span></span><br><span class="line"><span class="string">&quot;%&#123;IncludeDir.filewatch&#125;&quot;</span>,</span><br><span class="line"><span class="string">&quot;%&#123;IncludeDir.GLFW&#125;&quot;</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">links</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;Box2D&quot;</span>,</span><br><span class="line"><span class="string">&quot;GLFW&quot;</span>,</span><br><span class="line"><span class="string">&quot;Glad&quot;</span>,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GLFW.lua</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">local premakeDir = path.<span class="built_in">getabsolute</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">local projectDir = path.<span class="built_in">getabsolute</span>(<span class="string">&quot;../GLFW&quot;</span>)</span><br><span class="line">os.<span class="built_in">chdir</span>(projectDir)</span><br><span class="line"></span><br><span class="line">project <span class="string">&quot;GLFW&quot;</span></span><br><span class="line">    kind <span class="string">&quot;StaticLib&quot;</span></span><br><span class="line">    language <span class="string">&quot;C&quot;</span></span><br><span class="line">    staticruntime <span class="string">&quot;off&quot;</span></span><br><span class="line">    warnings <span class="string">&quot;off&quot;</span> -- 隐藏一些编译警告</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="built_in">targetdir</span> (<span class="string">&quot;bin/&quot;</span> .. outputdir .. <span class="string">&quot;/%&#123;prj.name&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">objdir</span> (<span class="string">&quot;bin-int/&quot;</span> .. outputdir .. <span class="string">&quot;/%&#123;prj.name&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line">files</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;include/GLFW/glfw3.h&quot;</span>,</span><br><span class="line">    <span class="string">&quot;include/GLFW/glfw3native.h&quot;</span>,</span><br><span class="line">    <span class="string">&quot;src/glfw_config.h&quot;</span>,       </span><br><span class="line">    <span class="string">&quot;src/internal.h&quot;</span>,       </span><br><span class="line">    <span class="string">&quot;src/platform.h&quot;</span>,       </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter <span class="string">&quot;system:windows&quot;</span></span><br><span class="line">    systemversion <span class="string">&quot;latest&quot;</span></span><br><span class="line"></span><br><span class="line">    files</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;src/win32_init.c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;src/win32_module.c&quot;</span>,   </span><br><span class="line">        <span class="string">&quot;src/win32_joystick.c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;src/win32_monitor.c&quot;</span>,</span><br><span class="line"> ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    defines </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="string">&quot;_GLFW_WIN32&quot;</span>,</span><br><span class="line">        <span class="string">&quot;_CRT_SECURE_NO_WARNINGS&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">filter <span class="string">&quot;configurations:Debug&quot;</span></span><br><span class="line">    runtime <span class="string">&quot;Debug&quot;</span></span><br><span class="line">    symbols <span class="string">&quot;on&quot;</span></span><br><span class="line"></span><br><span class="line">filter <span class="string">&quot;configurations:Release&quot;</span></span><br><span class="line">    runtime <span class="string">&quot;Release&quot;</span></span><br><span class="line">    optimize <span class="string">&quot;on&quot;</span></span><br></pre></td></tr></table></figure><p>写好了所有要配置的文件后，最后运行Script文件夹下的Win-GenProjects.bat,运行Premake.exe，即可完成项目的配置</p><p><strong>Win-GenProjects.bat</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">pushd %~dp0\..\</span><br><span class="line">call vendor\premake\bin\premake5.exe vs2022</span><br><span class="line">popd</span><br><span class="line">PAUSE</span><br></pre></td></tr></table></figure><p>最后可以看到在VStudio看到，里面各个项目是有分组的，很方便管理</p><p><img src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/2.webp" alt="2"></p>]]></content>
    
    
    <summary type="html">记录一些Premake5写法和使用中遇到的问题</summary>
    
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="游戏引擎" scheme="https://donghuiw.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法与外挂标签写法汇总</title>
    <link href="https://donghuiw.github.io/posts/2013454d"/>
    <id>https://donghuiw.github.io/posts/2013454d</id>
    <published>2024-06-05T10:19:03.000Z</published>
    <updated>2025-03-17T12:09:58.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Markdown语法自带格式">1.Markdown语法自带格式</h2><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><p>文章一律使用<code>markdown</code>文档，后缀名为<code>.md</code></p><p>使用<code>hexo new &quot;文章名称&quot;</code>在<code>source\_posts</code>中创建文件后，就能直接打开开始写作了</p><h3 id="1-0-Front-matter">1.0 Front-matter</h3><p>每篇文章的开头都有一个<code>Front-matter</code>，用于保存这篇文章的信息</p><p>一般情况下，我们只需要关注<code>title</code>、<code>date</code>、<code>tags</code>、<code>categories</code>这4个参数</p><ul><li><code>title</code>：【必需】文章标题</li><li><code>date</code>：【必需】写作时间，还有一个相关参数是<code>updated</code>，但不需要加，编译器会把<code>md</code>文件的修改时间作为更新时间</li><li><code>tags</code>：文章标签，语法为<code>tags: [A,B]</code>，这样就为这个文章添加了<code>A</code>，<code>B</code>2个标签</li><li><code>categories</code>：文章分类，语法为<code>categories: [A,B]</code>，这表示本文属于<code>A</code>分类下的<code>B</code>子类</li><li>swiper_index:  设置文章滚动栏优先级，数字越高优先级越大</li><li><code>description</code>:  文章描述</li></ul><p>另外还有一个参数 <code>sticky</code> ，语法为 <code>sticky: n</code> ，它可以设定置顶文章，而且优先级为 <code>n</code></p><h3 id="1-1-代码块">1.1 代码块</h3><p><strong>&amp;nbsp; 表示半角空格（英文）</strong></p><p><strong>&amp;emsp; 表示全角空格（中文）</strong></p><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-2-多级标题">1.2 多级标题</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-3-文字样式">1.3 文字样式</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h3 id="1-4-引用">1.4 引用</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-5-分割线">1.5 分割线</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h3><h4 id="1-6-1-无序列表">1.6.1 无序列表</h4><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h4 id="1-6-2-有序列表">1.6.2 有序列表</h4><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-7-图片">1.7 图片</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-8-表格">1.8 表格</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-9-公式">1.9 公式</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-Butterfly外挂标签">2.Butterfly外挂标签</h2><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h3 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-2-行内文本-span">2.2 行内文本 span</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-3-段落文本-p">2.3 段落文本 p</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-4-引用note">2.4 引用note</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-5-上标标签-tip">2.5 上标标签 tip</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-6-动态标签-anima">2.6 动态标签 anima</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-8-单选列表-radio">2.8 单选列表 radio</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-10-链接卡片-link">2.10 链接卡片 link</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-11-按钮-btns">2.11 按钮 btns</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-16-单张图片-image">2.16 单张图片 image</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-17-音频-audio">2.17 音频 audio</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-18-视频-video">2.18 视频 video</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-19-相册-gallery">2.19 相册 gallery</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-20-折叠框-folding">2.20 折叠框 folding</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-21-分栏-tab">2.21 分栏 tab</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-24-特效标签wow">2.24 特效标签wow</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-25-进度条-progress">2.25  进度条 progress</h3><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-26-注释-notation">2.26 注释 notation</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-28-引用文献-reference">2.28 引用文献 reference</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-29-PDF展示">2.29 PDF展示</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="2-31-隐藏块">2.31 隐藏块</h3>]]></content>
    
    
    <summary type="html">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</summary>
    
    
    
    <category term="演示" scheme="https://donghuiw.github.io/categories/%E6%BC%94%E7%A4%BA/"/>
    
    
    <category term="演示" scheme="https://donghuiw.github.io/tags/%E6%BC%94%E7%A4%BA/"/>
    
  </entry>
  
</feed>
