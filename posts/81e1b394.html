<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HEngine游戏引擎(01-30) | DongHuiWang</title><meta name="keywords" content="游戏引擎"><meta name="author" content="DongHuiWang"><meta name="copyright" content="DongHuiWang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="记录HEngine每一次提交的重点内容以及遇到的问题和解决的步骤">
<meta property="og:type" content="article">
<meta property="og:title" content="HEngine游戏引擎(01-30)">
<meta property="og:url" content="https://donghuiw.github.io/posts/81e1b394">
<meta property="og:site_name" content="DongHuiWang">
<meta property="og:description" content="记录HEngine每一次提交的重点内容以及遇到的问题和解决的步骤">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/winterdev/images/raw/master/blog_cover6.webp">
<meta property="article:published_time" content="2025-03-02T02:27:10.000Z">
<meta property="article:modified_time" content="2025-03-13T14:07:08.599Z">
<meta property="article:author" content="DongHuiWang">
<meta property="article:tag" content="游戏引擎">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/winterdev/images/raw/master/blog_cover6.webp"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://donghuiw.github.io/posts/81e1b394"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HEngine游戏引擎(01-30)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-13 22:07:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 8 || hour >= 22
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><script src="https://npm.elemecdn.com/echarts@4.9.0/dist/echarts.min.js"></script><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="DongHuiWang" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/toxiang.webp" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche"></use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan"></use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie"></use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">DongHuiWang</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1"></use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian"></use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei"></use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche"></use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan"></use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie"></use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane"></use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">HEngine游戏引擎(01-30)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2025-03-02T02:27:10.000Z" title="发表于 2025-03-02 10:27:10">2025-03-02</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-13T14:07:08.599Z" title="更新于 2025-03-13 22:07:08">2025-03-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">2w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>86分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HEngine游戏引擎(01-30)"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>1-15是些基础工作、如项目构建、添加子模块、使引擎具有日志系统、事件系统，可视化窗口等基础功能</p>
<p>16开始是游戏引擎最核心的部分-Rendering，使引擎能够真正绘制出图形，如果想直接看这部分点此<a href="#16">链接</a>跳转</p>
<h2 id="一、-项目设置"><a href="#一、-项目设置" class="headerlink" title="一、  项目设置"></a>一、  项目设置</h2><p>新建HEngine和Sandbox项目，HEngine项目生成为dll，Sandbox项目生成为exe，运行此exe通过动态链接HEngine的dll，可以调用dll定义的函数并输出信息。</p>
<p><strong>1.调整输出目录和中间的目录</strong></p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(SolutionDir)\bin\$(Configuration)-$(Platform)\$(ProjectName)\ </span><br><span class="line">$(SolutionDir)\bin-<span class="keyword">int</span>\$(Configuration)-$(Platform)\$(ProjectName)\</span><br></pre></td></tr></table></figure>
<p>生成的文件在bin目录下，生成的intermediate文件在bin-int目录下，大概是这么个目录结构</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin<span class="regexp">/Debug-x64/</span>ProjectName/</span><br><span class="line">bin-<span class="keyword">int</span><span class="regexp">/Debug-64x/</span>ProjectName/</span><br></pre></td></tr></table></figure>
<p>中间目录:存储一些obj、二进制文件，生成好dll、exe后可以删除此文件夹</p>
<p><strong>2.Sandbox项目引用HEngine项目</strong></p>
<p>C++：静态链接与动态链接<br>阅读的博客，讲的很通俗易懂：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kang___xi/article/details/80210717">https://blog.csdn.net/kang___xi/article/details/80210717</a></p>
<ul>
<li><p>静态链接</p>
<ul>
<li><p>说明</p>
<ul>
<li>使用静态库方式链接，编译后链接时会将使用的库函数对应所包含库函数定义的.o目标文件都包含在exe文件中。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li>执行速度快：因为可执行文件程序内部包含了所有需要执行的东西</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>浪费空间：因为多个可执行程序对同所需要的目标文件都有一份副本</p>
</li>
<li><p>更新慢：如果有一个.o目标文件发生改变，那么对应的使用这个.o目标文件的多个可执行程序需要重新来一遍链接过程，即链接多个.o目标文件来实现生成可执行文件。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>动态链接</p>
<ul>
<li><p>说明</p>
<ul>
<li>使用动态库方式链接，编译后因为推迟链接不会将使用的库函数对应的dll文件都包含在exe文件中，而是在exe运行的时候将dll加载到内存CPU中再链接。</li>
</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>节省空间：多个可执行程序对同所需要的库函数共享一份副本</p>
</li>
<li><p>更新快：一个源文件发生改变，只需更新编译成dll文件，不用每个可执行程序需要重新来一遍链接过程，因为多个可执行程序在运行时时链接，且共享一份副本</p>
</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>启动速度慢：因为每次执行程序都需要链接</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二、-程序入口"><a href="#二、-程序入口" class="headerlink" title="二、  程序入口"></a>二、  程序入口</h2><h4 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件"></a>代码文件</h4><ul>
<li><p>HEngine项目</p>
<ul>
<li><p>Application类</p>
<p>引擎内部功能实现</p>
</li>
<li><p>Core.h</p>
<p>来根据不同项目的条件编译，而写dll导入还是导出的宏定义</p>
</li>
<li><p>EntryPoint.h</p>
<p>入口点，main函数</p>
</li>
<li><p>HEngine.h</p>
<p>引入其它头文件，控制给Sandbox项目提供哪些引擎内部功能</p>
</li>
</ul>
</li>
<li><p>Sandbox项目</p>
<ul>
<li><p>SanboxApp.cpp</p>
<p>应用层实现</p>
</li>
</ul>
</li>
</ul>
<h4 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h4><ul>
<li><p>在HEngine项目的Application.h中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Application&#123;</span><br><span class="line">	....</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// To be defined in CLIENT</span></span><br><span class="line">	<span class="function">Application* <span class="title">CreateApplication</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在HEngine命名空间内声明了CreateApplication函数</p>
</li>
<li><p>在Sandbox项目的SandboxApp.cpp中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HEngine::Application* <span class="title">HEngine::CreateApplication</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sandbox</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了CreateApplication函数</p>
</li>
<li><p>在EntryPoint.h中调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> HEngine::Application* <span class="title">HEngine::CreateApplication</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> app = HEngine::<span class="built_in">CreateApplication</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将CreateApplication函数声明为<strong>extern</strong>，表示此函数会在外部定义，接下来使用的这函数时将使用在外部定义的CreateApplication</p>
</li>
</ul>
<p><strong>包含头文件+条件编译和宏定义实现Dll导入与导出</strong></p>
<p><strong>前提操作</strong></p>
<ul>
<li>HEngine项目</li>
</ul>
<p>​    右键项目Proterties(所有配置)  =&gt;   C/C++  =&gt;    Preprocessor(预处理器)  =&gt;    Definitions(预处理器定义)</p>
<p>​    输入:     HE_PLATFORM_WINDOWS;    HE_BUILD_DLL</p>
<ul>
<li><p>Sandbox项目</p>
<ul>
<li><p>同上</p>
<p>输入:     HE_PLATFORM_WINDOWS;</p>
</li>
<li><p>右键属性(所有配置)  =&gt;  C/C++   =&gt;   General(常规)   =&gt;   附加包含目录</p>
<p>输入:     $(SolutionDir)HEngine\src</p>
<p>为了Sandbox项目能引入HEngine项目的文件</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;HEngine.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在Core.h中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HE_PLATFORM_WINDOWS</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> HE_BUILD_DLL</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> HEngine_API __declspec(dllexport)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> HEngine_API __declspec(dllimport)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">error</span> HEngine only supports Windows!</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>根据条件编译定义<strong>HEngine_API</strong>是dll导入还是导出，HEngine项目将是<strong>declspec(dllexport)，Sandbox项目是</strong>declspec(dllimport)</p>
</li>
</ul>
<h4 id="程序运行流程"><a href="#程序运行流程" class="headerlink" title="程序运行流程"></a>程序运行流程</h4><ul>
<li><p>EntryPoint.h<strong>定义了main函数</strong>，即写了入口点，所以程序会在这运行</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HE_PLATFORM_WINDOWS</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> HEngine::Application* <span class="title">HEngine::CreateApplication</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> app = HEngine::<span class="built_in">CreateApplication</span>();</span><br><span class="line">	app-&gt;<span class="built_in">Run</span>();</span><br><span class="line">	<span class="keyword">delete</span> app;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>main函数中执行CreateApplication函数，将调用<strong>定义在SandboxApp.cpp</strong>中的CreateApplication函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HEngine::Application* <span class="title">HEngine::CreateApplication</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Sandbox</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这函数返回的指针是HEngine项目中的<strong>Application父类指针</strong>，所以auto app的类型是Application*。</p>
</li>
<li><p>当执行app-&gt;Run()函数时，由于Run()函数<strong>没有</strong>声明为虚函数，所以会调用Application.cpp中的<strong>Run()函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line">	Application::<span class="built_in">Application</span>()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	Application::~<span class="built_in">Application</span>()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="三、-日志系统-Premake"><a href="#三、-日志系统-Premake" class="headerlink" title="三、  日志系统 + Premake"></a>三、  日志系统 + Premake</h2><p>主要是以下几个任务</p>
<ol>
<li>创建Log类，然后有s_CoreLogger和s_ClientLogger，分别处理引擎的log和client的log</li>
<li>使用spdlog，具体主要是怎么利用git submodule使用该库</li>
<li>使用宏来封装对应的log函数，使用宏可以更好的方便不同平台的应用</li>
<li>用lua脚本配置项目属性，使用premake运行程序<strong>一键生成</strong>VS项目及属性</li>
</ol>
<p>游戏引擎少不了LogStystem，这里使用了别人做好的日志系统，叫做spdlog, 原作者是<a target="_blank" rel="noopener" href="https://github.com/gabime/spdlog.git，因为我要在内部加入Premake5文件，所以fork到我自己的仓库再添加子模块，就变成了">https://github.com/gabime/spdlog.git，因为我要在内部加入Premake5文件，所以fork到我自己的仓库再添加子模块，就变成了</a></p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https:<span class="regexp">//gi</span>thub.com<span class="regexp">/donghuiw/</span>spdlog.git HEngine<span class="regexp">/vendor/</span>spdlog</span><br></pre></td></tr></table></figure>
<p>对于这个LogSystem，底层使用的是spdlog，上层封装一层HEngine的Log类，以下是核心代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	std::shared_ptr&lt;spdlog::logger&gt; Log::s_CoreLogger;</span><br><span class="line">	std::shared_ptr&lt;spdlog::logger&gt; Log::s_ClientLogger;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Log::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		spdlog::<span class="built_in">set_pattern</span>(<span class="string">&quot;%^[%T] %n: %v%$&quot;</span>);</span><br><span class="line"></span><br><span class="line">		s_CoreLogger = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;HEngine&quot;</span>);</span><br><span class="line">		s_CoreLogger-&gt;<span class="built_in">set_level</span>(spdlog::level::trace);</span><br><span class="line">		s_ClientLogger = spdlog::<span class="built_in">stdout_color_mt</span>(<span class="string">&quot;APP&quot;</span>);</span><br><span class="line">		s_ClientLogger-&gt;<span class="built_in">set_level</span>(spdlog::level::trace);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额外的宏操作，这里的宏的写法可以实现函数的宏，代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> std::shared_ptr&lt;spdlog::logger&gt;&amp; <span class="title">GetCoreLogger</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_CoreLogger; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">static</span> std::shared_ptr&lt;spdlog::logger&gt;&amp; <span class="title">GetClientLogger</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_ClientLogger; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//core log macros</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_CORE_TRACE(...)		 ::HEngine::Log::GetCoreLogger()-&gt;trace(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_CORE_INFO(...)		 ::HEngine::Log::GetCoreLogger()-&gt;info(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HE_CORE_WARN(...)		 ::HEngine::Log::GetCoreLogger()-&gt;warn(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure>
<h4 id="Git删除子模块"><a href="#Git删除子模块" class="headerlink" title="Git删除子模块"></a>Git删除子模块</h4><p>因添加子模块时候，写错代码，导致子模块添加路径错误，需要删除子模块并重新添加。而删除子模块是个稍微麻烦的事，网上查阅后，在此记录一下</p>
<p><strong>1. 删除submodule缓存</strong></p>
<p><strong>需要先暂存 .gitmodules 文件</strong>, 否则会报错: fatal: please stage your changes to .gitmodules or stash them to proceed</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .gitmodules</span><br><span class="line">git rm --cached submodule_name </span><br></pre></td></tr></table></figure>
<p>若报什么index已经存在的错误，说明没有执行git rm —cached 命令。</p>
<p>若报什么please stage your changes to .gitmodules or stash them to proceed，说明没有执行git add .gitmodules命令</p>
<p><strong>2. 修改.gitmodules</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移除对应的submodule信息, 只有<span class="number">1</span>个submodule信息的时候也可以删除该文件.</span><br></pre></td></tr></table></figure>
<p><strong>3. .git/modules</strong></p>
<p>移除对应的submodule目录, 进入.git\modules\HEngine\vendor,删除对应的子模块文件夹</p>
<p><strong>4. .git/config</strong></p>
<p>移除config文件内对应的submodule目录</p>
<h4 id="Premake5使用及问题汇总"><a href="#Premake5使用及问题汇总" class="headerlink" title="Premake5使用及问题汇总"></a><a href="https://donghuiw.github.io/posts/a1665e0e">Premake5使用及问题汇总</a></h4><p><strong>Premake生成项目的部分单独写了一个blog，关于使用第三方库文件的一般会单独写一个详细的，也方便查阅</strong></p>
<hr>
<h2 id="四、-事件系统"><a href="#四、-事件系统" class="headerlink" title="四、  事件系统"></a>四、  事件系统</h2><p><a id="4"></a></p>
<p>思路是由Application创建自己的窗口window，对应的window类不应该知道任何Application的信息，所以Application在创建自己的window时，还要同时创建一个callback，在这之前，需要知道以下内容：</p>
<ul>
<li>std::function的用法</li>
<li>C++中的enum和enum class</li>
<li><code>#</code>和<code>##</code>在C++宏里的用法</li>
<li>C++虚函数的<code>override</code>关键字和相关用法</li>
</ul>
<p>我把这种补充知识点放到<a target="_blank" rel="noopener" href="https://winterdev.cn/posts/e0684db9"><strong>游戏引擎开发补充知识点</strong></a>,方便查看</p>
<p>现在可以正式开始<code>Event</code>的设计了，首先需要定义的就是<code>Event</code>和<code>EventType</code>类，这里把<code>Event</code>作为基类，<code>EventType</code>是enum class，包含了基本的外设事件，如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">EventType</span></span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    WindowClose, WindowResize, WindowFocus, WindowLostFocus, WindowMoved,</span><br><span class="line">    AppTick, AppUpdate, AppRender,</span><br><span class="line">    KeyPressed, KeyReleased,</span><br><span class="line">    MouseButtonPressed, MouseButtonReleased, MouseMoved, MouseScrolled</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于<code>Event</code>类型，作为基类，那么最基本的两个接口应该为：</p>
<ul>
<li>获取该事件的类型</li>
<li>获取该事件的名字</li>
</ul>
<p>作为基类，这都是最基本的API，再者，为了方便使用，仿照C#的方式，C#语言里所有的Object都有一个ToString函数，方便我们打印一些消息，所以这个API我们也把它加入到<code>Event</code>基类里，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>目前就是这样，然后我们还需要一个<code>EventCategory</code>枚举，以后用flag来快速筛选特定的<code>Event</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIT(x) (1 &lt;&lt; x)</span></span><br><span class="line"><span class="comment">// events filter</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">EventCategory</span></span><br><span class="line">&#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    EventCategoryApplication    = <span class="built_in">BIT</span>(<span class="number">0</span>),</span><br><span class="line">    EventCategoryInput          = <span class="built_in">BIT</span>(<span class="number">1</span>),</span><br><span class="line">    EventCategoryKeyboard       = <span class="built_in">BIT</span>(<span class="number">2</span>),</span><br><span class="line">    EventCategoryMouse          = <span class="built_in">BIT</span>(<span class="number">3</span>),</span><br><span class="line">    EventCategoryMouseButton    = <span class="built_in">BIT</span>(<span class="number">4</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义Event这个基类，就可以着手创建对应的子类的，拿鼠标事件举例，一共有<code>MouseMoved</code>、<code>MouseButtonPressed</code>、<code>MouseButtonReleased</code>、<code>MouseButtonScrolled</code>四种，那么我就建立四个子类，全放在<code>MouseEvent.h</code>文件下，拿<code>MouseMoved</code>举例，其类型为之前枚举定义的<code>MouseMovedEvent</code>，其ToString应该是打印出鼠标移动的offset值，由于该类的所有<code>Event</code>类型都是一样的，所以我们可以用一个static变量去存储该类型就够了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MouseMovedEvent</span> : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> EventType <span class="title">GetStaticType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> EventType::MouseMoved; &#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetStaticType</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MouseMoved&quot;</span>; &#125;</span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::stringstream a;</span><br><span class="line">        a &lt;&lt; <span class="string">&quot;MouseMovedEvent: xOffset = &quot;</span> &lt;&lt; <span class="built_in">GetXOffset</span>() &lt;&lt; <span class="string">&quot;, yOffset = &quot;</span> &lt;&lt; <span class="built_in">GetYOffset</span>();</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetXOffset</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_xOffset; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">float</span> <span class="title">GetYOffset</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_yOffset; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> m_xOffset, m_yOffset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>OK，写完了这个类，就可以继续写类似的鼠标事件的类了，但是我发现有一些代码都是非常类似的，写起来很麻烦，也很影响阅读：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MouseMovedEvent</span> : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> EventType <span class="title">GetStaticType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> EventType::MouseMoved; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetStaticType</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MouseMoved&quot;</span>; &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouseButtonPressedEvent</span>: <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">static</span> EventType <span class="title">GetStaticType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> EventType::MouseButtonPressed; &#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> EventType <span class="title">GetEventType</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetStaticType</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;MouseButtonPressed&quot;</span>; &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我学到了一个方法，用宏去代替我们编写这么长的语句，这个宏名就叫做<code>EVENT_CLASS_TYPE(typename)</code>，来为我们生成对应的函数，通过<code>#</code>和<code>##</code>符号，可以达到这种效果，一个<code>#</code>是转换成字符串，两个<code>#</code>是原语句替换，所以就是这么简化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于简化代码, 因为很多类都有着相同的函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EVENT_CLASS_TYPE(type) \</span></span><br><span class="line"><span class="meta">static EventType GetStaticType() &#123; return EventType::##type; &#125;\</span></span><br><span class="line"><span class="meta">const EventType GetEventType() const override &#123; return GetStaticType(); &#125;\</span></span><br><span class="line"><span class="meta">const char* GetName() const override &#123; return #type; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MouseMovedEvent</span> : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(MouseMoved)</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就像这样，我们可以把所有鼠标事件的类定义好，接下来还需要的定义的输入类就是Window Event、ApplicationEvent和KeyEvent，先说前两种Event，最后着重提一下KeyEvent，键盘事件的输入处理并不像点击鼠标那么简单，通常（简单的事件系统里）我们是没有长按鼠标的操作的，但是却有长按键盘的操作，当我们按键盘时，会先打印一个字母，然后停顿一下，如果这个时候还按着按钮，就继续打印剩余的字母。</p>
<p>所以说，按键的时候，第一次会立马打印第一个字母，然后需要记录我按的次数（或者记录按的时间），当记录的值达到一定阈值（或时间）时，才会继续不停打印接下来的字母，这里我们不用时间记录，而是用一个int值，记录按相同键的次数。</p>
<p>设计KeyEvent类的时候，可以发现，<code>KeyPressedEvent</code>会比<code>KeyReleasedEvent</code>的数据多一个，前者会额外记录按下Key时，key走过的Loop的总数，所以这个时候可以设计一个基类叫做KeyEvent，这里放通用的数据，就是Key的keycode，用于存放Key类型共有的内容，设计思路如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> KeyEvent : <span class="keyword">public</span> Event</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetKeycode</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> keycode;&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">EVENT_CLASS_CATEGORY</span>(EventCategoryKeyboard | EventCategoryInput)</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="comment">// 构造函数设为Protected，意味着只有其派生类能够调用此函数</span></span><br><span class="line">	<span class="built_in">KeyEvent</span>(<span class="type">int</span> keycode): <span class="built_in">keycode</span>(code)&#123;&#125; </span><br><span class="line">	<span class="type">int</span> keycode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后再写对应的子类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> KeyPressedEvent : <span class="keyword">public</span> KeyEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">KeyPressedEvent</span>(<span class="type">int</span> keycode, <span class="type">int</span> repeatCount)</span><br><span class="line">		: <span class="built_in">KeyEvent</span>(keycode), <span class="built_in">m_RepeatCount</span>(repeatCount) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">GetRepeatCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_RepeatCount; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::stringstream ss;</span><br><span class="line">		ss &lt;&lt; <span class="string">&quot;KeyPressedEvent: &quot;</span> &lt;&lt; m_KeyCode &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; m_RepeatCount &lt;&lt; <span class="string">&quot; repeats)&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EVENT_CLASS_TYPE</span>(KeyPressed)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_RepeatCount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="五、-预编译头文件"><a href="#五、-预编译头文件" class="headerlink" title="五、  预编译头文件"></a>五、  预编译头文件</h2><p>为了避免头文件被反复编译，需要加上pch文件，可以加快编译速度，主要有以下几点</p>
<ul>
<li>需要在VS工程里添加hepch.h和hepch.cpp文件，前者放所有常用的库的头文件，对于后者，一般的pch是不需要cpp文件的，但是VS工程里需要这个东西，所以得加上，然后让他引用hepch.h</li>
<li>然后在premake5.lua文件里进行修改，添加两个参数，pchheader “…” 和 pchsource “…” ,后者一般只是VS工程需要，其他平台会忽略这个，再次Build工程后，项目属性配置里会显示，使用pch</li>
<li>最后再把所有用到基本库的cpp（或者说所有cpp）里，都加上<code>#include &quot;hepch.h&quot;</code></li>
</ul>
<p>有两个重点注意:</p>
<p><strong>第一个是</strong>在premake5.lua中添加pchheader可以不顾当前路径随便写，但是pchsource得明确指定路径，需要改成：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pchheader <span class="string">&quot;hepch.h&quot;</span></span><br><span class="line">pchsource <span class="string">&quot;hepch.cpp&quot;</span>  ×</span><br><span class="line">pchsource <span class="string">&quot;%&#123;prj.name&#125;/Src/hepch.cpp&quot;</span> <span class="comment">-- 根目录基于premake5.lua文件</span></span><br></pre></td></tr></table></figure>
<p><strong>第二个</strong>是，如果勾选了使用pch文件，项目内的所有.cpp文件都要添加include “pch.h”，而且一定要在第一行</p>
<hr>
<h2 id="六、-GlFW窗口"><a href="#六、-GlFW窗口" class="headerlink" title="六、  GlFW窗口"></a>六、  GlFW窗口</h2><p>总体思路是:  Application类调用创建窗口函数，而Window类使用glfw库创建<strong>真正的</strong>窗口。Window类<strong>检测</strong>glfw窗口的事件，并<strong>回调</strong>给Application的处理事件函数。</p>
<p>在做这个事情之前,下面这些概念都得熟悉：Vsync、Observe Pattern、回调函数、函数指针,都放在<a target="_blank" rel="noopener" href="https://winterdev.cn/posts/e0684db9"><strong>游戏引擎开发补充知识点</strong></a>,方便查看</p>
<p><strong>步骤</strong></p>
<ul>
<li><p>添加glfw子模块</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add submodule https:<span class="comment">//github.com/glfw/glfw HEngine/vendor/GLFW</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改premake</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">IncludeDir = &#123;&#125;</span><br><span class="line">IncludeDir[<span class="string">&quot;GLFW&quot;</span>] = <span class="string">&quot;Hengine/vendor/GLFW/include&quot;</span></span><br><span class="line"><span class="comment">-- 这个include，相当于把glfw下的premake5.lua内容拷贝到这里</span></span><br><span class="line">include <span class="string">&quot;Hengine/vendor/GLFW&quot;</span></span><br><span class="line"></span><br><span class="line">project <span class="string">&quot;HEngine&quot;</span>		</span><br><span class="line">	location <span class="string">&quot;Hengine&quot;</span>		</span><br><span class="line">	kind <span class="string">&quot;SharedLib&quot;</span>		</span><br><span class="line"></span><br><span class="line">	includedirs&#123;</span><br><span class="line">		<span class="string">&quot;%&#123;prj.name&#125;/src&quot;</span>,</span><br><span class="line">		<span class="string">&quot;%&#123;prj.name&#125;/vendor/spdlog/include&quot;</span>,</span><br><span class="line">		<span class="string">&quot;%&#123;IncludeDir.GLFW&#125;&quot;</span>	<span class="comment">-- 包含GLFW目录</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	links </span><br><span class="line">	&#123; </span><br><span class="line">		<span class="string">&quot;GLFW&quot;</span>,			<span class="comment">-- HEngine链接glfw项目</span></span><br><span class="line">		<span class="string">&quot;opengl32.lib&quot;</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Window类"><a href="#Window类" class="headerlink" title="Window类"></a><strong>Window类</strong></h4><p>Window类作为接口类，需要包含通用的窗口内容：</p>
<ul>
<li>一个Update函数，用于在loop里每帧循环</li>
<li>窗口的长和宽，以及相应的Get函数</li>
<li>设置窗口的Vsync和Get窗口的Vsync函数</li>
<li>窗口的回调函数，当窗口接受事件输入时，会调用这个回调函数</li>
</ul>
<ul>
<li><p><strong>代码</strong></p>
<p>window.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">WindowProps</span></span><br><span class="line">    &#123;<span class="comment">// 窗口初始化设置的内容</span></span><br><span class="line">		std::string Title;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> Width;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> Height;</span><br><span class="line">		<span class="built_in">WindowProps</span>(<span class="type">const</span> std::string&amp; title = <span class="string">&quot;HEngine Engine&quot;</span>,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> width = <span class="number">1280</span>,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> height = <span class="number">720</span>)</span><br><span class="line">			: <span class="built_in">Title</span>(title), <span class="built_in">Width</span>(width), <span class="built_in">Height</span>(height)&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Window</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">using</span> EventCallbackFn = std::function&lt;<span class="built_in">void</span>(Event&amp;)&gt;;</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Window</span>() &#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// Window attributes</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetEventCallback</span><span class="params">(<span class="type">const</span> EventCallbackFn&amp; callback)</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsVSync</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 在Window父类声明创建函数</span></span><br><span class="line">		<span class="function"><span class="type">static</span> Window* <span class="title">Create</span><span class="params">(<span class="type">const</span> WindowProps&amp; props = WindowProps())</span></span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowsWindow.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">WindowsWindow</span> : <span class="keyword">public</span> Window</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">WindowsWindow</span>(<span class="type">const</span> WindowProps&amp; props);</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">WindowsWindow</span>();</span><br><span class="line">		Window函数重载...</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		GLFWwindow* m_Window;</span><br><span class="line">		<span class="keyword">struct</span> <span class="title class_">WindowData</span>&#123;</span><br><span class="line">			std::string Title;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> Width, Height;</span><br><span class="line">			<span class="type">bool</span> VSync;</span><br><span class="line">			EventCallbackFn EventCallback;</span><br><span class="line">		&#125;;</span><br><span class="line">		WindowData m_Data;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowsWindow.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">bool</span> s_GLFWInitialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 在WindowsWindow子类定义在Window父类声明的函数</span></span><br><span class="line">	<span class="function">Window* <span class="title">Window::Create</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WindowsWindow</span>(props);</span><br><span class="line">	&#125;</span><br><span class="line">	WindowsWindow::<span class="built_in">WindowsWindow</span>(<span class="type">const</span> WindowProps&amp; props)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">Init</span>(props);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WindowsWindow::Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		m_Data.Title = props.Title;</span><br><span class="line">		m_Data.Width = props.Width;</span><br><span class="line">		m_Data.Height = props.Height;</span><br><span class="line">		<span class="built_in">HE_CORE_INFO</span>(<span class="string">&quot;Creating window &#123;0&#125; (&#123;1&#125;, &#123;2&#125;)&quot;</span>, props.Title, props.Width, props.Height);</span><br><span class="line">		<span class="keyword">if</span> (!s_GLFWInitialized)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> glfwTerminate on system shutdown</span></span><br><span class="line">			<span class="type">int</span> success = <span class="built_in">glfwInit</span>();</span><br><span class="line">			<span class="built_in">HE_CORE_ASSERT</span>(success, <span class="string">&quot;Could not intialize GLFW!&quot;</span>);</span><br><span class="line">			s_GLFWInitialized = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 创建窗口</span></span><br><span class="line">		m_Window = <span class="built_in">glfwCreateWindow</span>((<span class="type">int</span>)props.Width, (<span class="type">int</span>)props.Height, m_Data.Title.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">		<span class="comment">// 设置glfw当前的上下文</span></span><br><span class="line">		<span class="built_in">glfwMakeContextCurrent</span>(m_Window);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			设置窗口关联的用户数据指针。这里GLFW仅做存储，不做任何的特殊处理和应用。</span></span><br><span class="line"><span class="comment">			window表示操作的窗口句柄。</span></span><br><span class="line"><span class="comment">			pointer表示用户数据指针。</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="built_in">glfwSetWindowUserPointer</span>(m_Window, &amp;m_Data);</span><br><span class="line">		<span class="built_in">SetVSync</span>(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">WindowsWindow::OnUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="built_in">glfwPollEvents</span>();			<span class="comment">// 轮询事件	</span></span><br><span class="line">		<span class="built_in">glfwSwapBuffers</span>(m_Window);	<span class="comment">// 交换缓冲</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">WindowsWindow::SetVSync</span><span class="params">(<span class="type">bool</span> enabled)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (enabled)</span><br><span class="line">			<span class="built_in">glfwSwapInterval</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">glfwSwapInterval</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		m_Data.VSync = enabled;</span><br><span class="line">	&#125;</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="其它修改"><a href="#其它修改" class="headerlink" title="其它修改"></a><strong>其它修改</strong></h4><ul>
<li><p>Application</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line">	Application::<span class="built_in">Application</span>()</span><br><span class="line">    &#123;</span><br><span class="line">		m_Window = std::<span class="built_in">unique_ptr</span>&lt;Window&gt;(Window::<span class="built_in">Create</span>()); <span class="comment">// 创建窗口</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (m_Running)</span><br><span class="line">        &#123;</span><br><span class="line">			<span class="built_in">glClearColor</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">			<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);		</span><br><span class="line">			m_Window-&gt;<span class="built_in">OnUpdate</span>();	<span class="comment">// 更新glfw</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="七、-GLFW事件"><a href="#七、-GLFW事件" class="headerlink" title="七、  GLFW事件"></a>七、  GLFW事件</h2><p>使用GLFW函数设置（拦截）真正窗口事件的回调函数，在回调函数中<strong>转换</strong>为我们自定义的事件，再<strong>回调</strong>给Application的OnEvent，OnEvent拦截对应的事件</p>
<p><strong>WindowsWindow.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GLFWErrorCallback</span><span class="params">(<span class="type">int</span> error, <span class="type">const</span> <span class="type">char</span>* description)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">HE_CORE_ERROR</span>(<span class="string">&quot;GLFW Error (&#123;0&#125;): &#123;1&#125;&quot;</span>, error, description);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WindowsWindow::Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s_GLFWInitialized)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">glfwSetErrorCallback</span>(GLFWErrorCallback); <span class="comment">//从glfw里设置自己的回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置glfw事件回调=接收glfw窗口事件</span></span><br><span class="line">    <span class="built_in">glfwSetWindowSizeCallback</span>(m_Window, [](GLFWwindow* window, <span class="type">int</span> width, <span class="type">int</span> height)</span><br><span class="line">    &#123;</span><br><span class="line">        WindowData&amp; data = *(WindowData*)<span class="built_in">glfwGetWindowUserPointer</span>(window);</span><br><span class="line">        data.Width = width;</span><br><span class="line">        data.Height = height;</span><br><span class="line"></span><br><span class="line">        WindowResizeEvent <span class="built_in">event</span>(width, height);</span><br><span class="line">        data.<span class="built_in">EventCallback</span>(event);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowCloseCallback</span>(m_Window, [](GLFWwindow* window)</span><br><span class="line">    &#123;</span><br><span class="line">        WindowData&amp; data = *(WindowData*)<span class="built_in">glfwGetWindowUserPointer</span>(window);</span><br><span class="line">        WindowCloseEvent event;</span><br><span class="line">        data.<span class="built_in">EventCallback</span>(event);</span><br><span class="line">    &#125;);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p><strong>Application.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BIND_EVENT_FN(x) std::bind(&amp;Application::x, this, std::placeholders::_1)</span></span><br><span class="line"></span><br><span class="line">Application::<span class="built_in">Application</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		m_Window = std::<span class="built_in">unique_ptr</span>&lt;Window&gt;(Window::<span class="built_in">Create</span>());</span><br><span class="line">		m_Window-&gt;<span class="built_in">SetEventCallback</span>(std::<span class="built_in">bind</span>(&amp;Application::OnEvent, <span class="keyword">this</span>, std::placeholders::_1));<span class="comment">// 设置window的callback为此对象的OnEvent函数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Application::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">EventDispatcher <span class="title">dispatcher</span><span class="params">(e)</span></span>;</span><br><span class="line">		dispatcher.<span class="built_in">Dispatch</span>&lt;WindowCloseEvent&gt;(<span class="built_in">BIND_EVENT_FN</span>(OnWindowClose));</span><br><span class="line"></span><br><span class="line">		<span class="built_in">HE_CORE_TRACE</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">Application::OnWindowClose</span><span class="params">(WindowCloseEvent &amp;e)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		m_Running = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>EventDispatcher</code>用于根据事件类型的不同，调用不同的函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当收到Event时，创建对应的EventDispatcher</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">HENGINE_API</span> EventDispatcher </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">		<span class="keyword">using</span> EventHandler = std::function&lt;<span class="built_in">bool</span>(T&amp;)&gt;;<span class="comment">//存储了一个输入为任意类型，返回值为bool的函数指针</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">EventDispatcher</span>(Event&amp; event):</span><br><span class="line">			<span class="built_in">m_Event</span>(event)&#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// T指的是事件类型, 如果输入的类型没有GetStaticType会报错</span></span><br><span class="line">		<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">		<span class="type">void</span> <span class="title">Dispatch</span><span class="params">(EventHandler&lt;T&gt; handler)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (m_Event.m_Handled)</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (m_Event.<span class="built_in">GetEventType</span>() == T::<span class="built_in">GetStaticType</span>()) </span><br><span class="line">			&#123;</span><br><span class="line">				m_Event.m_Handled = <span class="built_in">handler</span>(*(T*)&amp;m_Event); <span class="comment">//使用(T*)把m_Event转换成输入事件的指针类型</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Event&amp; m_Event;<span class="comment">//必须是引用，不可以是Event的实例，因为Event带有纯虚函数</span></span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>遇到的问题:</strong></p>
<p>编译时报错显示error C2338: Cannot format argument,初步判定是跟spdlog有关，经过排查发现问题出在这里</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void Application::<span class="built_in">OnEvent</span>(Event&amp; e)</span><br><span class="line">&#123;</span><br><span class="line"> EventDispatcher <span class="built_in">dispatcher</span>(e);</span><br><span class="line"> dispatcher<span class="selector-class">.Dispatch</span>&lt;WindowCloseEvent&gt;(BIND_EVENT_FN(OnWindowClose));</span><br><span class="line"></span><br><span class="line"> <span class="built_in">HE_CORE_TRACE</span>(&quot;&#123;<span class="number">0</span>&#125;&quot;, e); ××××××</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是spdlog无法识别Event这个类型，需要我们自定义一个关于Event的模版,在Log.h最上方加入以下代码即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> FMT_VERSION &gt;= 90000</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Events/Event.h&quot;</span></span></span><br><span class="line"> <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct</span> <span class="title class_">fmt</span>::formatter&lt;HEngine::Event&gt; : ostream_formatter &#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="八、-设计游戏的层级框架"><a href="#八、-设计游戏的层级框架" class="headerlink" title="八、  设计游戏的层级框架"></a>八、  设计游戏的层级框架</h2><p>设计完Window和Event之后，需要创建Layer类</p>
<ul>
<li><p>Layer的理解</p>
<p>想象同Ps中一张图有多个层级，每个层级都可以绘制不同的画面，最后合在一起展现出图片最终的样子</p>
</li>
<li><p>Layer的设计</p>
<ul>
<li><p>数据结构：vector</p>
</li>
<li><p>渲染顺序</p>
<p><strong>从前往后</strong>渲染各个层的图像，这样后面渲染的会覆盖前面渲染的图像，在屏幕的最顶层。</p>
</li>
<li><p>处理事件顺序</p>
<p><strong>从后往前</strong>依次处理事件，当一个事件被一个层处理完不会传递给前一个层，结合渲染顺序，这样在屏幕最顶层的（也就是在vector最后的layer）图像<strong>最先</strong>处理事件。</p>
</li>
<li><p>例子解释</p>
<p>比如常见的3D游戏有UI。</p>
<p>渲染顺序：将3D图形先渲染，再渲染2DUI，这样屏幕上2DUI永远在3D图形上方，显示正确；</p>
<p>事件顺序：点击屏幕的图形，应该是2DUI最先处理，如果是相应UI事件，处理完后<strong>不传递</strong>给前一个3D层，若不是自己的UI事件，<strong>才传递</strong>给前一个3D层。</p>
</li>
</ul>
</li>
</ul>
<p><strong>项目相关</strong>：</p>
<p>Layer接口设计如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Layer</span>(<span class="type">const</span> std::string&amp; name = <span class="string">&quot;Layer&quot;</span>);</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Layer</span>();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnAttach</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 应用添加此层执行</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDetach</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 应用分离此层执行</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 每层更新</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnEvent</span><span class="params">(Event&amp; event)</span> </span>&#123;&#125;<span class="comment">// 每层处理事件</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> std::string&amp; <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_DebugName; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string m_DebugName;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>LayerStack.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> LayerStack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">LayerStack</span>();</span><br><span class="line">	~<span class="built_in">LayerStack</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PushLayer</span><span class="params">(Layer* layer)</span></span>;	<span class="comment">// vector在头部添加一个层</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PushOverlay</span><span class="params">(Layer* overlay)</span></span>;<span class="comment">// 在vector末尾添加一个覆盖层，在屏幕的最上方的层</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PopLayer</span><span class="params">(Layer* layer)</span></span>;	<span class="comment">// vector弹出指定层</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PopOverlay</span><span class="params">(Layer* overlay)</span></span>;<span class="comment">// vector弹出覆盖层</span></span><br><span class="line">	std::vector&lt;Layer*&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    std::vector&lt;Layer*&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Layers.<span class="built_in">end</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::vector&lt;Layer*&gt;stack;</span><br><span class="line">	std::vector&lt;Layer*&gt;::iterator curStackItr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Application.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::PushLayer</span><span class="params">(Layer* layer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	m_LayerStack.<span class="built_in">PushLayer</span>(layer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::PushOverlay</span><span class="params">(Layer* layer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	m_LayerStack.<span class="built_in">PushOverlay</span>(layer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::OnEvent</span><span class="params">(Event&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">// 从后往前顺序处理事件</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">auto</span> it = m_LayerStack.<span class="built_in">end</span>(); it != m_LayerStack.<span class="built_in">begin</span>();)</span><br><span class="line">     &#123;</span><br><span class="line">       (*--it)-&gt;<span class="built_in">OnEvent</span>(e);</span><br><span class="line">       <span class="keyword">if</span> (e.Handled)	<span class="comment">// 截取后发现是此层的事件，就不传入前一个层</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">glClearColor</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">   <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// 从前往后顺序更新层</span></span><br><span class="line">   <span class="keyword">for</span> (Layer* layer : m_LayerStack)</span><br><span class="line">     layer-&gt;<span class="built_in">OnUpdate</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SandboxApp.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleLayer</span> : <span class="keyword">public</span> HEngine::Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ExampleLayer</span>()</span><br><span class="line">		: <span class="built_in">Layer</span>(<span class="string">&quot;Example&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">HE_INFO</span>(<span class="string">&quot;ExampleLayer::Update&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OnEvent</span><span class="params">(HEngine::Event&amp; event)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">HE_TRACE</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, event);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sandbox</span> : <span class="keyword">public</span> HEngine::Application</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Sandbox</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">PushLayer</span>(<span class="keyword">new</span> <span class="built_in">ExampleLayer</span>());</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="九、-添加GLAD"><a href="#九、-添加GLAD" class="headerlink" title="九、  添加GLAD"></a>九、  添加GLAD</h2><p>为了使用OpenGL，而OpenGL的函数定义在显卡中，大多数函数的定义位置都无法在编译时确定下来，所以需要在运行时查询，需要使用GLAD库在运行时获取OpenGL函数地址并将其保存在函数指针中供程序运行时使用。</p>
<p>可以使用glew，也可以使用glad库，二者的在效率上好像没啥区别，不过glad的库要更新一些，所以这里用glad库，具体步骤：</p>
<ul>
<li><p>上网站<a target="_blank" rel="noopener" href="https://glad.dav1d.de/上下载对应版本的header和src文件，放在vendor文件夹下">https://glad.dav1d.de/上下载对应版本的header和src文件，放在vendor文件夹下</a></p>
</li>
<li><p>网站上下载的glad库没有premake5文件，所以按照glfw库的方式为其写一个，与glfw库相同，这里的glad库也是作为lib文件使用</p>
</li>
<li><p>把glad库的premake5文件相关内容整合到整个工程的premake5文件里</p>
</li>
</ul>
<hr>
<h2 id="十、-ImGui层"><a href="#十、-ImGui层" class="headerlink" title="十、  ImGui层"></a>十、  ImGui层</h2><p>Dear ImGui主要用于程序员的图形Debug工具(类似于Unity的ImGUI)，如果没有ImGUI，要调整好一个参数，要反复在代码里面修改数值，然后编译运行项目查看效果，这样很麻烦，而通过ImGui，就可以实现直接在图形界面调试参数的功能。</p>
<h4 id="怎么使用ImGui的代码"><a href="#怎么使用ImGui的代码" class="headerlink" title="怎么使用ImGui的代码"></a>怎么使用ImGui的代码</h4><p>ImGui的网址<a target="_blank" rel="noopener" href="https://github.com/ocornut/imgui">https://github.com/ocornut/imgui</a>, 需要添加Premake，所以Fork到我的仓库再添加子模块</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add submodule https:<span class="comment">//github.com/donghuiw/imgui HEngine/vendor/imgui</span></span><br></pre></td></tr></table></figure>
<p>ImGui的代码仓库里给了两种代码：</p>
<ul>
<li>一种是源代码，HEngine需要引用这部分代码，作为库文件，类似于引用GLFW和Glad库文件项目一样</li>
<li>一种是使用ImGui的源代码的examples代码，就是教你怎么调用的</li>
</ul>
<p>对于第一种代码，为其生成一个premake5.lua文件，然后为其生成一个Project即可</p>
<p>具体怎么在HEngine里用，就需要参考ImGui的例子代码了，由于我们用的是glfw库加上OpenGL3的版本，所以要参考的两个cpp文件为：<code>imgui_impl_opengl3.cpp</code>和<code>imgui_impl_glfw.cpp</code></p>
<p>接下来在Platform文件夹下，创建OpenGL文件夹：</p>
<ul>
<li>把<code>imgui_impl_opengl3</code>的头文件和源文件放进去，更名为<code>ImGuiOpenGLRenderer</code>，用来存放ImGui调用OpenGL的代码。</li>
<li>而原本用到的<code>imgui_impl_glfw</code>相关内容，就直接Copy和Paste到ImGuiLayer里。</li>
</ul>
<h4 id="创建ImGUILayer"><a href="#创建ImGUILayer" class="headerlink" title="创建ImGUILayer"></a>创建ImGUILayer</h4><p>ImGui可以帮助程序员进行Debug，基于上述的Layer系统，把ImGui也作为一个Layer，为其创建对应的<code>ImGuiLayer.cpp</code>和相关头文件。</p>
<p>ImGuiLayer.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line"> 	<span class="keyword">class</span> <span class="title class_">HENGINE_API</span> ImGuiLayer : <span class="keyword">public</span> Layer</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">ImGuiLayer</span>();</span><br><span class="line">		~<span class="built_in">ImGuiLayer</span>();</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnAttach</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//当layer添加到layer stack的时候会调用此函数</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnDettach</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">//当layer从layer stack移除的时候会调用此函数</span></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnEvent</span><span class="params">(Event&amp;)</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ImGuiLayer.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;imgui.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Platform/OpenGL//ImGuiOpenGLRenderer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	ImGuiLayer::<span class="built_in">ImGuiLayer</span>()</span><br><span class="line">		:<span class="built_in">Layer</span>(<span class="string">&quot;ImGuiLayer&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ImGuiLayer::~<span class="built_in">ImGuiLayer</span>()</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnAttach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">        <span class="comment">//这部分直接复制example_glfw_opengl3的文件里的main函数</span></span><br><span class="line">		ImGui::<span class="built_in">CreateContext</span>();</span><br><span class="line">		ImGui::<span class="built_in">StyleColorsDark</span>();</span><br><span class="line"></span><br><span class="line">		ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">		io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;</span><br><span class="line">		io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;</span><br><span class="line"></span><br><span class="line">		io.KeyMap[ImGuiKey_Tab] = GLFW_KEY_TAB;</span><br><span class="line">		io.KeyMap[ImGuiKey_LeftArrow] = GLFW_KEY_LEFT;</span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="built_in">ImGui_ImplOpenGL3_Init</span>(<span class="string">&quot;#version 410&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnDetach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnEvent</span><span class="params">(Event &amp;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnUpdate</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这里也是参照ImGui给的Example写Update的函数，主要做了以下功能</span></span><br><span class="line">        <span class="comment">// 1. 创建Frame然后进行Render</span></span><br><span class="line">        <span class="comment">// 2. 根据窗口大小，动态给ImGui设置窗口展示大小</span></span><br><span class="line">        <span class="comment">// 3. 设置DeltaTime</span></span><br><span class="line">        ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">        Application&amp; app = Application::<span class="built_in">Get</span>();</span><br><span class="line">        io.DisplaySize = <span class="built_in">ImVec2</span>(app.<span class="built_in">GetWindow</span>().<span class="built_in">GetWindowWidth</span>(), app.<span class="built_in">GetWindow</span>().<span class="built_in">GetWindowHeight</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> time = (<span class="type">float</span>)<span class="built_in">glfwGetTime</span>();</span><br><span class="line">        io.DeltaTime = m_Time &gt; <span class="number">0.0f</span> ? (time - m_Time) : (<span class="number">1.0f</span> / <span class="number">60.0f</span>);</span><br><span class="line">        m_Time = time;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_NewFrame</span>();</span><br><span class="line">        ImGui::<span class="built_in">NewFrame</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">static</span> <span class="type">bool</span> show = <span class="literal">true</span>;</span><br><span class="line">        ImGui::<span class="built_in">ShowDemoWindow</span>(&amp;show);</span><br><span class="line"></span><br><span class="line">        ImGui::<span class="built_in">Render</span>();</span><br><span class="line">        <span class="built_in">ImGui_ImplOpenGL3_RenderDrawData</span>(ImGui::<span class="built_in">GetDrawData</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在SandboxApp.cpp添加这一层就可以了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SandBox</span> : <span class="keyword">public</span> HEngine::Application</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">SandBox</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">PushLayer</span>(<span class="keyword">new</span> <span class="built_in">ExampleLayer</span>());</span><br><span class="line">		<span class="built_in">PushOverlay</span>(<span class="keyword">new</span> HEngine::<span class="built_in">ImGuiLayer</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="十一、-给ImGui添加事件"><a href="#十一、-给ImGui添加事件" class="headerlink" title="十一、 给ImGui添加事件"></a>十一、 给ImGui添加事件</h2><ul>
<li><p>此节目的</p>
<p>为了让显示在屏幕上ImGui的UI能接收GLFW窗口事件。</p>
</li>
</ul>
<h4 id="如何写ImGui的事件"><a href="#如何写ImGui的事件" class="headerlink" title="如何写ImGui的事件"></a>如何写ImGui的事件</h4><ul>
<li><p>搞清楚原理</p>
<p>ImGui的事件是来自GLFW窗口的事件</p>
<p>（GLFW<strong>提供</strong>了函数来捕捉窗口事件，并回调自定义的函数-&gt;我们已经实现在回调自定义函数中传递给Application再传给Layer层，在Layer层中进行捕获和处理事件）</p>
</li>
<li><p>参考ImGui的imgui_impl_glfw.cpp</p>
<p>这个cpp里写了imgui实现处理glfw事件的<strong>回调处理事件函数</strong></p>
<p>所以参考imgui_impl_glfw.cpp对应的<strong>回调处理事件函数</strong>重写为ImGuiLayer层自己的回调处理函数函数</p>
</li>
</ul>
<h4 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h4><p><strong>代码</strong></p>
<ul>
<li><p>Event增加接收字符事件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> KeyTypedEvent : <span class="keyword">public</span> KeyEvent<span class="comment">// 增加接收字符事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KeyTypedEvent</span>(<span class="type">int</span> keycode)</span><br><span class="line">        : <span class="built_in">KeyEvent</span>(keycode) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::stringstream ss;</span><br><span class="line">        ss &lt;&lt; <span class="string">&quot;KeyTypedEvent: &quot;</span> &lt;&lt; m_KeyCode; <span class="comment">// 输出在窗口</span></span><br><span class="line">        <span class="keyword">return</span> ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EVENT_CLASS_TYPE</span>(KeyTyped)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WindowsWindow.cpp增加接收字符窗口事件并回调给Application</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入字符事件</span></span><br><span class="line"><span class="built_in">glfwSetCharCallback</span>(m_Window, [](GLFWwindow* window, <span class="type">unsigned</span> <span class="type">int</span> keycode)&#123;</span><br><span class="line">    WindowData&amp; data = *(WindowData*)<span class="built_in">glfwGetWindowUserPointer</span>(window);</span><br><span class="line"></span><br><span class="line">    KeyTypedEvent <span class="built_in">event</span>(keycode);</span><br><span class="line">    data.<span class="built_in">EventCallback</span>(event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Application把事件传给ImGuiLayer层</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 从Application的Event传递过来的事件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ImGuiLayer::OnEvent</span><span class="params">(Event&amp; event)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 参考imgui_impl_glfw.cpp对应的回调处理事件函数重写为ImGuiLayer层自己的回调处理函数函数</span></span><br><span class="line">    <span class="comment">// 和之前不同的一点是：ImGui拦截了事件并处理后，不标记为处理过了，而是return false标记为没处理，将其传递给前一个层</span></span><br><span class="line">        <span class="function">EventDispatcher <span class="title">dispatcher</span><span class="params">(event)</span></span>;</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;MouseButtonPressedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnMouseButtonPressedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;MouseButtonReleasedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnMouseButtonReleasedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;MouseMovedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnMouseMovedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;MouseScrolledEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnMouseScrolledEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;KeyPressedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnKeyPressedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;KeyReleasedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnKeyReleasedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;KeyTypedEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnKeyTypedEvent));</span><br><span class="line">        dispatcher.<span class="built_in">Dispatch</span>&lt;WindowResizeEvent&gt;(<span class="built_in">HE_BIND_EVENT_FN</span>(ImGuiLayer::OnWindowResizeEvent));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ImGuiLayer::OnMouseButtonPressedEvent</span><span class="params">(MouseButtonPressedEvent&amp; e)</span></span>&#123;</span><br><span class="line">        ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">        io.MouseDown[e.<span class="built_in">GetMouseButton</span>()] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 不标记为处理过了，而是没处理，将其传递给前一个层</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">ImGuiLayer::OnKeyReleasedEvent</span><span class="params">(KeyReleasedEvent&amp; e)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">        io.KeysDown[e.<span class="built_in">GetKeyCode</span>()] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">ImGuiLayer::OnKeyPressedEvent</span><span class="params">(KeyPressedEvent&amp; e)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		ImGuiIO&amp; io = ImGui::<span class="built_in">GetIO</span>();</span><br><span class="line">		io.KeysDown[e.<span class="built_in">GetKeyCode</span>()] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		io.KeyCtrl = io.KeysDown[GLFW_KEY_LEFT_CONTROL] || io.KeysDown[GLFW_KEY_RIGHT_CONTROL];</span><br><span class="line">		io.KeyShift = io.KeysDown[GLFW_KEY_LEFT_SHIFT] || io.KeysDown[GLFW_KEY_RIGHT_SHIFT];</span><br><span class="line">		io.KeyAlt = io.KeysDown[GLFW_KEY_LEFT_ALT] || io.KeysDown[GLFW_KEY_RIGHT_ALT];</span><br><span class="line">		io.KeySuper = io.KeysDown[GLFW_KEY_LEFT_SUPER] || io.KeysDown[GLFW_KEY_RIGHT_SUPER];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="十二、-输入事件轮询"><a href="#十二、-输入事件轮询" class="headerlink" title="十二、 输入事件轮询"></a>十二、 输入事件轮询</h2><p><strong>Input接口类设计</strong><br>现在要为引擎添加新的功能，我们的应用需要能够知道键盘的输入状态，比如Unity里按住W和鼠标右键就可以实现摄像机的推进，所以引擎需要能够知道键盘的W键是否被按下</p>
<p>思路是通过GLFW<strong>已经提供的输入事件检测函数</strong>来检测输入事件，创建一个Input接口类，这个类根据不同平台生成对应的的Input子类，比如Windows平台下有<code>class WindowsInput : public Input</code>，Input类的接口需要判断某个键的状态、鼠标点击状态等</p>
<p>由于一个系统不会存在两个同样的键，也不会有两个鼠标，所以把这些函数都设计为Static函数，用单例模式，单例暴露的接口是static函数，而实现的具体方法是单例的虚函数</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><ul>
<li><p>Input.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Input&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">bool</span> <span class="title">IsKeyPressed</span><span class="params">(<span class="type">int</span> keycode)</span> </span>&#123; <span class="keyword">return</span> s_Instance-&gt;<span class="built_in">IsKeyPressedImpl</span>(keycode); &#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">bool</span> <span class="title">IsMouseButtonPressed</span><span class="params">(<span class="type">int</span> button)</span> </span>&#123; <span class="keyword">return</span> s_Instance-&gt;<span class="built_in">IsMouseButtonPressedImpl</span>(button); &#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">static</span> std::pair&lt;<span class="type">float</span>, <span class="type">float</span>&gt; <span class="title">GetMousePosition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_Instance-&gt;<span class="built_in">GetMousePositionImpl</span>(); &#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">float</span> <span class="title">GetMouseX</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_Instance-&gt;<span class="built_in">GetMouseXImpl</span>(); &#125;</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">float</span> <span class="title">GetMouseY</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_Instance-&gt;<span class="built_in">GetMouseYImpl</span>(); &#125;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsKeyPressedImpl</span><span class="params">(<span class="type">int</span> keycode)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsMouseButtonPressedImpl</span><span class="params">(<span class="type">int</span> button)</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> std::pair&lt;<span class="type">float</span>, <span class="type">float</span>&gt; <span class="title">GetMousePositionImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetMouseXImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetMouseYImpl</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">static</span> Input* s_Instance;	<span class="comment">// 声明静态单例全局对象</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WindowsInput</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">WindowsInput</span> : <span class="keyword">public</span> Input&#123;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsKeyPressedImpl</span><span class="params">(<span class="type">int</span> keycode)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsMouseButtonPressedImpl</span><span class="params">(<span class="type">int</span> button)</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> std::pair&lt;<span class="type">float</span>, <span class="type">float</span>&gt; <span class="title">GetMousePositionImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetMouseXImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetMouseYImpl</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line">	Input* Input::s_Instance = <span class="keyword">new</span> <span class="built_in">WindowsInput</span>();	<span class="comment">// 定义静态单例全局对象</span></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">WindowsInput::IsKeyPressedImpl</span><span class="params">(<span class="type">int</span> keycode)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 获取GLFW原生窗口void*，转为GLFWwindow*</span></span><br><span class="line">		<span class="keyword">auto</span> window = <span class="built_in">static_cast</span>&lt;GLFWwindow*&gt;(Application::<span class="built_in">Get</span>().<span class="built_in">GetWindow</span>().<span class="built_in">GetNativeWindow</span>());</span><br><span class="line">		<span class="comment">// 通过GLFW函数来获取按键状态</span></span><br><span class="line">		<span class="keyword">auto</span> state = <span class="built_in">glfwGetKey</span>(window, keycode);</span><br><span class="line">		<span class="keyword">return</span> state == GLFW_PRESS || state == GLFW_REPEAT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">WindowsInput::IsMouseButtonPressedImpl</span><span class="params">(<span class="type">int</span> button)</span></span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> window = <span class="built_in">static_cast</span>&lt;GLFWwindow*&gt;(Application::<span class="built_in">Get</span>().<span class="built_in">GetWindow</span>().<span class="built_in">GetNativeWindow</span>());</span><br><span class="line">		<span class="keyword">auto</span> state = <span class="built_in">glfwGetMouseButton</span>(window, button);</span><br><span class="line">		<span class="keyword">return</span> state == GLFW_PRESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">std::pair&lt;<span class="type">float</span>, <span class="type">float</span>&gt; <span class="title">WindowsInput::GetMousePositionImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> window = <span class="built_in">static_cast</span>&lt;GLFWwindow*&gt;(Application::<span class="built_in">Get</span>().<span class="built_in">GetWindow</span>().<span class="built_in">GetNativeWindow</span>());</span><br><span class="line">		<span class="type">double</span> xpos, ypos;</span><br><span class="line">		<span class="built_in">glfwGetCursorPos</span>(window, &amp;xpos, &amp;ypos);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> &#123; (<span class="type">float</span>)xpos, (<span class="type">float</span>)ypos &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">WindowsInput::GetMouseXImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">// C++17写法</span></span><br><span class="line">		<span class="keyword">auto</span> [x, y] = <span class="built_in">GetMousePositionImpl</span>();</span><br><span class="line">		<span class="keyword">return</span> x;</span><br><span class="line">		<span class="comment">// C++14以下</span></span><br><span class="line">		<span class="comment">//auto x = GetMousePositionImpl();</span></span><br><span class="line">		<span class="comment">//return std::get&lt;0&gt;(x);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">WindowsInput::GetMouseYImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> [x, y] = <span class="built_in">GetMousePositionImpl</span>();</span><br><span class="line">		<span class="keyword">return</span> y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul>
<li><p>Application</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m_Running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [x, y] = Input::<span class="built_in">GetMousePosition</span>();</span><br><span class="line">			<span class="built_in">HE_CORE_TRACE</span>(<span class="string">&quot;&#123;0&#125;, &#123;1&#125;&quot;</span>, x, y);</span><br><span class="line">        m_Window-&gt;<span class="built_in">OnUpdate</span>();	<span class="comment">// 更新glfw</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="十三、-添加Math库"><a href="#十三、-添加Math库" class="headerlink" title="十三、 添加Math库"></a>十三、 添加Math库</h2><p>游戏引擎里自然少不了Vector3、Matrix以及相关的计算，如果自己写Math库，也可以允许，但是运行效率会不尽如人意，因为好的Math库能够尽可能快的完成数学运算(比如通过一次CPU指令完成矩阵的运算)，这(好像)也叫做smid，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/1.webp" alt="1"></p>
<p>为了保证效率和跨平台的能力，这里使用glm库作为引擎的数学库，glm不只是OpenGL的数学库，也可以单独抽出来使用。老样子添加到子模块，然后修改prmake，就不重复阐述了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https:<span class="comment">//github.com/g-truc/glm HEngine/vendor/glm</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="十四、-ImGui停靠功能"><a href="#十四、-ImGui停靠功能" class="headerlink" title="十四、 ImGui停靠功能"></a>十四、 ImGui停靠功能</h2><p>游戏引擎，比如Unity、UE5里的窗口都是可以拖拽和停靠(Docking)的，这是编辑器最基本的功能，可以直接用ImGui来完成，之前使用submodule的时候，都是引用该Project，然后把该submodule的源文件放进来，然而这里由于imgui里的源文件很多是我们不需要的，所以这里把其中的重要文件放到了ImGuiBuild.cpp里，直接当作头文件include进来，源码就不加在project的source列表里了</p>
<p>所以需要做以下事情：</p>
<ul>
<li>清除之前在ImGuiLayer.cpp里粘贴的ImGuiOpengl3Renderer和ImGuiGlfw3的相关内容，然后建立一个ImGuiBuild.cpp，把相关文件include进来(类似UnityBuild的做法)</li>
</ul>
<p><strong>设计思路</strong><br>之前的ImGuiLayer是在SandboxApp.cpp里加入的，而实际上ImGui应该是游戏引擎自带的东西，不应该是由用户定义添加到LayerStack里，所以需要为Application提供固有的ImGuiLayer成员，可以用宏括起来，Release游戏的时候，就不用这个东西，设计思路如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HENGINE_API</span> Application</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">           <span class="function"><span class="type">bool</span> <span class="title">OnWindowClose</span><span class="params">(WindowCloseEvent&amp; e)</span></span>;</span><br><span class="line"></span><br><span class="line">           std::unique_ptr&lt;Window&gt; m_Window;</span><br><span class="line">           ImGuiLayer* m_ImGuiLayer;	<span class="comment">//添加ImGuiLayer</span></span><br><span class="line">           <span class="type">bool</span> m_Running = <span class="literal">true</span>;</span><br><span class="line">           LayerStack m_LayerStack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了让每一个Layer都有一个ImGuiLayer，让每一个Layer都继承一个接口，用于绘制ImGui的内容，同时让ImGuiLayer成为HEngine内在的部分，需要在Application里面加上对应的LayerStack，与其内部的Layer一一对应，设计思路如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Layer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Layer</span> (<span class="type">const</span> std::string&amp; name = <span class="string">&quot;Layer&quot;</span>);</span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">Layer</span> ();</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnAttach</span><span class="params">()</span> </span>&#123;&#125;; </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDettach</span><span class="params">()</span> </span>&#123;&#125;; </span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnEvent</span><span class="params">(Event&amp;)</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnUpdate</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> </span>&#123;&#125;;	<span class="comment">//新增函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在Application里，先调用Layer的正常函数，再调用其ImGuiRender函数，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (m_Running)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (Layer* layer : m_LayerStack)</span><br><span class="line">	&#123;</span><br><span class="line">		layer-&gt;<span class="built_in">OnUpdate</span>();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	****</span><br><span class="line">	m_ImGuiLayer-&gt;<span class="built_in">Begin</span>();	</span><br><span class="line">	<span class="keyword">for</span> (Layer* layer : m_LayerStack)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 每一个Layer都在调用ImGuiRender函数</span></span><br><span class="line">		layer-&gt;<span class="built_in">OnImGuiRender</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	m_ImGuiLayer-&gt;<span class="built_in">End</span>();</span><br><span class="line">	****</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><p>在完成上述功能后，就可以把ImGui对应的窗口任意拖拽了，但为了在SandboxApp展示的窗口，也就是原始的Windows的粉色窗口上绘制对应的内容，需要在ExampleLayer里的OnImGuiRender里进行绘制，代码如下所示：</p>
<p><strong>Sandbox.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">&quot;imgui.h&quot;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">Text</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而运行后，会报错，如下所示：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SandboxApp.obj : <span class="built_in">error</span> LNK2019: unresolved <span class="keyword">external</span> symbol </span><br></pre></td></tr></table></figure>
<p>大概意思就是，Linker找不到Begin、Text和End函数的定义，这是为什么呢？</p>
<p>这是因为HEngine引擎做成了dll，从外部可以调用的类和函数都是用HENGINE_API定义的，而ImGUI的内容是作为lib文件链接到HEngine.dll里的，ImGUI的相关API并没有声明为dllexport，到了Sandbox这里当然是找不到的</p>
<p>所以需要对IMGUI进行处理，使IMGUI的工程里是dllexport，直接修改他的premake5.lua文件</p>
<p>定义IMGUI_API这个宏为__declspec(dllimport)，就可以了。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defines </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;IMGUI_API=__declspec(dllexport)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="十五、-HEngine改为静态库"><a href="#十五、-HEngine改为静态库" class="headerlink" title="十五、 HEngine改为静态库"></a>十五、 HEngine改为静态库</h2><ul>
<li><p>dll</p>
<ul>
<li>优点<ul>
<li>热更新，更改引擎代码后只需重新编译dll，让多个测试项目不用重新编译能使用最新引擎代码</li>
<li>让客户端的链接更容易</li>
</ul>
</li>
<li>缺点<ul>
<li>dll很多警告</li>
<li>exe动态链接dll启动速度慢</li>
</ul>
</li>
</ul>
</li>
<li><p>lib</p>
<p>所有链接都构建到exe文件中</p>
</li>
</ul>
<p>需要考虑dll的优点在使用引擎的角度，引擎代码已经完成了就不需要热更新了，dll的热更新优点没有了</p>
<h4 id="如何将引擎从dll改为lib"><a href="#如何将引擎从dll改为lib" class="headerlink" title="如何将引擎从dll改为lib"></a>如何将引擎从dll改为lib</h4><p>这里是用premake构建的工程，直接在premake5.lua文件里进行修改HEngine工程的类型就可以了。</p>
<p>原来的HEngine的premake部分内容如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project <span class="string">&quot;HEngine&quot;</span></span><br><span class="line">    location <span class="string">&quot;%&#123;prj.name&#125;&quot;</span> <span class="comment">-- 这里的location是生成的vcproj的位置</span></span><br><span class="line">    kind <span class="string">&quot;SharedLib&quot;</span><span class="comment">-- 类型为dll</span></span><br><span class="line">    staticruntime <span class="string">&quot;on&quot;</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>修改之后变为：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project <span class="string">&quot;HEngine&quot;</span></span><br><span class="line">    location <span class="string">&quot;%&#123;prj.name&#125;&quot;</span> <span class="comment">-- 这里的location是生成的vcproj的位置</span></span><br><span class="line">    kind <span class="string">&quot;StaticLib&quot;</span><span class="comment">-- 类型为.lib</span></span><br><span class="line">    staticruntime <span class="string">&quot;off&quot;</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>同时，把之前的dllexport和dllimport的宏注释掉就行了，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> HE_DYNAMIC_LINK</span></span><br><span class="line">	<span class="meta">#<span class="keyword">ifdef</span> HE_BUILD_DLL</span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> HENGINE_API __declspec(dllexport)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="meta">#<span class="keyword">define</span> HENGINE_API __declspec(dllimport)</span></span><br><span class="line">	<span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="meta">#<span class="keyword">define</span> HENGINE_API <span class="comment">//现在为空</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><a id="16"></a></p>
<hr>
<h2 id="十六、-渲染前准备工作"><a href="#十六、-渲染前准备工作" class="headerlink" title="十六、 渲染前准备工作"></a>十六、 渲染前准备工作</h2><p>这里开始我们就要开始激动人心的渲染部分啦，我们选择使用OpenGL来开始工作，因为它是较为简单和容易的图形库。我们用抽象类封装渲染图形API的Context，后面可以根据不同渲染API，设置不同渲染的上下文。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><ul>
<li><p>GraphicsContext.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">GraphicsContext</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SwapBuffers</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OpenGLContext.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HEngine/Renderer/GraphicsContext.h&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">GLFWwindow</span>;</span><br><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">OpenGLContext</span> : <span class="keyword">public</span> GraphicsContext&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">OpenGLContext</span>(GLFWwindow* windowHandle);</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SwapBuffers</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		GLFWwindow* m_WindowHandle;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OpenGLContext.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;OpenGLContext.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	OpenGLContext::<span class="built_in">OpenGLContext</span>(GLFWwindow* windowHandle)</span><br><span class="line">		: <span class="built_in">m_WindowHandle</span>(windowHandle)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">HE_CORE_ASSERT</span>(windowHandle, <span class="string">&quot;Window handle is numm!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLContext::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="built_in">glfwMakeContextCurrent</span>(m_WindowHandle);	<span class="comment">// 设置当前线程的主上下文</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取显卡OpenGL函数定义的地址</span></span><br><span class="line">        <span class="type">int</span> status = <span class="built_in">gladLoadGLLoader</span>((GLADloadproc)glfwGetProcAddress);</span><br><span class="line">        <span class="built_in">HE_CORE_ASSERT</span>(status, <span class="string">&quot;Failed to initialize Glad!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OpenGLContext::SwapBuffers</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">glfwSwapBuffers</span>(m_WindowHandle);	<span class="comment">// 交换缓冲</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WindowsWindow.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowsWindow</span> : <span class="keyword">public</span> Window&#123;</span><br><span class="line">    .....</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		GLFWwindow* m_Window;</span><br><span class="line">		GraphicsContext* m_Context;</span><br><span class="line">    .....</span><br></pre></td></tr></table></figure>
</li>
<li><p>WindowsWindow.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WindowsWindow::Init</span><span class="params">(<span class="type">const</span> WindowProps&amp; props)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    m_Window = <span class="built_in">glfwCreateWindow</span>((<span class="type">int</span>)props.Width, (<span class="type">int</span>)props.Height, m_Data.Title.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    m_Context = <span class="keyword">new</span> <span class="built_in">OpenGLContext</span>(m_Window); <span class="comment">// 创建渲染上下文对象</span></span><br><span class="line">    m_Context-&gt;<span class="built_in">Init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glfwSetWindowUserPointer</span>(m_Window, &amp;m_Data);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="十七、-渲染第一个三角形"><a href="#十七、-渲染第一个三角形" class="headerlink" title="十七、 渲染第一个三角形!"></a>十七、 渲染第一个三角形!</h2><ul>
<li><p>此节介绍</p>
<p>在屏幕上用OpenGL的函数成功显示一个三角形，以及显示显卡信息。</p>
</li>
<li><p>此次渲染三角形，是直接调用OpenGL图形API，并没有抽象类来封装这些API，先了解有哪些API，后面再慢慢封装成一个个抽象类，关于OpenGL学习，视频我看的是YouTube上<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=W3gAzLwfIP0&amp;list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2">Cherno</a>的，访问不了外网的话网站推荐<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/">OpenGL中文网</a>，建议学习过之后再看以下代码</p>
</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><ul>
<li><p>Application</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line">....</span><br><span class="line">Application::<span class="built_in">Application</span>()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 顶点数据</span></span><br><span class="line">    <span class="type">float</span> vertices[<span class="number">3</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> indices[<span class="number">3</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">// 索引数据</span></span><br><span class="line">    <span class="comment">// 0.生成顶点数组对象VAO、顶点缓冲对象VBO、索引缓冲对象EBO</span></span><br><span class="line">    <span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_VertexArray);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_VertexBuffer);</span><br><span class="line">    <span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;m_IndexBuffer);</span><br><span class="line">    <span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">    <span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br><span class="line">    <span class="comment">// 2. 把我们的CPU的顶点数据复制到GPU顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_VertexBuffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="built_in">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 复制我们的CPU的索引数据到GPU索引缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_IndexBuffer);</span><br><span class="line">    <span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="built_in">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 4. 设定顶点属性指针，来解释顶点缓冲中的顶点属性布局</span></span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);<span class="comment">// 开启glsl的layout = 0输入</span></span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">while</span> (m_Running)&#123;</span><br><span class="line">        <span class="built_in">glClearColor</span>(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.绑定顶点数组对象，并开始绘制，默认使用一个白色的着色器</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br><span class="line">        <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/4.webp" alt="4"></p>
<p><strong>OpenGLContext</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLContext::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打印当前exe使用的显卡信息</span></span><br><span class="line">    <span class="built_in">HE_CORE_INFO</span>(<span class="string">&quot;OpenGL Info:&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HE_CORE_INFO</span>(<span class="string">&quot;  Vendor: &#123;0&#125;&quot;</span>, (<span class="type">const</span> <span class="type">char</span>*)<span class="built_in">glGetString</span>(GL_VENDOR));</span><br><span class="line">    <span class="built_in">HE_CORE_INFO</span>(<span class="string">&quot;  Renderer: &#123;0&#125;&quot;</span>, (<span class="type">const</span> <span class="type">char</span>*)<span class="built_in">glGetString</span>(GL_RENDERER));</span><br><span class="line">    <span class="built_in">HE_CORE_INFO</span>(<span class="string">&quot;  Version: &#123;0&#125;&quot;</span>, (<span class="type">const</span> <span class="type">char</span>*)<span class="built_in">glGetString</span>(GL_VERSION));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Renderging负责在屏幕上的绘制工作，同时接受与外部Input的交互，为了表现更好的画面效果，需要使用Graphics Processing Unit（GPU），GPU的主要优点是：能并行处理、能很快的进行数学运算</p>
<p>对于一些电脑，可能这里不会默认使用独显，比如N卡可以在NVDIA ControlPanel里选择这个exe使用高性能的GPU处理器，如下图所示</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/3.webp" alt="3"></p>
<hr>
<h2 id="十八、-添加着色器"><a href="#十八、-添加着色器" class="headerlink" title="十八、 添加着色器"></a>十八、 添加着色器</h2><ul>
<li><p>此节目的</p>
<p>使用shader，让渲染的三角形有颜色，并且将关于shader的代码抽象到Shader类中</p>
</li>
<li><p>关于Shader</p>
<ul>
<li>告诉GPU如何处理我们从CPU发送到GPU的顶点数据</li>
<li>着色器(Shader)是运行在GPU上的小程序，分别对应渲染管理不同阶段。</li>
<li>着色器是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。</li>
</ul>
</li>
<li><p>官网介绍<a target="_blank" rel="noopener" href="https://www.khronos.org/opengl/wiki/Shader_Compilation">https://www.khronos.org/opengl/wiki/Shader_Compilation</a></p>
</li>
</ul>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><ul>
<li><p>增加Shader类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc);</span><br><span class="line">		~<span class="built_in">Shader</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">uint32_t</span> m_RendererID;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Shader.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line">	Shader::<span class="built_in">Shader</span>(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 1.1 创建顶点着色器对象</span></span><br><span class="line">		GLuint vertexShader = <span class="built_in">glCreateShader</span>(GL_VERTEX_SHADER);</span><br><span class="line">		<span class="comment">// 1.2 附加顶点着色器源码到顶点着色器对象中</span></span><br><span class="line">		<span class="type">const</span> GLchar* source = vertexSrc.<span class="built_in">c_str</span>();</span><br><span class="line">		<span class="built_in">glShaderSource</span>(vertexShader, <span class="number">1</span>, &amp;source, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">glCompileShader</span>(vertexShader);	<span class="comment">// 1.3 编译顶点着色器对象</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 1.4 检查是否编译成功</span></span><br><span class="line">		GLint isCompiled = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">glGetShaderiv</span>(vertexShader, GL_COMPILE_STATUS, &amp;isCompiled);</span><br><span class="line">		<span class="keyword">if</span> (isCompiled == GL_FALSE)</span><br><span class="line">		&#123;</span><br><span class="line">			GLint maxLength = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">glGetShaderiv</span>(vertexShader, GL_INFO_LOG_LENGTH, &amp;maxLength);</span><br><span class="line">			<span class="comment">// The maxLength includes the NULL character</span></span><br><span class="line">			<span class="function">std::vector&lt;GLchar&gt; <span class="title">infoLog</span><span class="params">(maxLength)</span></span>;</span><br><span class="line">			<span class="built_in">glGetShaderInfoLog</span>(vertexShader, maxLength, &amp;maxLength, &amp;infoLog[<span class="number">0</span>]);</span><br><span class="line">			<span class="comment">// We don&#x27;t need the shader anymore.</span></span><br><span class="line">			<span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">			<span class="comment">// Use the infoLog as you see fit.</span></span><br><span class="line">			<span class="built_in">HE_CORE_ERROR</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, infoLog.<span class="built_in">data</span>());</span><br><span class="line">			<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Vertex shader compilation failure!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 片段着色器大部分和上面一样</span></span><br><span class="line">		GLuint fragmentShader = <span class="built_in">glCreateShader</span>(GL_FRAGMENT_SHADER);</span><br><span class="line">		source = fragmentSrc.<span class="built_in">c_str</span>();</span><br><span class="line">		<span class="built_in">glShaderSource</span>(fragmentShader, <span class="number">1</span>, &amp;source, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">glCompileShader</span>(fragmentShader);</span><br><span class="line">		<span class="built_in">glGetShaderiv</span>(fragmentShader, GL_COMPILE_STATUS, &amp;isCompiled);</span><br><span class="line">		<span class="comment">//判断是否编译成功和上面一样，换个参数的事，就不写上来了</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 3.1创建着色器程序对象</span></span><br><span class="line">		m_RendererID = <span class="built_in">glCreateProgram</span>();</span><br><span class="line">		GLuint program = m_RendererID;</span><br><span class="line">		<span class="comment">// 3.2附加着色器对象给着色器程序对象</span></span><br><span class="line">		<span class="built_in">glAttachShader</span>(program, vertexShader);</span><br><span class="line">		<span class="built_in">glAttachShader</span>(program, fragmentShader);</span><br><span class="line">		<span class="comment">// 3.3链接着色器程序对象</span></span><br><span class="line">		<span class="built_in">glLinkProgram</span>(program);</span><br><span class="line">		<span class="comment">// 3.4可以检查链接是否成功</span></span><br><span class="line">		GLint isLinked = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">glGetProgramiv</span>(program, GL_LINK_STATUS, (<span class="type">int</span>*)&amp;isLinked);</span><br><span class="line">		<span class="keyword">if</span> (isLinked == GL_FALSE)</span><br><span class="line">		&#123;</span><br><span class="line">			GLint maxLength = <span class="number">0</span>;</span><br><span class="line">			<span class="built_in">glGetProgramiv</span>(program, GL_INFO_LOG_LENGTH, &amp;maxLength);</span><br><span class="line">			<span class="function">std::vector&lt;GLchar&gt; <span class="title">infoLog</span><span class="params">(maxLength)</span></span>;</span><br><span class="line">			<span class="built_in">glGetProgramInfoLog</span>(program, maxLength, &amp;maxLength, &amp;infoLog[<span class="number">0</span>]);</span><br><span class="line">			<span class="built_in">glDeleteProgram</span>(program);</span><br><span class="line">			<span class="built_in">glDeleteShader</span>(vertexShader);</span><br><span class="line">			<span class="built_in">glDeleteShader</span>(fragmentShader);</span><br><span class="line">			<span class="built_in">HE_CORE_ERROR</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, infoLog.<span class="built_in">data</span>());</span><br><span class="line">			<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Shader compilation failure!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 4.删除着色器对象</span></span><br><span class="line">		<span class="built_in">glDetachShader</span>(program, vertexShader);</span><br><span class="line">		<span class="built_in">glDetachShader</span>(program, fragmentShader);</span><br><span class="line">	&#125;</span><br><span class="line">	Shader::~<span class="built_in">Shader</span>()&#123;</span><br><span class="line">		<span class="built_in">glDeleteProgram</span>(m_RendererID);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Shader::Bind</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="built_in">glUseProgram</span>(m_RendererID);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Shader::Unbind</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">		<span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Application.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Application::<span class="built_in">Application</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 着色器代码</span></span><br><span class="line">    std::string vertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">			#version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string">			out vec3 v_Position;</span></span><br><span class="line"><span class="string">			void main()</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				v_Position = a_Position;</span></span><br><span class="line"><span class="string">				gl_Position = vec4(a_Position, 1.0);	</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		)&quot;</span>;</span><br><span class="line">    std::string fragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">			#version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string">			in vec3 v_Position;</span></span><br><span class="line"><span class="string">			void main()</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				color = vec4(v_Position * 0.5 + 0.5, 1.0);</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		)&quot;</span>;</span><br><span class="line">    m_Shader.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Shader</span>(vertexSrc, fragmentSrc));</span><br><span class="line">	<span class="comment">// 在头文件的std::unique_ptr&lt;Shader&gt; m_Shader;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m_Running)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 绑定着色器</span></span><br><span class="line">        m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        <span class="comment">// 绑定顶点数组对象，并绘制</span></span><br><span class="line">        <span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br><span class="line">        <span class="built_in">glDrawElements</span>(GL_TRIANGLES, <span class="number">3</span>, GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>解释</p>
<ul>
<li><p>片段着色器</p>
<p>color = vec4(v_Position * 0.5 + 0.5, 1.0);</p>
<p>三个顶点颜色被确定，其围成的区域片段的颜色将会根据三个顶点颜色线性插值</p>
</li>
<li><p>着色器源码字符串书写方式 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的-不美观</span></span><br><span class="line">string s = <span class="string">&quot;#version 450 core\n&quot;</span></span><br><span class="line"><span class="string">&quot;asf\n&quot;</span></span><br><span class="line"><span class="string">&quot;adf\n&quot;</span></span><br><span class="line"><span class="comment">// 用R&quot;()&quot;包围</span></span><br><span class="line">string s = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">	#version 450 core</span></span><br><span class="line"><span class="string">	....</span></span><br><span class="line"><span class="string">)&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/5.webp" alt="5"></p>
<hr>
<h2 id="十九、-封装Buffer类"><a href="#十九、-封装Buffer类" class="headerlink" title="十九、 封装Buffer类"></a>十九、 封装Buffer类</h2><ul>
<li><p>此节目的</p>
<p>对于OpenGL的生成<strong>顶点缓冲</strong>、<strong>索引缓冲</strong>这种原始代码抽象成类。</p>
</li>
<li><p>如何设计类</p>
<p>从想使用的API形式出发，先想像我要使用的API接口是什么样，写出调用，然后再去根据这个去写接口</p>
</li>
<li><p>渲染接口的设计</p>
<p>由于可以有多个渲染图形API：OpenGL、DX，若引擎支持两种渲染图形API，需要设计选择哪一个</p>
<ul>
<li><p>如果是在<strong>编译时</strong>确定选择</p>
<p>缺点：如果更改渲染对象，需要重新编译引擎、且运行时不能切换</p>
</li>
<li><p>如果是在<strong>运行时</strong>确定选择</p>
<p>缺点：编译时两个渲染相关obj都要编译</p>
<p>优点：能动态切换</p>
<p>如何实现：采用C++的动态特性，基类指针指向子类对象实现<strong>动态多态</strong></p>
</li>
</ul>
<p>如：VertexBuffer有静态Create函数，返回VertexBuffer<em>，根据选择<em>*不同渲染图形API</em></em>调用return new OpenGLVertexBuffer还是DirectxVertexBuffer</p>
</li>
</ul>
<h4 id="代码修改"><a href="#代码修改" class="headerlink" title="代码修改"></a>代码修改</h4><ul>
<li><p>Renderer</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">enum class</span> <span class="title class_">RendererAPI</span></span><br><span class="line">	&#123;</span><br><span class="line">		None = <span class="number">0</span>, OpenGL = <span class="number">1</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Renderer</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">static</span> RendererAPI <span class="title">GetAPI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_RendererAPI; &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">static</span> RendererAPI s_RendererAPI;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Renderer.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hepch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Renderer.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	RendererAPI Renderer::s_RendererAPI = RendererAPI::OpenGL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加VertexBuffer与IndexBuffer类同放在Buffer文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">VertexBuffer</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">VertexBuffer</span>() &#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="type">static</span> VertexBuffer* <span class="title">Create</span><span class="params">(<span class="type">float</span>* vertices, <span class="type">uint32_t</span> size)</span></span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">IndexBuffer</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">IndexBuffer</span>() &#123;&#125;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">uint32_t</span> <span class="title">GetCount</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="type">static</span> IndexBuffer* <span class="title">Create</span><span class="params">(<span class="type">uint32_t</span>* indices, <span class="type">uint32_t</span> size)</span></span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<p>Buffer.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">VertexBuffer* <span class="title">VertexBuffer::Create</span><span class="params">(<span class="type">float</span>* vertices, <span class="type">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> RendererAPI::None:			 <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI::None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">case</span> RendererAPI::OpenGL:		 <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenGLVertexBuffer</span>(vertices, size);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown RendererAPI!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">IndexBuffer* <span class="title">IndexBuffer::Create</span><span class="params">(<span class="type">uint32_t</span>* indices, <span class="type">uint32_t</span> size)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> RendererAPI::None:				<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI::None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">case</span> RendererAPI::OpenGL:			<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenGLIndexBuffer</span>(indices, size);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown RendererAPI!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OpenGLBuffer.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">OpenGLVertexBuffer</span> : <span class="keyword">public</span> VertexBuffer</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">OpenGLVertexBuffer</span>(<span class="type">float</span>* vertices, <span class="type">uint32_t</span> size);</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">OpenGLVertexBuffer</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">uint32_t</span> m_RendererID;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">OpenGLIndexBuffer</span> : <span class="keyword">public</span> IndexBuffer</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">OpenGLIndexBuffer</span>(<span class="type">uint32_t</span>* indices, <span class="type">uint32_t</span> size);</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">OpenGLIndexBuffer</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">uint32_t</span> <span class="title">GetCount</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Count;  &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">uint32_t</span> m_RendererID;</span><br><span class="line">		<span class="type">uint32_t</span> m_Count;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OpenGLBuffer.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line">	<span class="comment">// VertexBuffer /</span></span><br><span class="line">	OpenGLVertexBuffer::<span class="built_in">OpenGLVertexBuffer</span>(<span class="type">float</span>* vertices, <span class="type">uint32_t</span> size)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="comment">// 1.创建顶点缓冲对象</span></span><br><span class="line">		<span class="built_in">glCreateBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">		<span class="comment">// 2.绑定顶点缓冲对象</span></span><br><span class="line">		<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">		<span class="comment">// 3. 把我们的CPU的顶点数据复制到GPU顶点缓冲中，供OpenGL使用</span></span><br><span class="line">		<span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, size, vertices, GL_STATIC_DRAW);</span><br><span class="line">	&#125;</span><br><span class="line">	OpenGLVertexBuffer::~<span class="built_in">OpenGLVertexBuffer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLVertexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLVertexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// IndexBuffer //</span></span><br><span class="line">	OpenGLIndexBuffer::<span class="built_in">OpenGLIndexBuffer</span>(<span class="type">uint32_t</span>* indices, <span class="type">uint32_t</span> count)</span><br><span class="line">		: <span class="built_in">m_Count</span>(count)</span><br><span class="line">    &#123;		</span><br><span class="line">		<span class="comment">// 1.创建顶点缓冲对象</span></span><br><span class="line">		<span class="built_in">glCreateBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">		<span class="comment">// 2.绑定顶点缓冲对象</span></span><br><span class="line">		<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">		<span class="comment">// 3. 复制我们的CPU的索引数据到GPU索引缓冲中，供OpenGL使用</span></span><br><span class="line">		<span class="built_in">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, count * <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>), indices, GL_STATIC_DRAW);</span><br><span class="line">	&#125;</span><br><span class="line">	OpenGLIndexBuffer::~<span class="built_in">OpenGLIndexBuffer</span>()</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="built_in">glDeleteBuffers</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLIndexBuffer::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, m_RendererID);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLIndexBuffer::Unbind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="built_in">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Application.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> m_VertexArray;</span><br><span class="line"></span><br><span class="line">	std::unique_ptr&lt;VertexBuffer&gt; m_VertexBuffer;</span><br><span class="line">	std::unique_ptr&lt;IndexBuffer&gt; m_IndexBuffer;</span><br></pre></td></tr></table></figure>
<p>Application.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="type">float</span> vertices[<span class="number">3</span> * <span class="number">3</span>] = &#123;</span><br><span class="line">  <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">  <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">  <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> indices[<span class="number">3</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;; </span><br><span class="line"></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_VertexArray);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br><span class="line"><span class="comment">/* 删除</span></span><br><span class="line"><span class="comment">glGenBuffers(1, &amp;m_VertexBuffer);</span></span><br><span class="line"><span class="comment">glBindBuffer(GL_ARRAY_BUFFER, m_VertexBuffer);</span></span><br><span class="line"><span class="comment">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">m_VertexBuffer.<span class="built_in">reset</span>(VertexBuffer::<span class="built_in">Create</span>(vertices, <span class="built_in">sizeof</span>(vertices)));	<span class="comment">//换成</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glEnableVertexAttribArray</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="literal">nullptr</span>);</span><br><span class="line">.....</span><br><span class="line">m_IndexBuffer.<span class="built_in">reset</span>(IndexBuffer::<span class="built_in">Create</span>(indices, <span class="built_in">sizeof</span>(indices) <span class="comment">//换成</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="二十、-设计顶点缓冲区布局"><a href="#二十、-设计顶点缓冲区布局" class="headerlink" title="二十、 设计顶点缓冲区布局"></a>二十、 设计顶点缓冲区布局</h2><p>此节目的，抽象<strong>顶点缓冲布局</strong>类：给出对应顶点着色器输入一样的格式，使能够<strong>自动</strong>计算每个属性的偏移量、分量大小，总大小，而不用手动计算</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><p>Buffer.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shdader数据类型</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">ShaderDataType</span>&#123;</span><br><span class="line">    None = <span class="number">0</span>, Float, Float2, Float3, Float4, Mat3, Mat4, Int, Int2, Int3, Int4, Bool</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 获取Shader数据类型的大小</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title">ShaderDataTypeSize</span><span class="params">(ShaderDataType type)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type)&#123;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Float:    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Float2:   <span class="keyword">return</span> <span class="number">4</span> * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Float3:   <span class="keyword">return</span> <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Float4:   <span class="keyword">return</span> <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Mat3:     <span class="keyword">return</span> <span class="number">4</span> * <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Mat4:     <span class="keyword">return</span> <span class="number">4</span> * <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Int:      <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Int2:     <span class="keyword">return</span> <span class="number">4</span> * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Int3:     <span class="keyword">return</span> <span class="number">4</span> * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Int4:     <span class="keyword">return</span> <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> ShaderDataType::Bool:     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown ShaderDataType!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Shader属性类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BufferElement</span>&#123; 	</span><br><span class="line">    std::string Name;	</span><br><span class="line">    ShaderDataType Type;</span><br><span class="line">    <span class="type">uint32_t</span> Size;		</span><br><span class="line">    <span class="type">uint32_t</span> Offset;	</span><br><span class="line">    <span class="type">bool</span> Normalized;	</span><br><span class="line">    <span class="built_in">BufferElement</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">BufferElement</span>(ShaderDataType type, <span class="type">const</span> std::string&amp; name, <span class="type">bool</span> normalized = <span class="literal">false</span>)</span><br><span class="line">        : <span class="built_in">Name</span>(name), <span class="built_in">Type</span>(type), <span class="built_in">Size</span>(<span class="built_in">ShaderDataTypeSize</span>(type)), <span class="built_in">Offset</span>(<span class="number">0</span>), <span class="built_in">Normalized</span>(normalized)</span><br><span class="line">        &#123; &#125;</span><br><span class="line">    <span class="comment">// 获取此属性有几个分量</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">GetComponentCount</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (Type) &#123;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Float:   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Float2:  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Float3:  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Float4:  <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Mat3:    <span class="keyword">return</span> <span class="number">3</span> * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Mat4:    <span class="keyword">return</span> <span class="number">4</span> * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Int:     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Int2:    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Int3:    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Int4:    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">case</span> ShaderDataType::Bool:    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown ShaderDataType!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 顶点缓冲布局抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BufferLayout</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BufferLayout</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">// 用初始化列表构造BufferLayout对象</span></span><br><span class="line">    <span class="built_in">BufferLayout</span>(<span class="type">const</span> std::initializer_list&lt;BufferElement&gt;&amp; elements)</span><br><span class="line">        : <span class="built_in">m_Elements</span>(elements)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">CalculateOffsetsAndStride</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">GetStride</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Stride; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> std::vector&lt;BufferElement&gt;&amp; <span class="title">GetElements</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Elements; &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;BufferElement&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Elements.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    std::vector&lt;BufferElement&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_Elements.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    std::vector&lt;BufferElement&gt;::<span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Elements.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    std::vector&lt;BufferElement&gt;::<span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Elements.<span class="built_in">end</span>(); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 计算属性列表各个属性的偏移量,跨步长</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CalculateOffsetsAndStride</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">uint32_t</span> offset = <span class="number">0</span>;</span><br><span class="line">        m_Stride = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; element : m_Elements)&#123;</span><br><span class="line">            element.Offset = offset;</span><br><span class="line">            offset += element.Size;</span><br><span class="line">            m_Stride += element.Size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;BufferElement&gt; m_Elements;</span><br><span class="line">    <span class="type">uint32_t</span> m_Stride = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>OpenGLBuffer.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> BufferLayout&amp; <span class="title">GetLayout</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> m_Layout;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetLayout</span><span class="params">(<span class="type">const</span> BufferLayout&amp; layout)</span> <span class="keyword">override</span> </span>&#123; m_Layout = layout; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	BufferLayout m_Layout;</span><br></pre></td></tr></table></figure>
<p>Application.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> GLenum <span class="title">ShaderDataTypeToOpenGLBaseType</span><span class="params">(ShaderDataType type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Float:			<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Float2:			<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Float3:			<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Float4:			<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Mat3:				<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Mat4:				<span class="keyword">return</span> GL_FLOAT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Int:			    <span class="keyword">return</span> GL_INT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Int2:				<span class="keyword">return</span> GL_INT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Int3:				<span class="keyword">return</span> GL_INT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Int4:				<span class="keyword">return</span> GL_INT;</span><br><span class="line">        <span class="keyword">case</span> HEngine::ShaderDataType::Bool:				<span class="keyword">return</span> GL_BOOL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknow ShaderDataType!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*删除</span></span><br><span class="line"><span class="comment">float vertices[3 * 3] = &#123;</span></span><br><span class="line"><span class="comment">    -0.5f, -0.5f, 0.0f,</span></span><br><span class="line"><span class="comment">     0.5f, -0.5f, 0.0f,</span></span><br><span class="line"><span class="comment">     0.0f,  0.5f, 0.0f</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">float</span> vertices[<span class="number">3</span> * <span class="number">7</span>] = &#123;	<span class="comment">//加上颜色数据</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">/*删除</span></span><br><span class="line"><span class="comment">glEnableVertexAttribArray(0);</span></span><br><span class="line"><span class="comment">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), nullptr);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#123;</span><br><span class="line">    BufferLayout layout = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123; ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;,</span><br><span class="line">        &#123; ShaderDataType::Float4, <span class="string">&quot;a_Color&quot;</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    m_VertexBuffer-&gt;<span class="built_in">SetLayout</span>(layout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; layout = m_VertexBuffer-&gt;<span class="built_in">GetLayout</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : layout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">glEnableVertexAttribArray</span>(index);</span><br><span class="line">    <span class="built_in">glVertexAttribPointer</span>(index,</span><br><span class="line">        element.<span class="built_in">GetComponentCount</span>(),</span><br><span class="line">        <span class="built_in">ShaderDataTypeToOpenGLBaseType</span>(element.Type),</span><br><span class="line">        element.Normalized ? GL_TRUE : GL_FALSE,</span><br><span class="line">        layout.<span class="built_in">GetStride</span>(),</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span>*)element.Offset);</span><br><span class="line"></span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">std::string vertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string">    layout(location = 1) in vec4 a_Color;</span></span><br><span class="line"><span class="string">    out vec3 v_Position;</span></span><br><span class="line"><span class="string">    out vec4 v_Color;</span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        v_Position = a_Position;</span></span><br><span class="line"><span class="string">        v_Color = a_Color;</span></span><br><span class="line"><span class="string">        gl_Position = vec4(a_Position, 1.0);	</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">std::string fragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 450 core</span></span><br><span class="line"><span class="string">    layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string">    in vec3 v_Position;</span></span><br><span class="line"><span class="string">    in vec4 v_Color;</span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        color = vec4(v_Position * 0.5 + 0.5, 1.0);</span></span><br><span class="line"><span class="string">        color = v_Color;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>效果:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/6.webp" alt="6"></p>
<hr>
<h2 id="二十一、添加顶点数组"><a href="#二十一、添加顶点数组" class="headerlink" title="二十一、添加顶点数组"></a>二十一、添加顶点数组</h2><p>OpenGL里的VAO，其实本身不包含任何Buffer的数据，它只是记录了Vertex Buffer和IndexBuffer的引用，并且使用<code>glVertexAttribPointer</code>函数来决定VAO通过哪种方式来挖取 VBO中的数据。</p>
<p>这节目的是创建Vertex Array类，由于OpenGL有VAO这个东西，而DX里完全没有这个概念，但是前期的HEngine引擎是极大程度依赖OpenGL的，所以目前是先创建VertexArray类</p>
<p>Application.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建VertexArray，这一段还没抽象化</span></span><br><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_VertexArray);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一段已经成功抽象化了</span></span><br><span class="line">&#123;</span><br><span class="line">	BufferLayout layout = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123; ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;,</span><br><span class="line">        &#123; ShaderDataType::Float4, <span class="string">&quot;a_Color&quot;</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">    vertexBuffer-&gt;<span class="built_in">SetLayout</span>(layout);</span><br><span class="line">    m_VertexArray-&gt;<span class="built_in">AddVertexBuffer</span>(vertexBuffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BufferLayout layout = m_VertexBuffer-&gt;<span class="built_in">GetBufferLayout</span>();</span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2. 指定VAO挖数据的方法，这一段也没抽象化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> BufferElement&amp; element : layout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">glEnableVertexAttribArray</span>(index);</span><br><span class="line">	<span class="built_in">glVertexAttribPointer</span>(index,</span><br><span class="line">	<span class="built_in">GetShaderTypeDataCount</span>(element.<span class="built_in">GetType</span>()),</span><br><span class="line">	<span class="built_in">GetShaderDataTypeToOpenGL</span>(element.<span class="built_in">GetType</span>()), </span><br><span class="line">		element.<span class="built_in">IsNormalized</span>()? GL_TRUE : GL_FALSE,</span><br><span class="line">		layout.<span class="built_in">GetStride</span>(),</span><br><span class="line">		(<span class="type">const</span> <span class="type">void</span>*)(element.<span class="built_in">GetOffset</span>()));</span><br><span class="line">	index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是正式开始写代码了。</p>
<p>前面两句代码要把它抽象化，也就是把它变成跟平台无关的东西，跟之前创建的VertexBuffer和IndexBuffer都差不多</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glGenVertexArrays</span>(<span class="number">1</span>, &amp;m_VertexArray);</span><br><span class="line"><span class="built_in">glBindVertexArray</span>(m_VertexArray);</span><br></pre></td></tr></table></figure>
<p>这里单独建一个<code>VertexArray</code>的cpp和h文件，之所以单独建立cpp和h文件，是因为还不确定相关的VertexArray的内容以后还会不会会保留，毕竟DX里是没有这个概念的</p>
<p>VertexArray.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接复制VertexBuffer的相关内容就行：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VertexArray</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 这些都是跟VertexBuffer和IndexBuffer的接口一样的</span></span><br><span class="line">	<span class="keyword">virtual</span> ~<span class="built_in">VertexArray</span>() &#123;&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;<span class="comment">//Unbind函数一般用于debuging purposes</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">static</span> VertexArray* <span class="title">Create</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 由于一个VAO可以挖取多个VBO的数据，所以需要添加记录相关VBO引用的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddVertexBuffer</span><span class="params">(<span class="type">const</span> std::shared_ptr &lt; VertexBuffer&gt;&amp; vertexBuffer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetIndexBuffer</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;IndexBuffer&gt;&amp; indexBuffer)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">const</span> std::vector&lt;std::shared_ptr&lt;VertexBuffer&gt;&gt;&amp; <span class="built_in">GetVertexBuffers</span>() <span class="type">const</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::shared_ptr&lt;IndexBuffer&gt;&amp; <span class="title">GetIndexBuffer</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>VertexArray.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">VertexArray* <span class="title">VertexArray::Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> RendererAPI::None:  <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI::None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">			<span class="keyword">case</span> RendererAPI::OpenGL: <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenGLVertexArray</span>();	</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknow RendererAPI!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是创建OpenGLVertexArray的头文件和cpp文件了，放到Platform的文件夹里，实现过程跟OpenGLVertexBuffer差不多</p>
<p>OpenGLVertexArray.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLVertexArray::AddVertexBuffer</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexBuffer&gt;&amp; vertexBuffer)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">HE_CORE_ASSERT</span>(vertexBuffer-&gt;<span class="built_in">GetLayout</span>().<span class="built_in">GetElements</span>().<span class="built_in">size</span>(), <span class="string">&quot;Vertex Buffer has no layout!&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">glBindVertexArray</span>(m_RendererID);</span><br><span class="line">		vertexBuffer-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">		<span class="type">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line">		<span class="type">const</span> <span class="keyword">auto</span>&amp; layout = vertexBuffer-&gt;<span class="built_in">GetLayout</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : layout)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">glEnableVertexAttribArray</span>(index);</span><br><span class="line">			<span class="built_in">glVertexAttribPointer</span>(index,</span><br><span class="line">				element.<span class="built_in">GetComponentCount</span>(),</span><br><span class="line">				<span class="built_in">ShaderDataTypeToOpenGLBaseType</span>(element.Type),</span><br><span class="line">				element.Normalized ? GL_TRUE : GL_FALSE,</span><br><span class="line">				layout.<span class="built_in">GetStride</span>(),</span><br><span class="line">				(<span class="type">const</span> <span class="type">void</span>*)element.Offset);</span><br><span class="line"></span><br><span class="line">			index++;</span><br><span class="line">		&#125;</span><br><span class="line">		m_VertexBuffers.<span class="built_in">push_back</span>(vertexBuffer);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLVertexArray::SetIndexBuffer</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;IndexBuffer&gt;&amp; indexBuffer)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glBindVertexArray</span>(m_RendererID);</span><br><span class="line">		indexBuffer-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"></span><br><span class="line">		m_IndexBuffer = indexBuffer;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="多个VBO来验证"><a href="#多个VBO来验证" class="headerlink" title="多个VBO来验证"></a>多个VBO来验证</h4><p>做到这里其实就差不多了，但是为了验证之前做的是正确的，创建了一个应用场景，就是通过使用两个Shader，一个VAO，两个VBO，一个EBO来绘制出来</p>
<p><strong>创建第二个VertexArray</strong><br>前面画了个三角形，下面再画一个Quad，在Application类里创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;VertexArray&gt; m_QuadVertexArray;</span><br></pre></td></tr></table></figure>
<p>然后按照同样的方式，创建VAO、VBO和顶点数据，再创建一个Shader，这里做一个只输出蓝色的Shader，就可以了，最后在Loop里分别绑定VBO和Shader就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> squareVertices[<span class="number">3</span> * <span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="number">-0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.75f</span>,  <span class="number">0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line">    <span class="number">-0.75f</span>,  <span class="number">0.75f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br><span class="line">std::shared_ptr&lt;VertexBuffer&gt; squareVB;</span><br><span class="line">squareVB.<span class="built_in">reset</span>(VertexBuffer::<span class="built_in">Create</span>(squareVertices, <span class="built_in">sizeof</span>(squareVertices)));</span><br><span class="line">squareVB-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">    &#123; ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">m_SquareVA-&gt;<span class="built_in">AddVertexBuffer</span>(squareVB);</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> squareIndices[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span> &#125;;</span><br><span class="line">std::shared_ptr&lt;IndexBuffer&gt; squareIB;</span><br><span class="line">squareIB.<span class="built_in">reset</span>(IndexBuffer::<span class="built_in">Create</span>(squareIndices, <span class="built_in">sizeof</span>(squareIndices) / <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line">m_SquareVA-&gt;<span class="built_in">SetIndexBuffer</span>(squareIB);</span><br><span class="line"></span><br><span class="line">std::string blueShaderVertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out vec3 v_Position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    v_Position = a_Position;</span></span><br><span class="line"><span class="string">    gl_Position = vec4(a_Position, 1.0);	</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"></span><br><span class="line">std::string blueShaderFragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">#version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">in vec3 v_Position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">void main()</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    color = vec4(0.2, 0.3, 0.8, 1.0);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">m_BlueShader.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Shader</span>(blueShaderVertexSrc, blueShaderFragmentSrc));</span><br><span class="line"></span><br><span class="line">m_BlueShader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">m_SquareVA-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, m_SquareVA-&gt;<span class="built_in">GetIndexBuffer</span>()-&gt;<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">m_VertexArray-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, m_VertexArray-&gt;<span class="built_in">GetIndexBuffer</span>()-&gt;<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/7.webp" alt="7"></p>
<hr>
<h2 id="二十二、设计渲染器架构"><a href="#二十二、设计渲染器架构" class="headerlink" title="二十二、设计渲染器架构"></a>二十二、设计渲染器架构</h2><p>从无到有，绘制出了三角形，然后把相关的VerterBuffer、VertexArray、IndexBuffer进行了抽象化，也就是说目前Application里不会有具体的OpenGL这种平台相关的代码，只剩下里面的glDrawElements函数、glClear和glClearColor没有抽象化。</p>
<p>前面做的抽象化，比如VertexBuffer、VertexArray，这些都是渲染要用到的相关概念的类抽象，真正的跨平台 用于渲染的Renderer类还没有创建起来。</p>
<p>思考一下，<strong>一个Renderer需要干什么</strong> 它需要Render一个Geometry。Render一个Geometry需要以下内容：</p>
<ul>
<li>一个Vertex Array，包含了VertexBuffers和一个IndexBuffer</li>
<li>一个Shader</li>
<li>人物的视角，即Camera系统，本质上就是一个Projection和View矩阵</li>
<li>绘制物体的所在的世界坐标，前面的VertexBuffer里记录的是局部坐标，也就是Model(World)矩阵</li>
<li>Cube表面的材质属性，wooden或者plastic，金属度等相关属性，这个也可以属于Shader的范畴</li>
<li>环境信息：比如环境光照、比如Environment Map、Radiance Map</li>
</ul>
<p>这些信息可以分为两类：</p>
<ul>
<li>环境相关的信息：渲染不同的物体时，环境信息也一般是相同的，比如环境光照、人物的视角等</li>
<li>被渲染的物体相关的信息：不同物体的相关信息很多是不同的，比如VertexArray，也可能部分属性相同（比如材质），这些相同的内容可以在批处理里进行处理，从而优化性能</li>
</ul>
<p>总结得到，<strong>一个Renderer应该具有以下功能</strong>：</p>
<ul>
<li>设置环境相关的信息</li>
<li>接受被渲染的物体，传入它对应的数据，比如Vertex Array、引用的Material和Shader</li>
<li>渲染物体，调用DrawCall</li>
<li>批处理，为了优化性能，把相同材质的物体一起渲染等</li>
</ul>
<p>可以把Renderer每帧执行的任务分为四个步骤：</p>
<ul>
<li>BeginScene: 负责每帧渲染前的环境设置</li>
<li>Submit：收集场景数据，同时收集渲染命令，提交渲染命令到队列里</li>
<li>EndScene：对收集到的场景数据进行优化</li>
<li>Render：按照渲染队列，进行渲染</li>
</ul>
<p>具体步骤如下：<br><strong>1. BeginScene</strong><br>由于环境相关的信息是相同的，所以在Renderer开始渲染的阶段，需要先搭建相关环境，为此设计了一个Begin Scene函数。Begin Scene阶段，基本就是告诉Renderer，我要开始渲染一个场景，然后会设置其周围的环境（比如环境光照）、Camera。</p>
<p><strong>2. Submit</strong><br>这个阶段，就可以渲染每一个Mesh了，他们的Transform矩阵一般是不同的，依次传给Renderer就可以了，这里会把所有的渲染命令都commit到RenderCommandQueue里。</p>
<p><strong>3. End Scene</strong><br>应该是在这个阶段，在收集完场景数据后，做一些优化的操作，比如</p>
<ul>
<li>把使用相同的材质的物体合并到一起(Batch)</li>
<li>把在Frustum外部的物体Cull掉</li>
<li>根据位置进行排序</li>
</ul>
<p><strong>4. Render</strong><br>在把所有的东西都commit到RenderCommandQueue里后，所有的Scene相关的东西，现在Renderer都处理好了，也都拥有了该数据，就可以开始渲染了。</p>
<p>整体四个过程的代码大体如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Render Run里</span></span><br><span class="line"><span class="keyword">while</span> (m_Running)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 这个ClearColor是游戏最底层的颜色，一般不会出现在用户界面里，可能用得比较少</span></span><br><span class="line">	RenderCommand::<span class="built_in">SetClearColor</span>();<span class="comment">// 参数省略</span></span><br><span class="line">	RenderCommand::<span class="built_in">Clear</span>();</span><br><span class="line">	RenderCommand::<span class="built_in">DrawIndexed</span>();</span><br><span class="line">	</span><br><span class="line">	Renderer::<span class="built_in">BeginScene</span>();<span class="comment">// 用于设置Camera、Environment和lighting等</span></span><br><span class="line">	Renderer::<span class="built_in">Submit</span>();<span class="comment">// 提交Mesh给Renderer</span></span><br><span class="line">    Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 在多线程渲染里，可能会在这个阶段用一个另外的线程执行Render::Flush操作，需要结合Render Command Queue</span></span><br><span class="line">	Renderer::<span class="built_in">Flush</span>();</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="本节要做的实际内容"><a href="#本节要做的实际内容" class="headerlink" title="本节要做的实际内容"></a>本节要做的实际内容</h4><p>上面虽然介绍完了渲染架构，大体上是统一处理物体，然后统一渲染，但是由于目前相关的架构还没搭起来，所以这仍然是Bind一个VAO，然后调用一次DrawCall，以后会改进的。</p>
<p>目前就剩glClear、glClearColor和DrawCall的代码需要抽象化了，也就是这三句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glClearColor</span>(<span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"><span class="built_in">glDrawElements</span>(GL_TRIANGLES, m_QuadVertexArray-&gt;<span class="built_in">GetIndexBuffer</span>()-&gt;<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure>
<p>这些代码，打算把它抽象为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个ClearColor是游戏最底层的颜色，一般不会出现在用户界面里，用洋红色这种offensive的颜色比较好</span></span><br><span class="line">RenderCommand::<span class="built_in">SetClearColor</span>(glm::<span class="built_in">vec4</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>));<span class="comment">// 直接用glm里的vec4好了</span></span><br><span class="line">RenderCommand::<span class="built_in">Clear</span>();</span><br><span class="line">RenderCommand::<span class="built_in">DrawIndexed</span>();</span><br></pre></td></tr></table></figure>
<p>然后对于原本的Renderer里的GetAPI函数，它应该由RendererAPI负责, 而不是Renderer负责，这里新建RendererAPI类，除了要有标识当前使用的API类型的函数外，还需要有很多与平台无关的渲染的API，比如清空Buffer、根据Vertex Array进行调用DrawCall等函数</p>
<p>RendererAPI.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">RendererAPI</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">enum class</span> <span class="title class_">API</span></span><br><span class="line">		&#123;</span><br><span class="line">			None = <span class="number">0</span>, OpenGL = <span class="number">1</span></span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetClearColor</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DrawIndexed</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">inline</span> <span class="type">static</span> API <span class="title">GetAPI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s_API; &#125;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">static</span> API s_API;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在RendererAPI的cpp文件里进行初始化：</span></span><br><span class="line">RendererAPI::API RendererAPI::s_API = RendererAPI::API::OpenGL;</span><br></pre></td></tr></table></figure>
<p>RendererAPI是一个接口类，与平台无关，现在就可以实现OpenGL平台的OpenGLRendererAPI了，Platform文件夹下创建对应的cpp和h文件，跟之前的做法类似，不多说。</p>
<p>OpenGLRendererAPI.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::SetClearColor</span><span class="params">(<span class="type">const</span> glm::vec4&amp; color)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glClearColor</span>(color.r, color.g, color.b, color.a);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::Clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::DrawIndexed</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glDrawElements</span>(GL_TRIANGLES, vertexArray-&gt;<span class="built_in">GetIndexBuffer</span>()-&gt;<span class="built_in">GetCount</span>(), GL_UNSIGNED_INT, <span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就是<strong>实现Renderer类</strong>了，目前这个类只实现了一个GetAPIType函数，类的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 未来会接受Scene场景的相关参数，比如Camera、lighting, 保证shaders能够得到正确的环境相关的uniforms</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BeginScene</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">EndScene</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 会把VAO通过RenderCommand下的指令，传递给RenderCommandQueue</span></span><br><span class="line">	<span class="comment">// 目前偷个懒，直接调用RenderCommand::DrawIndexed()函数</span></span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">static</span> RendererAPI::API <span class="title">GetAPIType</span><span class="params">()</span>	</span>&#123; <span class="keyword">return</span> RendererAPI::<span class="built_in">GetAPIType</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后面会再去实现成员函数，现在先把类都声明好，还剩一个<strong>RenderCommand类</strong>了，同样创建一个RenderCommand.h头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RenderCommand</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 注意RenderCommand里的函数都应该是单一功能的函数，不应该有其他耦合的任何功能</span></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">DrawIndexed</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 比如这里不可以调用vertexArray-&gt;Bind()函数</span></span><br><span class="line">		s_RenderAPI-&gt;<span class="built_in">DrawIndexed</span>(vertexArray);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 同上，再实现Clear和ClearColor的static函数 </span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">static</span> RendererAPI* s_RenderAPI;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，RenderCommand类只是把RendererAPI的内容，做了一个静态的封装，这样做是为了以后把函数加入到RenderCommandQueue里做的架构设计，也是为了后面的多线程渲染做铺垫。</p>
<p>然后在Renderer的submit函数里实现下面的内容即可：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vertexArray-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(vertexArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此我们渲染框架就大致完成了，Application里已经没有OpenGL原生函数就可以完成绘制了</p>
<p>Application.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (m_Running)</span><br><span class="line">	&#123;</span><br><span class="line">        ....</span><br><span class="line">		Renderer::<span class="built_in">BeginScene</span>();</span><br><span class="line">        m_BlueShader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        Renderer::<span class="built_in">Submit</span>(m_QuadVertexArray);			</span><br><span class="line"></span><br><span class="line">        m_Shader-&gt;<span class="built_in">Bind</span>();</span><br><span class="line">        Renderer::<span class="built_in">Submit</span>(m_VertexArray);</span><br><span class="line"></span><br><span class="line">        Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二十三、正交摄像机实现"><a href="#二十三、正交摄像机实现" class="headerlink" title="二十三、正交摄像机实现"></a>二十三、正交摄像机实现</h2><p>先介绍一些Camera的概念，相机系统的代码框架(architecture)很重要，它决定了游戏引擎能否将更多的时间花在渲染上，从而提高帧数。Camera除了与渲染相关，还与玩家有着交互， 比如User Input、比如玩家移动的时候，Camera往往也需要移动，所以说，Camera既受GamePlay影响，也会被Submit到Renderer做渲染工作</p>
<p>Camera本身是一个虚拟的概念，它的本质其实就是View和Projection矩阵的设置，其属性有：</p>
<ul>
<li>相机的位置</li>
<li>相机的相关属性，比如FOV，比如Aspect Ratio</li>
<li>还有MVP三个矩阵（以下个人理解不一定对），M是与模型密切相关的，但是不同模型在同一个相机下，V和P矩阵是相同的，所以说，<strong>VP矩阵属于相机的属性</strong>。举个简单的例子，在日常生活中你去拍照，你首先会取景，然后把你想拍的东西都摆放好，这一步叫做model transformation（模型变换）。接下来你肯定会挑选一个特定的角度摆放你的摄像机，这一步就叫做view transformation（视图变换）。然后按下快门后把图片拍下来，这一步就叫做projection transformation（投影变换）。</li>
</ul>
<p>实际渲染时，默认相机都是在世界坐标系原点，朝向-z方向看的，当调整相机属性时，其实没有Camera这个实物，实际上是整个世界的物体在靠近相机，即往Camera这边平移；当我们向左移动相机的时候，，实际上我们是把所有世界的物体向右移，所以，相机的transform变化矩阵与物体的transform变化矩阵正好是互逆的。也就是说，我们可以通过记录相机的transformation矩阵，然后取逆矩阵，就可以得到对应的View矩阵了，这里只需要Position和Rotation，因为相机是没有缩放的。</p>
<p>根据投影方式的不同，分为了透视投影的Camera和正交投影的Camera，这一节先实现更简单的正交投影的Camera。</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><ul>
<li><p>OrthographicCamera.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OrthographicCamera</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OrthographicCamera</span>(<span class="type">float</span> left, <span class="type">float</span> right, <span class="type">float</span> bottom, <span class="type">float</span> top);</span><br><span class="line">    <span class="function"><span class="type">const</span> glm::vec3&amp; <span class="title">GetPosition</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Position; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetPosition</span><span class="params">(<span class="type">const</span> glm::vec3&amp; position)</span> </span>&#123; m_Position = position; <span class="built_in">RecalculateViewMatrix</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">GetRotation</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Rotation; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetRotation</span><span class="params">(<span class="type">float</span> rotation)</span> </span>&#123; m_Rotation = rotation; <span class="built_in">RecalculateViewMatrix</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> glm::mat4&amp; <span class="title">GetProjectionMatrix</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_ProjectionMatrix; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> glm::mat4&amp; <span class="title">GetViewMatrix</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_ViewMatrix; &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> glm::mat4&amp; <span class="title">GetViewProjectionMatrix</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_ViewProjectionMatrix; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">RecalculateViewMatrix</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    glm::mat4 m_ProjectionMatrix;</span><br><span class="line">    glm::mat4 m_ViewMatrix;</span><br><span class="line">    glm::mat4 m_ViewProjectionMatrix;</span><br><span class="line">    glm::vec3 m_Position = &#123; <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span> &#125;;<span class="comment">// 位置</span></span><br><span class="line">    <span class="type">float</span> m_Rotation = <span class="number">0.0f</span>;					<span class="comment">// 绕z轴的旋转角度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>OrthographicCamera.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化用glm计算正交投影矩阵</span></span><br><span class="line">OrthographicCamera::<span class="built_in">OrthographicCamera</span>(<span class="type">float</span> left, <span class="type">float</span> right, <span class="type">float</span> bottom, <span class="type">float</span> top)</span><br><span class="line">    : <span class="built_in">m_ProjectionMatrix</span>(glm::<span class="built_in">ortho</span>(left, right, bottom, top, <span class="number">-1.0f</span>, <span class="number">1.0f</span>)), <span class="built_in">m_ViewMatrix</span>(<span class="number">1.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 投影观察矩阵计算</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OrthographicCamera::RecalculateViewMatrix</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 观察矩阵</span></span><br><span class="line">    glm::mat4 transform = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), m_Position) *</span><br><span class="line">        glm::<span class="built_in">rotate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">radians</span>(m_Rotation), glm::<span class="built_in">vec3</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    m_ViewMatrix = glm::<span class="built_in">inverse</span>(transform);</span><br><span class="line">    m_ViewProjectionMatrix = m_ProjectionMatrix * m_ViewMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Renderer.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Renderer</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">BeginScene</span><span class="params">(OrthographicCamera&amp; camera)</span></span>;	</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Shader&gt;&amp; shader, <span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">SceneData</span> &#123;</span><br><span class="line">        glm::mat4 ViewProjectionMatrix;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> SceneData* m_SceneData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Renderer.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Renderer::SceneData* Renderer::m_SceneData = <span class="keyword">new</span> Renderer::SceneData;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::BeginScene</span><span class="params">(OrthographicCamera&amp; camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_SceneData-&gt;ViewProjectionMatrix = camera.<span class="built_in">GetViewProjectionMatrix</span>(); <span class="comment">// 保存计算的Projection * view矩阵</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Shader&gt;&amp; shader, <span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shader-&gt;<span class="built_in">Bind</span>();			<span class="comment">// 着色器绑定</span></span><br><span class="line">    shader-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_ViewProjection&quot;</span>, m_SceneData-&gt;ViewProjectionMatrix);<span class="comment">// 上传投影观察矩阵</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Shader.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shader::UploadUniformMat4</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::mat4&amp; matrix)</span></span>&#123;</span><br><span class="line">    GLint location = <span class="built_in">glGetUniformLocation</span>(m_RendererID, name.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="built_in">glUniformMatrix4fv</span>(location, <span class="number">1</span>, GL_FALSE, glm::<span class="built_in">value_ptr</span>(matrix));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Application</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OrthographiCamera m_Camera;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Application::<span class="built_in">Application</span>() : <span class="built_in">m_Camera</span>(<span class="number">-1.6f</span>, <span class="number">1.6f</span>, <span class="number">-0.9f</span>, <span class="number">0.9f</span>)</span><br><span class="line">&#123;</span><br><span class="line">    std::string vertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">			#version 450 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string">			layout(location = 1) in vec4 a_Color;</span></span><br><span class="line"><span class="string">			uniform mat4 u_ViewProjection;		//新增</span></span><br><span class="line"><span class="string">			out vec3 v_Position;</span></span><br><span class="line"><span class="string">			out vec4 v_Color;</span></span><br><span class="line"><span class="string">			void main()</span></span><br><span class="line"><span class="string">			&#123;</span></span><br><span class="line"><span class="string">				v_Position = a_Position;</span></span><br><span class="line"><span class="string">				v_Color = a_Color;</span></span><br><span class="line"><span class="string">				gl_Position = u_ViewProjection * vec4(a_Position, 1.0);	//新增</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (m_Running)&#123;</span><br><span class="line"></span><br><span class="line">        m_Camera.<span class="built_in">SetPosition</span>(&#123; <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span> &#125;);  <span class="comment">//新增</span></span><br><span class="line">        m_Camera.<span class="built_in">SetRotation</span>(<span class="number">45.0f</span>);	<span class="comment">//新增</span></span><br><span class="line"></span><br><span class="line">        Renderer::<span class="built_in">BeginScene</span>(m_Camera);</span><br><span class="line"></span><br><span class="line">        Renderer::<span class="built_in">Submit</span>(m_BlueShader, m_SquareVA);</span><br><span class="line">        Renderer::<span class="built_in">Submit</span>(m_Shader, m_VertexArray);</span><br><span class="line"></span><br><span class="line">        Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="遇到的问题-1"><a href="#遇到的问题-1" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ul>
<li><p>正方形变成长方形</p>
<p>窗口是1280 * 720，当glm::ortho(-1.0f,1.0f, -1.0f, 1.0f, -1.0f, 1.0f);时候，本来正方形的蓝色quad变为长方形</p>
</li>
<li><p>修复变回正方形</p>
<p>在1280<em>720下，left right需传入1280/720=1.7左右，将宽放大，从而<strong>左右视角变大</strong>，物体围成的宽范围<em>*缩小</em></em>，从而变回正方形。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Application::<span class="built_in">Application</span>()</span><br><span class="line">    :<span class="built_in">m_Camera</span>(<span class="number">-1.6f</span>, <span class="number">1.6f</span>, <span class="number">-0.9f</span>, <span class="number">0.9f</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="GLM库函数相关"><a href="#GLM库函数相关" class="headerlink" title="GLM库函数相关"></a>GLM库函数相关</h4><ul>
<li><p>glm::ortho（left,right, bottom, top, -1.0f, 1.0f）;</p>
<p>left = -1.0f；right = 1.0f；bottom = -1.0f；top = 1.0f</p>
<p>得到的矩阵是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span>  <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span>  <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span>  <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>glm::<strong>translate</strong>(glm::mat4(1.0f), m_Position);</p>
<p>m_Position= {0.5f, 0.5f, 0.5f};</p>
<p>glm::mat4(1.0f)，是4x4的单位矩阵</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>glm::translate(glm::mat4(1.0f), m_Position);</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    glm::translate函数中</span></span><br><span class="line"><span class="comment">    mat&lt;4, 4, T, Q&gt; Result(m); </span></span><br><span class="line"><span class="comment">    Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];</span></span><br><span class="line"><span class="comment">    Result[3]是第4行，m[0]是第1行，m[1]是第2行，m[2]是第3行。。。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">1</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0.5</span></span><br><span class="line"><span class="number">0</span> 	<span class="number">1</span> 	<span class="number">0</span> 	<span class="number">0.5</span></span><br><span class="line"><span class="number">0</span> 	<span class="number">0</span> 	<span class="number">1</span> 	<span class="number">0.5</span></span><br><span class="line"><span class="number">0</span> 	<span class="number">0</span> 	<span class="number">0</span> 	<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="二十四、添加Timestep系统"><a href="#二十四、添加Timestep系统" class="headerlink" title="二十四、添加Timestep系统"></a>二十四、添加Timestep系统</h2><p>现在的HEngine游戏引擎里，一秒内调用多少次OnUpdate函数，完全是取决于CPU的(当开启VSync则取决于显示器的频率)。假如我设计一个用代码控制相机移动的功能</p>
<p>此时会出现一个问题：如果同时在不同的机器上执行这段代码，性能更好的CPU，1s内循环跑的此时越多，相机会移动的更快。不同的机器的执行效果不一样，这肯定是不行的，所以要设计<strong>TimeStep</strong>系统。</p>
<h4 id="三种不同的Timestep系统"><a href="#三种不同的Timestep系统" class="headerlink" title="三种不同的Timestep系统"></a>三种不同的Timestep系统</h4><p>一般来说，有三种Timestep系统，它们都用来帮助解决不同机器上循环执行速度不同的问题：</p>
<ul>
<li>固定delta time的Timestep系统</li>
<li>灵活delta time的Timestep系统，delta time取决于此帧用时</li>
<li>半固定delta time的Timestep系统(Semi-fixed timestep)</li>
</ul>
<h4 id="HEngine引擎里的Timestep系统"><a href="#HEngine引擎里的Timestep系统" class="headerlink" title="HEngine引擎里的Timestep系统"></a>HEngine引擎里的Timestep系统</h4><p>由于目前没有物理引擎部分，所以这里选择了上面说的第二种<strong>Timestep系统</strong>。</p>
<p>第二种<strong>Timestep</strong>系统的设计原理是：虽然不同机器执行一次Loop函数的用时不同，但只要把每一帧里的运动，跟该帧所经历的时间相乘，就能抵消因为帧率导致的数据不一致的问题。</p>
<ul>
<li><p>计算deltatime</p>
<p>HZ为60的，1/60 = 0.01666666</p>
<p>HZ为100的，1/100 = 0.01</p>
<p>由于 <code>deltaTime</code> 变小，高帧率时每帧移动距离会自动缩小，确保一致的运动。</p>
</li>
</ul>
<p>所以只需要记录每帧的DeltaTime，然后在Movement里乘以它即可，具体其实就是把之前在循环里调用的函数，比如<code>OnUpdate</code>函数，从无参函数变成带一个TimeStep参数的函数而已，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ============== Timestep.cpp =============</span></span><br><span class="line"><span class="comment">// Timestep 实际就是一个float值的wrapper</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Timestep</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Timestep</span>(<span class="type">float</span> time = <span class="number">0.0f</span>)</span><br><span class="line">		: <span class="built_in">m_Time</span>(time)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">operator</span> <span class="title">float</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Time; &#125;</span><br><span class="line">	<span class="comment">// 给float添加wrapper是方便进行秒和毫秒的转换</span></span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetSeconds</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Time; &#125;</span><br><span class="line">	<span class="function"><span class="type">float</span> <span class="title">GetMilliseconds</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_Time * <span class="number">1000.0f</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">float</span> m_Time;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ============== Application.cpp =============</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Application::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(m_Running)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">float</span> time = (<span class="type">float</span>)<span class="built_in">GetTime</span>();</span><br><span class="line">		</span><br><span class="line">		Timestep timestep = time - m_LastFrameTIme;</span><br><span class="line">		m_LastFrameTime = time; </span><br><span class="line">		</span><br><span class="line">		...</span><br><span class="line">        layer-&gt;<span class="built_in">OnUpdate</span>(timestep);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//============== Sandbox.cpp =============</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(HEngine::Timestep ts)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		HEngine::RenderCommand::<span class="built_in">SetClearColor</span>(&#123; <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">0.1f</span>, <span class="number">1</span> &#125;);</span><br><span class="line">		HEngine::RenderCommand::<span class="built_in">Clear</span>();</span><br><span class="line"></span><br><span class="line">		m_Camera.<span class="built_in">SetPosition</span>(m_CameraPosition);</span><br><span class="line">		m_Camera.<span class="built_in">SetRotation</span>(m_CameraRotation);</span><br><span class="line"></span><br><span class="line">		HEngine::Renderer::<span class="built_in">BeginScene</span>(m_Camera);</span><br><span class="line"></span><br><span class="line">		HEngine::Renderer::<span class="built_in">Submit</span>(m_BlueShader, m_SquareVA);</span><br><span class="line">		HEngine::Renderer::<span class="built_in">Submit</span>(m_Shader, m_VertexArray);</span><br><span class="line"></span><br><span class="line">		HEngine::Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="把Application-cpp里的内容移到Sandbox对应的Project"><a href="#把Application-cpp里的内容移到Sandbox对应的Project" class="headerlink" title="把Application.cpp里的内容移到Sandbox对应的Project"></a>把Application.cpp里的内容移到Sandbox对应的Project</h4><p><code>Application</code>类应该主要负责进行While循环，在里面调用各个Layer的Update函数，而<code>SandboxApp</code>类虽然继承于<code>Application</code>类，但是也只是个大致的空壳而已，它的存在是为了把new出来的ExampleLayer加入到继承来的<code>m_LayerStack</code>里，具体的绘制Quad和Triangle的的操作应该放到Sandbox对应Project的Layer里，大概是这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleLayer</span> : <span class="keyword">public</span> HEngine::Layer</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ExampleLayer</span>()</span><br><span class="line">		: <span class="built_in">Layer</span>(<span class="string">&quot;Example&quot;</span>)</span><br><span class="line">		: <span class="built_in">Layer</span>(<span class="string">&quot;Example&quot;</span>), <span class="built_in">m_Camera</span>(<span class="number">-1.6f</span>, <span class="number">1.6f</span>, <span class="number">-0.9f</span>, <span class="number">0.9f</span>), <span class="built_in">m_CameraPosition</span>(<span class="number">0.0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		m_VertexArray.<span class="built_in">reset</span>(HEngine::VertexArray::<span class="built_in">Create</span>());</span><br><span class="line">		<span class="type">float</span> vertices[<span class="number">3</span> * <span class="number">7</span>] = &#123;</span><br><span class="line">			<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>,</span><br><span class="line">			 <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>,</span><br><span class="line">			 <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span></span><br><span class="line">		&#125;;</span><br><span class="line">		std::shared_ptr&lt;HEngine::VertexBuffer&gt; vertexBuffer;</span><br><span class="line">		vertexBuffer.<span class="built_in">reset</span>(HEngine::VertexBuffer::<span class="built_in">Create</span>(vertices, <span class="built_in">sizeof</span>(vertices)));</span><br><span class="line">		HEngine::BufferLayout layout = &#123;</span><br><span class="line">			&#123; HEngine::ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;,</span><br><span class="line">			&#123; HEngine::ShaderDataType::Float4, <span class="string">&quot;a_Color&quot;</span> &#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		vertexBuffer-&gt;<span class="built_in">SetLayout</span>(layout);</span><br><span class="line">		m_VertexArray-&gt;<span class="built_in">AddVertexBuffer</span>(vertexBuffer);</span><br><span class="line"></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> indices[<span class="number">3</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">		std::shared_ptr&lt;HEngine::IndexBuffer&gt; indexBuffer;</span><br><span class="line">		indexBuffer.<span class="built_in">reset</span>(HEngine::IndexBuffer::<span class="built_in">Create</span>(indices, <span class="built_in">sizeof</span>(indices) / <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line">		m_VertexArray-&gt;<span class="built_in">SetIndexBuffer</span>(indexBuffer);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">		m_SquareVA.<span class="built_in">reset</span>(HEngine::VertexArray::<span class="built_in">Create</span>());</span><br><span class="line">		<span class="type">float</span> squareVertices[<span class="number">3</span> * <span class="number">4</span>] = &#123;</span><br><span class="line">			<span class="number">-0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line">			 <span class="number">0.75f</span>, <span class="number">-0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line">			 <span class="number">0.75f</span>,  <span class="number">0.75f</span>, <span class="number">0.0f</span>,</span><br><span class="line">			<span class="number">-0.75f</span>,  <span class="number">0.75f</span>, <span class="number">0.0f</span></span><br><span class="line">		&#125;;</span><br><span class="line">		std::shared_ptr&lt;HEngine::VertexBuffer&gt; squareVB;</span><br><span class="line">		squareVB.<span class="built_in">reset</span>(HEngine::VertexBuffer::<span class="built_in">Create</span>(squareVertices, <span class="built_in">sizeof</span>(squareVertices)));</span><br><span class="line">		squareVB-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">			&#123; HEngine::ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;</span><br><span class="line">			&#125;);</span><br><span class="line">		m_SquareVA-&gt;<span class="built_in">AddVertexBuffer</span>(squareVB);</span><br><span class="line"></span><br><span class="line">		<span class="type">uint32_t</span> squareIndices[<span class="number">6</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span> &#125;;</span><br><span class="line">		std::shared_ptr&lt;HEngine::IndexBuffer&gt; squareIB;</span><br><span class="line">		squareIB.<span class="built_in">reset</span>(HEngine::IndexBuffer::<span class="built_in">Create</span>(squareIndices, <span class="built_in">sizeof</span>(squareIndices) / <span class="built_in">sizeof</span>(<span class="type">uint32_t</span>)));</span><br><span class="line">		m_SquareVA-&gt;<span class="built_in">SetIndexBuffer</span>(squareIB);</span><br><span class="line"></span><br><span class="line">		std::string vertexSrc = ...;</span><br><span class="line">		std::string fragmentSrc = ...;</span><br><span class="line">		m_Shader.<span class="built_in">reset</span>(<span class="keyword">new</span> HEngine::<span class="built_in">Shader</span>(vertexSrc, fragmentSrc));</span><br><span class="line"></span><br><span class="line">		std::string blueShaderVertexSrc = ...;</span><br><span class="line">		std::string blueShaderFragmentSrc = ...;</span><br><span class="line">		m_BlueShader.<span class="built_in">reset</span>(<span class="keyword">new</span> HEngine::<span class="built_in">Shader</span>(blueShaderVertexSrc, blueShaderFragmentSrc));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二十五、矩阵位置、旋转、缩放"><a href="#二十五、矩阵位置、旋转、缩放" class="headerlink" title="二十五、矩阵位置、旋转、缩放"></a>二十五、矩阵位置、旋转、缩放</h2><p>目前的Transform都是World坐标系的Transform，没有层级父子关系，本质就是globalPosition，globalRotation和globalScale，可以组成一个矩阵来表示。这里做的很简单，甚至都没有单独创建一个Transform类，就是用矩阵代表Model矩阵，作为uniform传给Shader而已，很简单，这里重点修改的函数是<code>Submit</code>函数，原本的函数如下：</p>
<p>Renderer.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Shader&gt;&amp; shader, <span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; va)</span></span></span><br></pre></td></tr></table></figure>
<p>现在要修改成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在渲染Vertex Array的时候, 添加对应model的transform对应的矩阵信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Shader&gt;&amp; shader, <span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray, <span class="type">const</span> glm::mat4&amp; transform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shader-&gt;<span class="built_in">Bind</span>();           </span><br><span class="line">	shader-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_ViewProjection&quot;</span>, s_SceneData-&gt;ViewProjectionMatrix);</span><br><span class="line">	shader-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_Transform&quot;</span>, transform);</span><br><span class="line"></span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(va);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后Sandbox.cpp中修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnUpdate</span><span class="params">(HEngine::Timestep ts)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_LEFT))</span><br><span class="line">        m_CameraPosition.x -= m_CameraMoveSpeed * ts;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_RIGHT))</span><br><span class="line">        m_CameraPosition.x += m_CameraMoveSpeed * ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_UP))</span><br><span class="line">        m_CameraPosition.y += m_CameraMoveSpeed * ts;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_DOWN))</span><br><span class="line">        m_CameraPosition.y -= m_CameraMoveSpeed * ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_A))</span><br><span class="line">        m_CameraRotation += m_CameraRotationSpeed * ts;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (HEngine::Input::<span class="built_in">IsKeyPressed</span>(HE_KEY_D))</span><br><span class="line">        m_CameraRotation -= m_CameraRotationSpeed * ts;</span><br><span class="line"></span><br><span class="line">    m_Camera.<span class="built_in">SetPosition</span>(m_CameraPosition);</span><br><span class="line">    m_Camera.<span class="built_in">SetRotation</span>(m_CameraRotation);</span><br><span class="line"></span><br><span class="line">    HEngine::Renderer::<span class="built_in">BeginScene</span>(m_Camera);</span><br><span class="line"></span><br><span class="line">    glm::mat4 scale = glm::<span class="built_in">scale</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), glm::<span class="built_in">vec3</span>(<span class="number">0.1f</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt; <span class="number">20</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; <span class="number">20</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">glm::vec3 <span class="title">pos</span><span class="params">(x * <span class="number">0.11f</span>, y * <span class="number">0.11f</span>, <span class="number">0.0f</span>)</span></span>;</span><br><span class="line">            glm::mat4 transform = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>), pos) * scale;</span><br><span class="line">            HEngine::Renderer::<span class="built_in">Submit</span>(m_BlueShader, m_SquareVA, transform);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    HEngine::Renderer::<span class="built_in">Submit</span>(m_Shader, m_VertexArray);</span><br><span class="line">    HEngine::Renderer::<span class="built_in">EndScene</span>();</span><br><span class="line">&#125;</span><br><span class="line">std::string vertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">   #version 450 core</span></span><br><span class="line"><span class="string">   layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string">   layout(location = 1) in vec4 a_Color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   uniform mat4 u_ViewProjection;</span></span><br><span class="line"><span class="string">   uniform mat4 u_Transform;	//新增</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   out vec3 v_Position;</span></span><br><span class="line"><span class="string">   out vec4 v_Color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   void main()</span></span><br><span class="line"><span class="string">   &#123;</span></span><br><span class="line"><span class="string">     v_Position = a_Position;</span></span><br><span class="line"><span class="string">     v_Color = a_Color;</span></span><br><span class="line"><span class="string">     gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0); //乘上Transform</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string"> )&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/8.webp" alt="8"></p>
<hr>
<h2 id="二十六、着色器封装"><a href="#二十六、着色器封装" class="headerlink" title="二十六、着色器封装"></a>二十六、着色器封装</h2><ul>
<li><p>此节目的</p>
<p>完成Shader的抽象，因为目前只有Shader类，应该像顶点数组、顶点缓冲一样完善Shader的抽象</p>
<p>同之前抽象的结构一样：Shader是一个抽象类，有一个静态的Create方法，返回Shader指针，在这个函数中根据不同的预定义，实例化OpenGLShader还是DxShader。</p>
</li>
</ul>
<h4 id="关键代码-1"><a href="#关键代码-1" class="headerlink" title="关键代码"></a>关键代码</h4><ul>
<li><p>动态指针强转</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(m_FlatShader)-&gt;<span class="built_in">UploadUniformFloat3</span>(<span class="string">&quot;u_Color&quot;</span>, m_SquareColor);</span><br></pre></td></tr></table></figure>
<p>因为要执行OpenGLShader（子类）<strong>独有的函数</strong>UploadUniformFloat3，而Shader（父类）里没有这个函数UploadUniformFloat3，所以需要<strong>动态指针强转</strong>，转为派生类的指针类型。</p>
</li>
<li><p>由于上传的是vec3，所以fragment的代码uniform接受的是vec3，而color是vec4类型，所以要补充最后A通道</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::string blueShaderfragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">			#version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			in vec3 v_Position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			uniform vec3 u_Color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			void main()&#123;</span></span><br><span class="line"><span class="string">				color = vec4(u_Color, 1.0f);	// 补充最后A通道</span></span><br><span class="line"><span class="string">			&#125;			</span></span><br><span class="line"><span class="string">		)&quot;</span>;</span><br><span class="line">		</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用imgui对应效果图的<strong>颜色选择器</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImgGuiRender</span><span class="params">()</span><span class="keyword">override</span> </span>&#123;</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Settings&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;Square Color&quot;</span>,glm::<span class="built_in">value_ptr</span>(m_SquareColor));</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h4><ul>
<li><p>Shader父类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shader</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shader</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UnBind</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Shader* <span class="title">Create</span><span class="params">(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine </span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">Shader* <span class="title">Shader::Create</span><span class="params">(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> RendererAPI::API::None: <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI:None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">case</span> RendererAPI::API::OpenGL: <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenGLShader</span>(vertexSrc, fragmentSrc);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;UnKnown RendererAPI!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>OpenGlShader子类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">OpenGLShader</span> : <span class="keyword">public</span> Shader</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">OpenGLShader</span>(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc);</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">OpenGLShader</span>();</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Unbind</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">UploadUniformInt</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">UploadUniformFloat</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">float</span> value)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">UploadUniformFloat2</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::vec2&amp; value)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">UploadUniformFloat3</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::vec3&amp; value)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">UploadUniformFloat4</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::vec4&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">UploadUniformMat3</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::mat3&amp; matrix)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">UploadUniformMat4</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">const</span> glm::mat4&amp; matrix)</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="type">uint32_t</span> m_RendererID;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line">	OpenGLShader::<span class="built_in">OpenGLShader</span>(<span class="type">const</span> std::string&amp; vertexSrc, <span class="type">const</span> std::string&amp; fragmentSrc)</span><br><span class="line">	&#123;</span><br><span class="line">		.......</span><br><span class="line">	&#125;</span><br><span class="line">	OpenGLShader::~<span class="built_in">OpenGLShader</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glDeleteProgram</span>(m_RendererID);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLShader::Bind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glUseProgram</span>(m_RendererID);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLShader::UnBind</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glUseProgram</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLShader::UploadUniformInt</span><span class="params">(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		GLint location = <span class="built_in">glGetUniformLocation</span>(m_RendererID, name.<span class="built_in">c_str</span>());</span><br><span class="line">		<span class="built_in">glUniform1i</span>(location, value);</span><br><span class="line">	&#125;</span><br><span class="line">	.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Sandbox.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::string flatColorShaderFragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    in vec3 v_Position;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    uniform vec3 u_Color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        color = vec4(u_Color, 1.0);		//换成输入的动态color</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;	</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnImGuiRender</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ImGui::<span class="built_in">Begin</span>(<span class="string">&quot;Settings&quot;</span>);</span><br><span class="line">    ImGui::<span class="built_in">ColorEdit3</span>(<span class="string">&quot;Square Color&quot;</span>, glm::<span class="built_in">value_ptr</span>(m_SquareColor));</span><br><span class="line">    ImGui::<span class="built_in">End</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="二十七、宏定义智能指针"><a href="#二十七、宏定义智能指针" class="headerlink" title="二十七、宏定义智能指针"></a>二十七、宏定义智能指针</h2><p>此节只是将shared_ptr与unique_ptr给与<strong>别名</strong></p>
<h4 id="代码修改-1"><a href="#代码修改-1" class="headerlink" title="代码修改"></a>代码修改</h4><ul>
<li><p>Core.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line">.....</span><br><span class="line"><span class="keyword">namespace</span> HEngine &#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">using</span> Scope = std::unique_ptr&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">using</span> Ref = std::shared_ptr&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将项目中的shared_ptr变为Ref名字</p>
</li>
</ul>
<h4 id="应该为哪种指针"><a href="#应该为哪种指针" class="headerlink" title="应该为哪种指针"></a>应该为哪种指针</h4><ul>
<li><p>前置C++知识</p>
<p>| 指针类型     | 释放策略                     | 离开作用域时指针是否被释放 |<br>| —————— | —————————————— | ————————————— |<br>| <code>shared_ptr</code> | 引用计数                     | 是，当引用计数为0时        |<br>| <code>unique_ptr</code> | 独占所有权，不允许共享所有权 | 是                         |</p>
</li>
<li><p>思考ExampleLayer中的Shader指针为什么应该为unique_ptr，而不是shared_ptr</p>
<ul>
<li><p>目前运行机制是</p>
<p>C++程序上传数据给shader去渲染，这一段过程需要时间</p>
<p>而电脑屏幕显示的是<strong>上一帧</strong>，显卡现在在渲染<strong>当前帧</strong>。</p>
</li>
<li><p>假设这个类指针指向OpenGLShader，且这个指针是unique_ptr</p>
<ol>
<li>在Renderer中需要用到OpenGLShader上传数据给显卡上的Shader程序，这需要时间。</li>
<li>但是若当前Renderer的容器ExampleLayer<strong>关闭</strong>了，指针离开作用域，那么这个OpenGLShader指针指向的内存也会被<strong>释放</strong></li>
<li>而Renderer中并不知道，还在使用这个指针指向的内存，就会报错。</li>
</ol>
</li>
</ul>
</li>
<li><p>ExampleLayer中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;HEngine::Shader&gt; m_Shader;			<span class="comment">// shader类 指针</span></span><br><span class="line"></span><br><span class="line">HEngine::Renderer::<span class="built_in">Submit</span>(m_Shader, m_VertexArray);	<span class="comment">// 在Onupdate函数中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Renderer的Submit函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Submit</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Shader&gt;&amp; shader, <span class="type">const</span> std::shared_ptr&lt;VertexArray&gt;&amp; vertexArray, glm::mat4 transform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vertexArray-&gt;<span class="built_in">Bind</span>(); </span><br><span class="line">    shader-&gt;<span class="built_in">Bind</span>();		</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(shader)-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_ViewProjection&quot;</span>, m_SceneData-&gt;ViewProjectionMatrix);</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(shader)-&gt;<span class="built_in">UploadUniformMat4</span>(<span class="string">&quot;u_Transform&quot;</span>, transform);</span><br><span class="line"></span><br><span class="line">    RenderCommand::<span class="built_in">DrawIndexed</span>(vertexArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见：Renderer的Submit函数中需要<strong>保持m_Shader存在</strong>才可不会报错</p>
</li>
</ul>
<ul>
<li>解释：OpenGLShader指针指向的内存不会被释放<ol>
<li>函数形参是shared_ptr引用</li>
<li>由于Submit的形参是引用，接受实参时，并不会增加计数，当离开作用域时候，形参也不会减少计数，所以m_Shader的内存还存在</li>
</ol>
</li>
</ul>
<hr>
<h2 id="二十八、添加纹理"><a href="#二十八、添加纹理" class="headerlink" title="二十八、添加纹理"></a>二十八、添加纹理</h2><ul>
<li><p>此节目的: 为了给图形表面赋予纹理Texture</p>
</li>
<li><p>如何实现</p>
<ul>
<li><p>顶点属性中需要有这个顶点的<strong>UV</strong></p>
</li>
<li><p><strong>stb_img</strong>加载图片数据</p>
</li>
<li><p>片段着色器根据当前片段的UV<strong>采样</strong>图片，从而得到当前片段的纹理信息</p>
<p>当图形所有的片段着色器运行完，效果就是图形表面被覆上一张图片</p>
</li>
</ul>
</li>
<li><p>具体说明纹理</p>
<ul>
<li><p>是属于材质Material的一部分</p>
</li>
<li><p>纹理需要被</p>
<p>采样</p>
<ol>
<li>一组顶点位置包围了一个区域</li>
<li>需要为这个区域上色，这些颜色可以从纹理里来</li>
<li>而如何获得纹理的颜色，则需要使用采样方式</li>
</ol>
</li>
<li><p>纹理不止可以包含颜色，还可以包含<strong>高度</strong>什么的，可以不用法线与光源计算就可以得到更逼真一点的模型。</p>
</li>
</ul>
</li>
</ul>
<h4 id="项目引入stb"><a href="#项目引入stb" class="headerlink" title="项目引入stb"></a>项目引入stb</h4><ol>
<li><p>从<a target="_blank" rel="noopener" href="https://github.com/nothings/stb/blob/master/stb_image.h">stb_imgage</a>项目拷贝stb_image.h和cpp到vendor文件夹下</p>
</li>
<li><p>stb_image.cpp文件定义宏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STB_IMAGE_IMPLEMENTATION</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stb_image.h&quot;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码:"></a>代码:</h4><p>创建Texture类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Texture</span></span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">virtual</span> ~<span class="built_in">Texture</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">uint32_t</span> <span class="title">GetWidth</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">uint32_t</span> <span class="title">GetHeight</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Bind</span><span class="params">(<span class="type">uint32_t</span> slot = <span class="number">0</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Texture2D</span> : <span class="keyword">public</span> Texture</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="type">static</span> Ref&lt;Texture2D&gt; <span class="title">Create</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span></span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cpp内的定义</span></span><br><span class="line"><span class="function">Ref&lt;HEngine::Texture2D&gt; <span class="title">Texture2D::Create</span><span class="params">(<span class="type">const</span> std::string&amp; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> RendererAPI::API::None:			<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI::None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">case</span> RendererAPI::API::OpenGL:		<span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;OpenGLTexture2D&gt;(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown RendererAPI!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建子类OpenGLTexture</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;</span><br><span class="line">	OpenGLTexture2D::<span class="built_in">OpenGLTexture2D</span>(<span class="type">const</span> std::string&amp; path)</span><br><span class="line">		:<span class="built_in">m_Path</span>(path)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> width, height, channels;</span><br><span class="line">        <span class="comment">// 设置垂直翻转，由于OpenGL是从上往下渲染的，所以要把图片翻转过来</span></span><br><span class="line">		<span class="built_in">stbi_set_flip_vertically_on_load</span>(<span class="number">1</span>);</span><br><span class="line">		stbi_uc* data = <span class="built_in">stbi_load</span>(path.<span class="built_in">c_str</span>(), &amp;width, &amp;height, &amp;channels, <span class="number">0</span>);</span><br><span class="line">		<span class="built_in">HE_CORE_ASSERT</span>(data, <span class="string">&quot;Failed to load image!&quot;</span>);</span><br><span class="line">		m_Width = width;</span><br><span class="line">		m_Height = height;</span><br><span class="line">            </span><br><span class="line">		<span class="built_in">glCreateTextures</span>(GL_TEXTURE_2D, <span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">		<span class="built_in">glTextureStorage2D</span>(m_RendererID, <span class="number">1</span>, GL_RGB8, m_Width, m_Height);</span><br><span class="line">		<span class="built_in">glTextureParameteri</span>(m_RendererID, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line">        <span class="comment">//纹理放大时用周围颜色的平均值过滤，不然尺寸小的纹理被放到大矩阵上会很糊//</span></span><br><span class="line">		<span class="built_in">glTextureParameteri</span>(m_RendererID, GL_TEXTURE_MAG_FILTER, GL_NEAREST);</span><br><span class="line">		<span class="built_in">glTextureSubImage2D</span>(m_RendererID, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m_Width, m_Height, GL_RGB, GL_UNSIGNED_BYTE, data);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">stbi_image_free</span>(data);</span><br><span class="line">	&#125;</span><br><span class="line">	OpenGLTexture2D::~<span class="built_in">OpenGLTexture2D</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">glDeleteTextures</span>(<span class="number">1</span>, &amp;m_RendererID);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">OpenGLTexture2D::Bind</span><span class="params">(<span class="type">uint32_t</span> slot)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">glBindTextureUnit</span>(slot, m_RendererID);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sandbox.cpp添加图片纹理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> squareVertices[<span class="number">5</span> * <span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>,</span><br><span class="line">    <span class="number">-0.5f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>		<span class="comment">//添加了纹理坐标</span></span><br><span class="line">&#125;;</span><br><span class="line">squareVB-&gt;<span class="built_in">SetLayout</span>(&#123;</span><br><span class="line">    &#123; HEngine::ShaderDataType::Float3, <span class="string">&quot;a_Position&quot;</span>&#125;,</span><br><span class="line">    &#123; HEngine::ShaderDataType::Float2 ,<span class="string">&quot;a_TexCoord&quot;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line">std::string textureShaderVertexSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    layout(location = 0) in vec3 a_Position;</span></span><br><span class="line"><span class="string">    layout(location = 1) in vec2 a_TexCoord;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    uniform mat4 u_ViewProjection;</span></span><br><span class="line"><span class="string">    uniform mat4 u_Transform;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    out vec2 v_TexCoord;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        v_TexCoord = a_TexCoord;</span></span><br><span class="line"><span class="string">        gl_Position = u_ViewProjection * u_Transform * vec4(a_Position, 1.0);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line">std::string textureShaderFragmentSrc = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">    #version 330 core</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    layout(location = 0) out vec4 color;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    in vec2 v_TexCoord;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    uniform sampler2D u_Texture;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void main()</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        color = texture(u_Texture, v_TexCoord);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">)&quot;</span>;</span><br><span class="line"> m_TextureShader.<span class="built_in">reset</span>(HEngine::Shader::<span class="built_in">Create</span>(textureShaderVertexSrc, textureShaderFragmentSrc));</span><br><span class="line"></span><br><span class="line"> m_Texture = HEngine::Texture2D::<span class="built_in">Create</span>(<span class="string">&quot;assets/textures/Checkerboard.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"> std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(m_TextureShader)-&gt;<span class="built_in">Bind</span>();</span><br><span class="line"> std::<span class="built_in">dynamic_pointer_cast</span>&lt;HEngine::OpenGLShader&gt;(m_TextureShader)-&gt;<span class="built_in">UploadUniformInt</span>(<span class="string">&quot;u_Texture&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="效果-3"><a href="#效果-3" class="headerlink" title="效果:"></a>效果:</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/PostImages/2025-3/9.webp" alt="9"></p>
<hr>
<h2 id="二十九、添加混合效果"><a href="#二十九、添加混合效果" class="headerlink" title="二十九、添加混合效果"></a>二十九、添加混合效果</h2><ul>
<li><p>此节目的:  </p>
<p>添加混合效果,使用OpenGL自带的函数即可</p>
</li>
<li><p>什么是混合</p>
<p>两张图片有一部分叠加在一起，需要得出这重叠的部分最终的颜色。</p>
</li>
<li><p>如何混合</p>
<p>根据两张图片的alpha通道，由公式推出来最终颜色。</p>
</li>
</ul>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><p>OpenGLRendererAPI.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLRendererAPI::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glEnable</span>(GL_BLEND);</span><br><span class="line">    <span class="built_in">glBlendFunc</span>(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的图片通道不一样，要先判断读取的图片几个通道的图片，不然会读取颜色出错,需要修改代码</p>
<p>OpenGLTexture.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GLenum internalFormat = <span class="number">0</span>, dataFormat = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (channels == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    internalFormat = GL_RGBA8;</span><br><span class="line">    dataFormat = GL_RGBA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (channels == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    internalFormat = GL_RGB8;</span><br><span class="line">    dataFormat = GL_RGB;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glTextureStorage2D</span>(m_RendererID, <span class="number">1</span>, internalFormat, m_Width, m_Height);</span><br><span class="line"><span class="built_in">glTextureSubImage2D</span>(m_RendererID, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, m_Width, m_Height, dataFormat, </span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三十、-优化着色器文件"><a href="#三十、-优化着色器文件" class="headerlink" title="三十、 优化着色器文件"></a>三十、 优化着色器文件</h2><p>目前的Shader是在代码里写死的，这样写的代码会作为static常量存在内存里。但是游戏引擎里有一个常见的需求，就是<strong>对Shader的热更</strong>，比如说我更改一个Shader，我想立马在游戏里看到更改之后的Shader的效果。如果把Shader写在单独的文件里，就可以重新单独Reload和编译这个新文件。还有个问题，游戏引擎，比如Unity，里面支持在编辑器里写Shader，目前的这种写法不满足这种用户需求。</p>
<p>之前学习OpenGL时，一个ShaderProgram是有多个文件的，分别存放vert shader、fragment shader等，而DX是都放在一个文件里的。感觉都放一个文件里更科学一点，所以这边创建文件是下面这样的格式：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#type vertex				<span class="comment">// 注意：这是自己定义的字符串里分隔Shader的方法，不是官方写法</span></span><br><span class="line"><span class="params">...</span><span class="comment">//写原本的vertex shader</span></span><br><span class="line"></span><br><span class="line">#type fragment</span><br><span class="line"><span class="params">...</span><span class="comment">//写原本的fragment shader</span></span><br></pre></td></tr></table></figure>
<p>然后利用<code>ifstream</code>来读取文件，得到string，再寻找上面的<code>#type ...</code>这种东西，把一个大的string，分为多个string，每个细分后的string对应一种shader。</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><p>OpenGLShader.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HEngine</span><br><span class="line">&#123;	</span><br><span class="line">	<span class="function"><span class="type">static</span> GLenum <span class="title">ShaderTypeFromString</span><span class="params">(<span class="type">const</span> std::string&amp; type)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (type == <span class="string">&quot;vertex&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> GL_VERTEX_SHADER;</span><br><span class="line">		<span class="keyword">if</span> (type == <span class="string">&quot;fragment&quot;</span> || type == <span class="string">&quot;pixel&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span> GL_FRAGMENT_SHADER;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown shader type!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	OpenGLShader::<span class="built_in">OpenGLShader</span>(<span class="type">const</span> std::string&amp; filepath)</span><br><span class="line">	&#123;</span><br><span class="line">		std::string source = <span class="built_in">ReadFile</span>(filepath);</span><br><span class="line">		<span class="keyword">auto</span> shaderSources = <span class="built_in">PreProcess</span>(source);</span><br><span class="line">		<span class="built_in">Complie</span>(shaderSources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">std::string <span class="title">OpenGLShader::ReadFile</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::string result;</span><br><span class="line">		<span class="function">std::ifstream <span class="title">in</span><span class="params">(filepath, std::ios::in, std::ios::binary)</span></span>;</span><br><span class="line">		<span class="keyword">if</span> (in)</span><br><span class="line">		&#123;</span><br><span class="line">			in.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::end);</span><br><span class="line">			result.<span class="built_in">resize</span>(in.<span class="built_in">tellg</span>());</span><br><span class="line">			in.<span class="built_in">seekg</span>(<span class="number">0</span>, std::ios::beg);</span><br><span class="line">			in.<span class="built_in">read</span>(&amp;result[<span class="number">0</span>], result.<span class="built_in">size</span>());</span><br><span class="line">			in.<span class="built_in">close</span>();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">HE_CORE_ERROR</span>(<span class="string">&quot;Could not open file &#x27;&#123;0&#125;&#x27;&quot;</span>, filepath);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">std::unordered_map&lt;GLenum, std::string&gt; <span class="title">OpenGLShader::PreProcess</span><span class="params">(<span class="type">const</span> std::string&amp; source)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		std::unordered_map&lt;GLenum, std::string&gt;shaderSources;</span><br><span class="line"></span><br><span class="line">		<span class="type">const</span> <span class="type">char</span>* typeToken = <span class="string">&quot;#type&quot;</span>;</span><br><span class="line">		<span class="type">size_t</span> typeTokenLength = <span class="built_in">strlen</span>(typeToken);</span><br><span class="line">		<span class="type">size_t</span> pos = source.<span class="built_in">find</span>(typeToken, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span> (pos != std::string::npos)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">size_t</span> eol = source.<span class="built_in">find_first_of</span>(<span class="string">&quot;\r\n&quot;</span>, pos);</span><br><span class="line">			<span class="built_in">HE_CORE_ASSERT</span>(eol != std::string::npos, <span class="string">&quot;Syntax error&quot;</span>);</span><br><span class="line">			<span class="type">size_t</span> begin = pos + typeTokenLength + <span class="number">1</span>;</span><br><span class="line">			std::string type = source.<span class="built_in">substr</span>(begin, eol - begin);</span><br><span class="line">			<span class="built_in">HE_CORE_ASSERT</span>(<span class="built_in">ShaderTypeFromString</span>(type), <span class="string">&quot;Invalid shader type specified&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="type">size_t</span> nextLinePos = source.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;\r\n&quot;</span>, eol);</span><br><span class="line">			pos = source.<span class="built_in">find</span>(typeToken, nextLinePos);</span><br><span class="line">			shaderSources[<span class="built_in">ShaderTypeFromString</span>(type)] = source.<span class="built_in">substr</span>(nextLinePos, pos - (nextLinePos == std::string::npos ? source.<span class="built_in">size</span>() - <span class="number">1</span> : nextLinePos));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> shaderSources;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Shandr.cpp</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Shader* <span class="title">Shader::Create</span><span class="params">(<span class="type">const</span> std::string&amp; filepath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (Renderer::<span class="built_in">GetAPI</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">case</span> RendererAPI::API::None:    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;RendererAPI::None is currently not supported!&quot;</span>); <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    	<span class="keyword">case</span> RendererAPI::API::OpenGL:  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">OpenGLShader</span>(filepath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HE_CORE_ASSERT</span>(<span class="literal">false</span>, <span class="string">&quot;Unknown RendererAPI!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把之前SandboxApp中shader的字符串移到一个文件里面,后缀为glsl</p>
<p>然后SandboxApp就只用这一句就可以了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_TextureShader.<span class="built_in">reset</span>(HEngine::Shader::<span class="built_in">Create</span>(<span class="string">&quot;assets/shaders/Texture.glsl&quot;</span>));</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>HEngine游戏引擎(01-30)</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://donghuiw.github.io/posts/81e1b394">https://donghuiw.github.io/posts/81e1b394</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>DongHuiWang</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2025-03-02</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-03-13</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>游戏引擎</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://gitee.com/winterdev/images/raw/master/wx.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/wx.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://gitee.com/winterdev/images/raw/master/zfb.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/zfb.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/39541a22"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover5.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hexo博客搭建教程</div></div></a></div><div class="next-post pull-right"><a href="/posts/e0684db9"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover4.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">游戏引擎开发补充知识点</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/e0684db9" title="游戏引擎开发补充知识点"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover4.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-03-18</div><div class="title">游戏引擎开发补充知识点</div></div></a></div><div><a href="/posts/a1665e0e" title="Premake5使用及问题汇总"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover4.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-03-13</div><div class="title">Premake5使用及问题汇总</div></div></a></div><div><a href="/posts/b6d9ed88" title="实体组件系统(ECS)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover5.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-03-14</div><div class="title">实体组件系统(ECS)</div></div></a></div><div><a href="/posts/3ad536fd" title="HEngine游戏引擎-31-60"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover2.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-03-17</div><div class="title">HEngine游戏引擎-31-60</div></div></a></div><div><a href="/posts/75ada542" title="HEngine游戏引擎-61-90"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover5.webp" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2025-07-23</div><div class="title">HEngine游戏引擎-61-90</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81-%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE"><span class="toc-text">一、  项目设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3"><span class="toc-text">二、  程序入口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6"><span class="toc-text">代码文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81"><span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">程序运行流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F-Premake"><span class="toc-text">三、  日志系统 + Premake</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Git%E5%88%A0%E9%99%A4%E5%AD%90%E6%A8%A1%E5%9D%97"><span class="toc-text">Git删除子模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Premake5%E4%BD%BF%E7%94%A8%E5%8F%8A%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB"><span class="toc-text">Premake5使用及问题汇总</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81-%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">四、  事件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E9%A2%84%E7%BC%96%E8%AF%91%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">五、  预编译头文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81-GlFW%E7%AA%97%E5%8F%A3"><span class="toc-text">六、  GlFW窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Window%E7%B1%BB"><span class="toc-text">Window类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E4%BF%AE%E6%94%B9"><span class="toc-text">其它修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81-GLFW%E4%BA%8B%E4%BB%B6"><span class="toc-text">七、  GLFW事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81-%E8%AE%BE%E8%AE%A1%E6%B8%B8%E6%88%8F%E7%9A%84%E5%B1%82%E7%BA%A7%E6%A1%86%E6%9E%B6"><span class="toc-text">八、  设计游戏的层级框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81-%E6%B7%BB%E5%8A%A0GLAD"><span class="toc-text">九、  添加GLAD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81-ImGui%E5%B1%82"><span class="toc-text">十、  ImGui层</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8ImGui%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">怎么使用ImGui的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAImGUILayer"><span class="toc-text">创建ImGUILayer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81-%E7%BB%99ImGui%E6%B7%BB%E5%8A%A0%E4%BA%8B%E4%BB%B6"><span class="toc-text">十一、 给ImGui添加事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%86%99ImGui%E7%9A%84%E4%BA%8B%E4%BB%B6"><span class="toc-text">如何写ImGui的事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3"><span class="toc-text">项目相关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81-%E8%BE%93%E5%85%A5%E4%BA%8B%E4%BB%B6%E8%BD%AE%E8%AF%A2"><span class="toc-text">十二、 输入事件轮询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-text">测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81-%E6%B7%BB%E5%8A%A0Math%E5%BA%93"><span class="toc-text">十三、 添加Math库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81-ImGui%E5%81%9C%E9%9D%A0%E5%8A%9F%E8%83%BD"><span class="toc-text">十四、 ImGui停靠功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">遇到的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81-HEngine%E6%94%B9%E4%B8%BA%E9%9D%99%E6%80%81%E5%BA%93"><span class="toc-text">十五、 HEngine改为静态库</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E5%BC%95%E6%93%8E%E4%BB%8Edll%E6%94%B9%E4%B8%BAlib"><span class="toc-text">如何将引擎从dll改为lib</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E3%80%81-%E6%B8%B2%E6%9F%93%E5%89%8D%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-text">十六、 渲染前准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%E3%80%81-%E6%B8%B2%E6%9F%93%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-text">十七、 渲染第一个三角形!</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E6%9E%9C"><span class="toc-text">效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%85%AB%E3%80%81-%E6%B7%BB%E5%8A%A0%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-text">十八、 添加着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E6%9E%9C-1"><span class="toc-text">效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D%E3%80%81-%E5%B0%81%E8%A3%85Buffer%E7%B1%BB"><span class="toc-text">十九、 封装Buffer类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9"><span class="toc-text">代码修改</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E3%80%81-%E8%AE%BE%E8%AE%A1%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2%E5%8C%BA%E5%B8%83%E5%B1%80"><span class="toc-text">二十、 设计顶点缓冲区布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80%E3%80%81%E6%B7%BB%E5%8A%A0%E9%A1%B6%E7%82%B9%E6%95%B0%E7%BB%84"><span class="toc-text">二十一、添加顶点数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AAVBO%E6%9D%A5%E9%AA%8C%E8%AF%81"><span class="toc-text">多个VBO来验证</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%E3%80%81%E8%AE%BE%E8%AE%A1%E6%B8%B2%E6%9F%93%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="toc-text">二十二、设计渲染器架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E8%8A%82%E8%A6%81%E5%81%9A%E7%9A%84%E5%AE%9E%E9%99%85%E5%86%85%E5%AE%B9"><span class="toc-text">本节要做的实际内容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%89%E3%80%81%E6%AD%A3%E4%BA%A4%E6%91%84%E5%83%8F%E6%9C%BA%E5%AE%9E%E7%8E%B0"><span class="toc-text">二十三、正交摄像机实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-1"><span class="toc-text">遇到的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GLM%E5%BA%93%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="toc-text">GLM库函数相关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%9B%9B%E3%80%81%E6%B7%BB%E5%8A%A0Timestep%E7%B3%BB%E7%BB%9F"><span class="toc-text">二十四、添加Timestep系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84Timestep%E7%B3%BB%E7%BB%9F"><span class="toc-text">三种不同的Timestep系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HEngine%E5%BC%95%E6%93%8E%E9%87%8C%E7%9A%84Timestep%E7%B3%BB%E7%BB%9F"><span class="toc-text">HEngine引擎里的Timestep系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8AApplication-cpp%E9%87%8C%E7%9A%84%E5%86%85%E5%AE%B9%E7%A7%BB%E5%88%B0Sandbox%E5%AF%B9%E5%BA%94%E7%9A%84Project"><span class="toc-text">把Application.cpp里的内容移到Sandbox对应的Project</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%94%E3%80%81%E7%9F%A9%E9%98%B5%E4%BD%8D%E7%BD%AE%E3%80%81%E6%97%8B%E8%BD%AC%E3%80%81%E7%BC%A9%E6%94%BE"><span class="toc-text">二十五、矩阵位置、旋转、缩放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E6%9E%9C-2"><span class="toc-text">效果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AD%E3%80%81%E7%9D%80%E8%89%B2%E5%99%A8%E5%B0%81%E8%A3%85"><span class="toc-text">二十六、着色器封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81-1"><span class="toc-text">关键代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="toc-text">具体代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%83%E3%80%81%E5%AE%8F%E5%AE%9A%E4%B9%89%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">二十七、宏定义智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9-1"><span class="toc-text">代码修改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E8%AF%A5%E4%B8%BA%E5%93%AA%E7%A7%8D%E6%8C%87%E9%92%88"><span class="toc-text">应该为哪种指针</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AB%E3%80%81%E6%B7%BB%E5%8A%A0%E7%BA%B9%E7%90%86"><span class="toc-text">二十八、添加纹理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%BC%95%E5%85%A5stb"><span class="toc-text">项目引入stb</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-text">代码:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E6%9E%9C-3"><span class="toc-text">效果:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B9%9D%E3%80%81%E6%B7%BB%E5%8A%A0%E6%B7%B7%E5%90%88%E6%95%88%E6%9E%9C"><span class="toc-text">二十九、添加混合效果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E3%80%81-%E4%BC%98%E5%8C%96%E7%9D%80%E8%89%B2%E5%99%A8%E6%96%87%E4%BB%B6"><span class="toc-text">三十、 优化着色器文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>放下个人素质 享受缺德人生 <br/>拒绝精神内耗 有事直接发疯^_^✨</div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/">文章统计</a><a href="/">我的唠叨</a></li><li><a href="/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a target="_blank" rel="noopener" href="https://fyfan.cn/" title="我的友友付少"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/fufan1025/blog_image_other/raw/master/avatar.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2024-2025</b></span><span><b>&nbsp;&nbsp;By DongHuiWang</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/CDN-TianliCDN.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.bitiful.net/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.winterdev.cn',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.winterdev.cn',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.winterdev.cn',
        region: '',
        pageSize: 5,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><meta name="referrer" content="no-referrer" /><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/butterfly-extsrc/1.1.3/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://donghuiw.github.io/categories/游戏引擎/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍨 游戏引擎学习笔记 (6)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://donghuiw.github.io/categories/演示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 案例演示笔记 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://donghuiw.github.io/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/48514759.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover8.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-07-22</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/48514759.html&quot;);" href="javascript:void(0);" alt="">游戏引擎HEngine项目展示</a><div class="blog-slider__text">自研游戏引擎HEngine相关介绍</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/48514759.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/94bccdc7.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover3.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-07-21</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/94bccdc7.html&quot;);" href="javascript:void(0);" alt="">Unity项目展示</a><div class="blog-slider__text">我的Unity项目展示</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/94bccdc7.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/81e1b394.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover6.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/81e1b394.html&quot;);" href="javascript:void(0);" alt="">HEngine游戏引擎(01-30)</a><div class="blog-slider__text">记录HEngine每一次提交的重点内容以及遇到的问题和解决的步骤</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/81e1b394.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/3ad536fd.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover2.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-11</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/3ad536fd.html&quot;);" href="javascript:void(0);" alt="">HEngine游戏引擎-31-60</a><div class="blog-slider__text">记录HEngine每一次提交的重点内容以及遇到的问题和解决的步骤</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/3ad536fd.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/b6d9ed88.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover5.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/b6d9ed88.html&quot;);" href="javascript:void(0);" alt="">实体组件系统(ECS)</a><div class="blog-slider__text">介绍实体组件系统(ECS)的好处以及为什么要实体组件系统</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/b6d9ed88.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/75ada542.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover5.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-17</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/75ada542.html&quot;);" href="javascript:void(0);" alt="">HEngine游戏引擎-61-90</a><div class="blog-slider__text">记录HEngine每一次提交的重点内容以及遇到的问题和解决的步骤</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/75ada542.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/a1665e0e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/a1665e0e.html&quot;);" href="javascript:void(0);" alt="">Premake5使用及问题汇总</a><div class="blog-slider__text">记录一些Premake5写法和使用中遇到的问题</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/a1665e0e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/e0684db9.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover4.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-03-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/e0684db9.html&quot;);" href="javascript:void(0);" alt="">游戏引擎开发补充知识点</a><div class="blog-slider__text">记录制作游戏引擎遇到的新知识点，包括c++知识和模式设计思路等</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/e0684db9.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover5.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-06-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/39541a22.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gitee.com/winterdev/images/raw/master/blog_cover5.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2025-02-27</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/39541a22.html&quot;);" href="javascript:void(0);" alt="">Hexo博客搭建教程</a><div class="blog-slider__text">暂无描述</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/39541a22.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>